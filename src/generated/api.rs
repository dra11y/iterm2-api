// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:iterm2.ClientOriginatedMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientOriginatedMessage {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ClientOriginatedMessage.id)
    pub id: ::std::option::Option<i64>,
    // message oneof groups
    pub submessage: ::std::option::Option<client_originated_message::Submessage>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ClientOriginatedMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientOriginatedMessage {
    fn default() -> &'a ClientOriginatedMessage {
        <ClientOriginatedMessage as ::protobuf::Message>::default_instance()
    }
}

impl ClientOriginatedMessage {
    pub fn new() -> ClientOriginatedMessage {
        ::std::default::Default::default()
    }

    // optional int64 id = 1;

    pub fn id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional .iterm2.GetBufferRequest get_buffer_request = 100;

    pub fn get_buffer_request(&self) -> &GetBufferRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::GetBufferRequest(ref v)) => v,
            _ => <GetBufferRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_buffer_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_get_buffer_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::GetBufferRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_buffer_request(&mut self, v: GetBufferRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::GetBufferRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_buffer_request(&mut self) -> &mut GetBufferRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::GetBufferRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::GetBufferRequest(GetBufferRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::GetBufferRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_buffer_request(&mut self) -> GetBufferRequest {
        if self.has_get_buffer_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::GetBufferRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            GetBufferRequest::new()
        }
    }

    // optional .iterm2.GetPromptRequest get_prompt_request = 101;

    pub fn get_prompt_request(&self) -> &GetPromptRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::GetPromptRequest(ref v)) => v,
            _ => <GetPromptRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_prompt_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_get_prompt_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::GetPromptRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_prompt_request(&mut self, v: GetPromptRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::GetPromptRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_prompt_request(&mut self) -> &mut GetPromptRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::GetPromptRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::GetPromptRequest(GetPromptRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::GetPromptRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_prompt_request(&mut self) -> GetPromptRequest {
        if self.has_get_prompt_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::GetPromptRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            GetPromptRequest::new()
        }
    }

    // optional .iterm2.TransactionRequest transaction_request = 102;

    pub fn transaction_request(&self) -> &TransactionRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::TransactionRequest(ref v)) => v,
            _ => <TransactionRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_transaction_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_transaction_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::TransactionRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transaction_request(&mut self, v: TransactionRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::TransactionRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transaction_request(&mut self) -> &mut TransactionRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::TransactionRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::TransactionRequest(TransactionRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::TransactionRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transaction_request(&mut self) -> TransactionRequest {
        if self.has_transaction_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::TransactionRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionRequest::new()
        }
    }

    // optional .iterm2.NotificationRequest notification_request = 103;

    pub fn notification_request(&self) -> &NotificationRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::NotificationRequest(ref v)) => v,
            _ => <NotificationRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_notification_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_notification_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::NotificationRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_notification_request(&mut self, v: NotificationRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::NotificationRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_notification_request(&mut self) -> &mut NotificationRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::NotificationRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::NotificationRequest(NotificationRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::NotificationRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_notification_request(&mut self) -> NotificationRequest {
        if self.has_notification_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::NotificationRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            NotificationRequest::new()
        }
    }

    // optional .iterm2.RegisterToolRequest register_tool_request = 104;

    pub fn register_tool_request(&self) -> &RegisterToolRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::RegisterToolRequest(ref v)) => v,
            _ => <RegisterToolRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_register_tool_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_register_tool_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::RegisterToolRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_register_tool_request(&mut self, v: RegisterToolRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::RegisterToolRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_register_tool_request(&mut self) -> &mut RegisterToolRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::RegisterToolRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::RegisterToolRequest(RegisterToolRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::RegisterToolRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_register_tool_request(&mut self) -> RegisterToolRequest {
        if self.has_register_tool_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::RegisterToolRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            RegisterToolRequest::new()
        }
    }

    // optional .iterm2.SetProfilePropertyRequest set_profile_property_request = 105;

    pub fn set_profile_property_request(&self) -> &SetProfilePropertyRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SetProfilePropertyRequest(ref v)) => v,
            _ => <SetProfilePropertyRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_profile_property_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_set_profile_property_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SetProfilePropertyRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_profile_property_request(&mut self, v: SetProfilePropertyRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SetProfilePropertyRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_profile_property_request(&mut self) -> &mut SetProfilePropertyRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::SetProfilePropertyRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SetProfilePropertyRequest(SetProfilePropertyRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SetProfilePropertyRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_profile_property_request(&mut self) -> SetProfilePropertyRequest {
        if self.has_set_profile_property_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::SetProfilePropertyRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            SetProfilePropertyRequest::new()
        }
    }

    // optional .iterm2.ListSessionsRequest list_sessions_request = 106;

    pub fn list_sessions_request(&self) -> &ListSessionsRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ListSessionsRequest(ref v)) => v,
            _ => <ListSessionsRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_list_sessions_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_list_sessions_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ListSessionsRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_sessions_request(&mut self, v: ListSessionsRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ListSessionsRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_sessions_request(&mut self) -> &mut ListSessionsRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::ListSessionsRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ListSessionsRequest(ListSessionsRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ListSessionsRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_sessions_request(&mut self) -> ListSessionsRequest {
        if self.has_list_sessions_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::ListSessionsRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            ListSessionsRequest::new()
        }
    }

    // optional .iterm2.SendTextRequest send_text_request = 107;

    pub fn send_text_request(&self) -> &SendTextRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SendTextRequest(ref v)) => v,
            _ => <SendTextRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_send_text_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_send_text_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SendTextRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_send_text_request(&mut self, v: SendTextRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SendTextRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_send_text_request(&mut self) -> &mut SendTextRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::SendTextRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SendTextRequest(SendTextRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SendTextRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_send_text_request(&mut self) -> SendTextRequest {
        if self.has_send_text_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::SendTextRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            SendTextRequest::new()
        }
    }

    // optional .iterm2.CreateTabRequest create_tab_request = 108;

    pub fn create_tab_request(&self) -> &CreateTabRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::CreateTabRequest(ref v)) => v,
            _ => <CreateTabRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_create_tab_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_create_tab_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::CreateTabRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_tab_request(&mut self, v: CreateTabRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::CreateTabRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_tab_request(&mut self) -> &mut CreateTabRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::CreateTabRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::CreateTabRequest(CreateTabRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::CreateTabRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_tab_request(&mut self) -> CreateTabRequest {
        if self.has_create_tab_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::CreateTabRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            CreateTabRequest::new()
        }
    }

    // optional .iterm2.SplitPaneRequest split_pane_request = 109;

    pub fn split_pane_request(&self) -> &SplitPaneRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SplitPaneRequest(ref v)) => v,
            _ => <SplitPaneRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_split_pane_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_split_pane_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SplitPaneRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_split_pane_request(&mut self, v: SplitPaneRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SplitPaneRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_split_pane_request(&mut self) -> &mut SplitPaneRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::SplitPaneRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SplitPaneRequest(SplitPaneRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SplitPaneRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_split_pane_request(&mut self) -> SplitPaneRequest {
        if self.has_split_pane_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::SplitPaneRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            SplitPaneRequest::new()
        }
    }

    // optional .iterm2.GetProfilePropertyRequest get_profile_property_request = 110;

    pub fn get_profile_property_request(&self) -> &GetProfilePropertyRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::GetProfilePropertyRequest(ref v)) => v,
            _ => <GetProfilePropertyRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_profile_property_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_get_profile_property_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::GetProfilePropertyRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_profile_property_request(&mut self, v: GetProfilePropertyRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::GetProfilePropertyRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_profile_property_request(&mut self) -> &mut GetProfilePropertyRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::GetProfilePropertyRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::GetProfilePropertyRequest(GetProfilePropertyRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::GetProfilePropertyRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_profile_property_request(&mut self) -> GetProfilePropertyRequest {
        if self.has_get_profile_property_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::GetProfilePropertyRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            GetProfilePropertyRequest::new()
        }
    }

    // optional .iterm2.SetPropertyRequest set_property_request = 111;

    pub fn set_property_request(&self) -> &SetPropertyRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SetPropertyRequest(ref v)) => v,
            _ => <SetPropertyRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_property_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_set_property_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SetPropertyRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_property_request(&mut self, v: SetPropertyRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SetPropertyRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_property_request(&mut self) -> &mut SetPropertyRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::SetPropertyRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SetPropertyRequest(SetPropertyRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SetPropertyRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_property_request(&mut self) -> SetPropertyRequest {
        if self.has_set_property_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::SetPropertyRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            SetPropertyRequest::new()
        }
    }

    // optional .iterm2.GetPropertyRequest get_property_request = 112;

    pub fn get_property_request(&self) -> &GetPropertyRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::GetPropertyRequest(ref v)) => v,
            _ => <GetPropertyRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_property_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_get_property_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::GetPropertyRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_property_request(&mut self, v: GetPropertyRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::GetPropertyRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_property_request(&mut self) -> &mut GetPropertyRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::GetPropertyRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::GetPropertyRequest(GetPropertyRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::GetPropertyRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_property_request(&mut self) -> GetPropertyRequest {
        if self.has_get_property_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::GetPropertyRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            GetPropertyRequest::new()
        }
    }

    // optional .iterm2.InjectRequest inject_request = 113;

    pub fn inject_request(&self) -> &InjectRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::InjectRequest(ref v)) => v,
            _ => <InjectRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_inject_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_inject_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::InjectRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_inject_request(&mut self, v: InjectRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::InjectRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_inject_request(&mut self) -> &mut InjectRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::InjectRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::InjectRequest(InjectRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::InjectRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_inject_request(&mut self) -> InjectRequest {
        if self.has_inject_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::InjectRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            InjectRequest::new()
        }
    }

    // optional .iterm2.ActivateRequest activate_request = 114;

    pub fn activate_request(&self) -> &ActivateRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ActivateRequest(ref v)) => v,
            _ => <ActivateRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_activate_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_activate_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ActivateRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_activate_request(&mut self, v: ActivateRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ActivateRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_activate_request(&mut self) -> &mut ActivateRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::ActivateRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ActivateRequest(ActivateRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ActivateRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_activate_request(&mut self) -> ActivateRequest {
        if self.has_activate_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::ActivateRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            ActivateRequest::new()
        }
    }

    // optional .iterm2.VariableRequest variable_request = 115;

    pub fn variable_request(&self) -> &VariableRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::VariableRequest(ref v)) => v,
            _ => <VariableRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_variable_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_variable_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::VariableRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_variable_request(&mut self, v: VariableRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::VariableRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_variable_request(&mut self) -> &mut VariableRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::VariableRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::VariableRequest(VariableRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::VariableRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_variable_request(&mut self) -> VariableRequest {
        if self.has_variable_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::VariableRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            VariableRequest::new()
        }
    }

    // optional .iterm2.SavedArrangementRequest saved_arrangement_request = 116;

    pub fn saved_arrangement_request(&self) -> &SavedArrangementRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SavedArrangementRequest(ref v)) => v,
            _ => <SavedArrangementRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_saved_arrangement_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_saved_arrangement_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SavedArrangementRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_saved_arrangement_request(&mut self, v: SavedArrangementRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SavedArrangementRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_saved_arrangement_request(&mut self) -> &mut SavedArrangementRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::SavedArrangementRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SavedArrangementRequest(SavedArrangementRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SavedArrangementRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_saved_arrangement_request(&mut self) -> SavedArrangementRequest {
        if self.has_saved_arrangement_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::SavedArrangementRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedArrangementRequest::new()
        }
    }

    // optional .iterm2.FocusRequest focus_request = 117;

    pub fn focus_request(&self) -> &FocusRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::FocusRequest(ref v)) => v,
            _ => <FocusRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_focus_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_focus_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::FocusRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_focus_request(&mut self, v: FocusRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::FocusRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_focus_request(&mut self) -> &mut FocusRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::FocusRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::FocusRequest(FocusRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::FocusRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_focus_request(&mut self) -> FocusRequest {
        if self.has_focus_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::FocusRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            FocusRequest::new()
        }
    }

    // optional .iterm2.ListProfilesRequest list_profiles_request = 118;

    pub fn list_profiles_request(&self) -> &ListProfilesRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ListProfilesRequest(ref v)) => v,
            _ => <ListProfilesRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_list_profiles_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_list_profiles_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ListProfilesRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_profiles_request(&mut self, v: ListProfilesRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ListProfilesRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_profiles_request(&mut self) -> &mut ListProfilesRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::ListProfilesRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ListProfilesRequest(ListProfilesRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ListProfilesRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_profiles_request(&mut self) -> ListProfilesRequest {
        if self.has_list_profiles_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::ListProfilesRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            ListProfilesRequest::new()
        }
    }

    // optional .iterm2.ServerOriginatedRPCResultRequest server_originated_rpc_result_request = 119;

    pub fn server_originated_rpc_result_request(&self) -> &ServerOriginatedRPCResultRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ServerOriginatedRpcResultRequest(ref v)) => v,
            _ => <ServerOriginatedRPCResultRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_server_originated_rpc_result_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_server_originated_rpc_result_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ServerOriginatedRpcResultRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_server_originated_rpc_result_request(&mut self, v: ServerOriginatedRPCResultRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ServerOriginatedRpcResultRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_server_originated_rpc_result_request(&mut self) -> &mut ServerOriginatedRPCResultRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::ServerOriginatedRpcResultRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ServerOriginatedRpcResultRequest(ServerOriginatedRPCResultRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ServerOriginatedRpcResultRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_server_originated_rpc_result_request(&mut self) -> ServerOriginatedRPCResultRequest {
        if self.has_server_originated_rpc_result_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::ServerOriginatedRpcResultRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            ServerOriginatedRPCResultRequest::new()
        }
    }

    // optional .iterm2.RestartSessionRequest restart_session_request = 120;

    pub fn restart_session_request(&self) -> &RestartSessionRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::RestartSessionRequest(ref v)) => v,
            _ => <RestartSessionRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_restart_session_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_restart_session_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::RestartSessionRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_restart_session_request(&mut self, v: RestartSessionRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::RestartSessionRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_restart_session_request(&mut self) -> &mut RestartSessionRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::RestartSessionRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::RestartSessionRequest(RestartSessionRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::RestartSessionRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_restart_session_request(&mut self) -> RestartSessionRequest {
        if self.has_restart_session_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::RestartSessionRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            RestartSessionRequest::new()
        }
    }

    // optional .iterm2.MenuItemRequest menu_item_request = 121;

    pub fn menu_item_request(&self) -> &MenuItemRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::MenuItemRequest(ref v)) => v,
            _ => <MenuItemRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_menu_item_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_menu_item_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::MenuItemRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_menu_item_request(&mut self, v: MenuItemRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::MenuItemRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_menu_item_request(&mut self) -> &mut MenuItemRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::MenuItemRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::MenuItemRequest(MenuItemRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::MenuItemRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_menu_item_request(&mut self) -> MenuItemRequest {
        if self.has_menu_item_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::MenuItemRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            MenuItemRequest::new()
        }
    }

    // optional .iterm2.SetTabLayoutRequest set_tab_layout_request = 122;

    pub fn set_tab_layout_request(&self) -> &SetTabLayoutRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SetTabLayoutRequest(ref v)) => v,
            _ => <SetTabLayoutRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_tab_layout_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_set_tab_layout_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SetTabLayoutRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_tab_layout_request(&mut self, v: SetTabLayoutRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SetTabLayoutRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_tab_layout_request(&mut self) -> &mut SetTabLayoutRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::SetTabLayoutRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SetTabLayoutRequest(SetTabLayoutRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SetTabLayoutRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_tab_layout_request(&mut self) -> SetTabLayoutRequest {
        if self.has_set_tab_layout_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::SetTabLayoutRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            SetTabLayoutRequest::new()
        }
    }

    // optional .iterm2.GetBroadcastDomainsRequest get_broadcast_domains_request = 123;

    pub fn get_broadcast_domains_request(&self) -> &GetBroadcastDomainsRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::GetBroadcastDomainsRequest(ref v)) => v,
            _ => <GetBroadcastDomainsRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_broadcast_domains_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_get_broadcast_domains_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::GetBroadcastDomainsRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_broadcast_domains_request(&mut self, v: GetBroadcastDomainsRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::GetBroadcastDomainsRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_broadcast_domains_request(&mut self) -> &mut GetBroadcastDomainsRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::GetBroadcastDomainsRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::GetBroadcastDomainsRequest(GetBroadcastDomainsRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::GetBroadcastDomainsRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_broadcast_domains_request(&mut self) -> GetBroadcastDomainsRequest {
        if self.has_get_broadcast_domains_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::GetBroadcastDomainsRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            GetBroadcastDomainsRequest::new()
        }
    }

    // optional .iterm2.TmuxRequest tmux_request = 124;

    pub fn tmux_request(&self) -> &TmuxRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::TmuxRequest(ref v)) => v,
            _ => <TmuxRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_tmux_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_tmux_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::TmuxRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tmux_request(&mut self, v: TmuxRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::TmuxRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tmux_request(&mut self) -> &mut TmuxRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::TmuxRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::TmuxRequest(TmuxRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::TmuxRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tmux_request(&mut self) -> TmuxRequest {
        if self.has_tmux_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::TmuxRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            TmuxRequest::new()
        }
    }

    // optional .iterm2.ReorderTabsRequest reorder_tabs_request = 125;

    pub fn reorder_tabs_request(&self) -> &ReorderTabsRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ReorderTabsRequest(ref v)) => v,
            _ => <ReorderTabsRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_reorder_tabs_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_reorder_tabs_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ReorderTabsRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reorder_tabs_request(&mut self, v: ReorderTabsRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ReorderTabsRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reorder_tabs_request(&mut self) -> &mut ReorderTabsRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::ReorderTabsRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ReorderTabsRequest(ReorderTabsRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ReorderTabsRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reorder_tabs_request(&mut self) -> ReorderTabsRequest {
        if self.has_reorder_tabs_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::ReorderTabsRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            ReorderTabsRequest::new()
        }
    }

    // optional .iterm2.PreferencesRequest preferences_request = 126;

    pub fn preferences_request(&self) -> &PreferencesRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::PreferencesRequest(ref v)) => v,
            _ => <PreferencesRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_preferences_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_preferences_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::PreferencesRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_preferences_request(&mut self, v: PreferencesRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::PreferencesRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_preferences_request(&mut self) -> &mut PreferencesRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::PreferencesRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::PreferencesRequest(PreferencesRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::PreferencesRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_preferences_request(&mut self) -> PreferencesRequest {
        if self.has_preferences_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::PreferencesRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            PreferencesRequest::new()
        }
    }

    // optional .iterm2.ColorPresetRequest color_preset_request = 127;

    pub fn color_preset_request(&self) -> &ColorPresetRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ColorPresetRequest(ref v)) => v,
            _ => <ColorPresetRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_color_preset_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_color_preset_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ColorPresetRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_color_preset_request(&mut self, v: ColorPresetRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ColorPresetRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_color_preset_request(&mut self) -> &mut ColorPresetRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::ColorPresetRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ColorPresetRequest(ColorPresetRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ColorPresetRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_color_preset_request(&mut self) -> ColorPresetRequest {
        if self.has_color_preset_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::ColorPresetRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            ColorPresetRequest::new()
        }
    }

    // optional .iterm2.SelectionRequest selection_request = 128;

    pub fn selection_request(&self) -> &SelectionRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SelectionRequest(ref v)) => v,
            _ => <SelectionRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_selection_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_selection_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SelectionRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_selection_request(&mut self, v: SelectionRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SelectionRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_selection_request(&mut self) -> &mut SelectionRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::SelectionRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SelectionRequest(SelectionRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SelectionRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_selection_request(&mut self) -> SelectionRequest {
        if self.has_selection_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::SelectionRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            SelectionRequest::new()
        }
    }

    // optional .iterm2.StatusBarComponentRequest status_bar_component_request = 129;

    pub fn status_bar_component_request(&self) -> &StatusBarComponentRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::StatusBarComponentRequest(ref v)) => v,
            _ => <StatusBarComponentRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_status_bar_component_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_status_bar_component_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::StatusBarComponentRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_status_bar_component_request(&mut self, v: StatusBarComponentRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::StatusBarComponentRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_status_bar_component_request(&mut self) -> &mut StatusBarComponentRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::StatusBarComponentRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::StatusBarComponentRequest(StatusBarComponentRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::StatusBarComponentRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_status_bar_component_request(&mut self) -> StatusBarComponentRequest {
        if self.has_status_bar_component_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::StatusBarComponentRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            StatusBarComponentRequest::new()
        }
    }

    // optional .iterm2.SetBroadcastDomainsRequest set_broadcast_domains_request = 130;

    pub fn set_broadcast_domains_request(&self) -> &SetBroadcastDomainsRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SetBroadcastDomainsRequest(ref v)) => v,
            _ => <SetBroadcastDomainsRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_broadcast_domains_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_set_broadcast_domains_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SetBroadcastDomainsRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_broadcast_domains_request(&mut self, v: SetBroadcastDomainsRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SetBroadcastDomainsRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_broadcast_domains_request(&mut self) -> &mut SetBroadcastDomainsRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::SetBroadcastDomainsRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SetBroadcastDomainsRequest(SetBroadcastDomainsRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::SetBroadcastDomainsRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_broadcast_domains_request(&mut self) -> SetBroadcastDomainsRequest {
        if self.has_set_broadcast_domains_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::SetBroadcastDomainsRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            SetBroadcastDomainsRequest::new()
        }
    }

    // optional .iterm2.CloseRequest close_request = 131;

    pub fn close_request(&self) -> &CloseRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::CloseRequest(ref v)) => v,
            _ => <CloseRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_close_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_close_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::CloseRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_close_request(&mut self, v: CloseRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::CloseRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_close_request(&mut self) -> &mut CloseRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::CloseRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::CloseRequest(CloseRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::CloseRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_close_request(&mut self) -> CloseRequest {
        if self.has_close_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::CloseRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            CloseRequest::new()
        }
    }

    // optional .iterm2.InvokeFunctionRequest invoke_function_request = 132;

    pub fn invoke_function_request(&self) -> &InvokeFunctionRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::InvokeFunctionRequest(ref v)) => v,
            _ => <InvokeFunctionRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_invoke_function_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_invoke_function_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::InvokeFunctionRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_invoke_function_request(&mut self, v: InvokeFunctionRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::InvokeFunctionRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_invoke_function_request(&mut self) -> &mut InvokeFunctionRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::InvokeFunctionRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::InvokeFunctionRequest(InvokeFunctionRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::InvokeFunctionRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_invoke_function_request(&mut self) -> InvokeFunctionRequest {
        if self.has_invoke_function_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::InvokeFunctionRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            InvokeFunctionRequest::new()
        }
    }

    // optional .iterm2.ListPromptsRequest list_prompts_request = 133;

    pub fn list_prompts_request(&self) -> &ListPromptsRequest {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ListPromptsRequest(ref v)) => v,
            _ => <ListPromptsRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_list_prompts_request(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_list_prompts_request(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ListPromptsRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_prompts_request(&mut self, v: ListPromptsRequest) {
        self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ListPromptsRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_prompts_request(&mut self) -> &mut ListPromptsRequest {
        if let ::std::option::Option::Some(client_originated_message::Submessage::ListPromptsRequest(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ListPromptsRequest(ListPromptsRequest::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(client_originated_message::Submessage::ListPromptsRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_prompts_request(&mut self) -> ListPromptsRequest {
        if self.has_list_prompts_request() {
            match self.submessage.take() {
                ::std::option::Option::Some(client_originated_message::Submessage::ListPromptsRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            ListPromptsRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(35);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &ClientOriginatedMessage| { &m.id },
            |m: &mut ClientOriginatedMessage| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetBufferRequest>(
            "get_buffer_request",
            ClientOriginatedMessage::has_get_buffer_request,
            ClientOriginatedMessage::get_buffer_request,
            ClientOriginatedMessage::mut_get_buffer_request,
            ClientOriginatedMessage::set_get_buffer_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetPromptRequest>(
            "get_prompt_request",
            ClientOriginatedMessage::has_get_prompt_request,
            ClientOriginatedMessage::get_prompt_request,
            ClientOriginatedMessage::mut_get_prompt_request,
            ClientOriginatedMessage::set_get_prompt_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TransactionRequest>(
            "transaction_request",
            ClientOriginatedMessage::has_transaction_request,
            ClientOriginatedMessage::transaction_request,
            ClientOriginatedMessage::mut_transaction_request,
            ClientOriginatedMessage::set_transaction_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, NotificationRequest>(
            "notification_request",
            ClientOriginatedMessage::has_notification_request,
            ClientOriginatedMessage::notification_request,
            ClientOriginatedMessage::mut_notification_request,
            ClientOriginatedMessage::set_notification_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RegisterToolRequest>(
            "register_tool_request",
            ClientOriginatedMessage::has_register_tool_request,
            ClientOriginatedMessage::register_tool_request,
            ClientOriginatedMessage::mut_register_tool_request,
            ClientOriginatedMessage::set_register_tool_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SetProfilePropertyRequest>(
            "set_profile_property_request",
            ClientOriginatedMessage::has_set_profile_property_request,
            ClientOriginatedMessage::set_profile_property_request,
            ClientOriginatedMessage::mut_set_profile_property_request,
            ClientOriginatedMessage::set_set_profile_property_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ListSessionsRequest>(
            "list_sessions_request",
            ClientOriginatedMessage::has_list_sessions_request,
            ClientOriginatedMessage::list_sessions_request,
            ClientOriginatedMessage::mut_list_sessions_request,
            ClientOriginatedMessage::set_list_sessions_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SendTextRequest>(
            "send_text_request",
            ClientOriginatedMessage::has_send_text_request,
            ClientOriginatedMessage::send_text_request,
            ClientOriginatedMessage::mut_send_text_request,
            ClientOriginatedMessage::set_send_text_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CreateTabRequest>(
            "create_tab_request",
            ClientOriginatedMessage::has_create_tab_request,
            ClientOriginatedMessage::create_tab_request,
            ClientOriginatedMessage::mut_create_tab_request,
            ClientOriginatedMessage::set_create_tab_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SplitPaneRequest>(
            "split_pane_request",
            ClientOriginatedMessage::has_split_pane_request,
            ClientOriginatedMessage::split_pane_request,
            ClientOriginatedMessage::mut_split_pane_request,
            ClientOriginatedMessage::set_split_pane_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetProfilePropertyRequest>(
            "get_profile_property_request",
            ClientOriginatedMessage::has_get_profile_property_request,
            ClientOriginatedMessage::get_profile_property_request,
            ClientOriginatedMessage::mut_get_profile_property_request,
            ClientOriginatedMessage::set_get_profile_property_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SetPropertyRequest>(
            "set_property_request",
            ClientOriginatedMessage::has_set_property_request,
            ClientOriginatedMessage::set_property_request,
            ClientOriginatedMessage::mut_set_property_request,
            ClientOriginatedMessage::set_set_property_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetPropertyRequest>(
            "get_property_request",
            ClientOriginatedMessage::has_get_property_request,
            ClientOriginatedMessage::get_property_request,
            ClientOriginatedMessage::mut_get_property_request,
            ClientOriginatedMessage::set_get_property_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, InjectRequest>(
            "inject_request",
            ClientOriginatedMessage::has_inject_request,
            ClientOriginatedMessage::inject_request,
            ClientOriginatedMessage::mut_inject_request,
            ClientOriginatedMessage::set_inject_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActivateRequest>(
            "activate_request",
            ClientOriginatedMessage::has_activate_request,
            ClientOriginatedMessage::activate_request,
            ClientOriginatedMessage::mut_activate_request,
            ClientOriginatedMessage::set_activate_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VariableRequest>(
            "variable_request",
            ClientOriginatedMessage::has_variable_request,
            ClientOriginatedMessage::variable_request,
            ClientOriginatedMessage::mut_variable_request,
            ClientOriginatedMessage::set_variable_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SavedArrangementRequest>(
            "saved_arrangement_request",
            ClientOriginatedMessage::has_saved_arrangement_request,
            ClientOriginatedMessage::saved_arrangement_request,
            ClientOriginatedMessage::mut_saved_arrangement_request,
            ClientOriginatedMessage::set_saved_arrangement_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FocusRequest>(
            "focus_request",
            ClientOriginatedMessage::has_focus_request,
            ClientOriginatedMessage::focus_request,
            ClientOriginatedMessage::mut_focus_request,
            ClientOriginatedMessage::set_focus_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ListProfilesRequest>(
            "list_profiles_request",
            ClientOriginatedMessage::has_list_profiles_request,
            ClientOriginatedMessage::list_profiles_request,
            ClientOriginatedMessage::mut_list_profiles_request,
            ClientOriginatedMessage::set_list_profiles_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ServerOriginatedRPCResultRequest>(
            "server_originated_rpc_result_request",
            ClientOriginatedMessage::has_server_originated_rpc_result_request,
            ClientOriginatedMessage::server_originated_rpc_result_request,
            ClientOriginatedMessage::mut_server_originated_rpc_result_request,
            ClientOriginatedMessage::set_server_originated_rpc_result_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RestartSessionRequest>(
            "restart_session_request",
            ClientOriginatedMessage::has_restart_session_request,
            ClientOriginatedMessage::restart_session_request,
            ClientOriginatedMessage::mut_restart_session_request,
            ClientOriginatedMessage::set_restart_session_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MenuItemRequest>(
            "menu_item_request",
            ClientOriginatedMessage::has_menu_item_request,
            ClientOriginatedMessage::menu_item_request,
            ClientOriginatedMessage::mut_menu_item_request,
            ClientOriginatedMessage::set_menu_item_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SetTabLayoutRequest>(
            "set_tab_layout_request",
            ClientOriginatedMessage::has_set_tab_layout_request,
            ClientOriginatedMessage::set_tab_layout_request,
            ClientOriginatedMessage::mut_set_tab_layout_request,
            ClientOriginatedMessage::set_set_tab_layout_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetBroadcastDomainsRequest>(
            "get_broadcast_domains_request",
            ClientOriginatedMessage::has_get_broadcast_domains_request,
            ClientOriginatedMessage::get_broadcast_domains_request,
            ClientOriginatedMessage::mut_get_broadcast_domains_request,
            ClientOriginatedMessage::set_get_broadcast_domains_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TmuxRequest>(
            "tmux_request",
            ClientOriginatedMessage::has_tmux_request,
            ClientOriginatedMessage::tmux_request,
            ClientOriginatedMessage::mut_tmux_request,
            ClientOriginatedMessage::set_tmux_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ReorderTabsRequest>(
            "reorder_tabs_request",
            ClientOriginatedMessage::has_reorder_tabs_request,
            ClientOriginatedMessage::reorder_tabs_request,
            ClientOriginatedMessage::mut_reorder_tabs_request,
            ClientOriginatedMessage::set_reorder_tabs_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PreferencesRequest>(
            "preferences_request",
            ClientOriginatedMessage::has_preferences_request,
            ClientOriginatedMessage::preferences_request,
            ClientOriginatedMessage::mut_preferences_request,
            ClientOriginatedMessage::set_preferences_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ColorPresetRequest>(
            "color_preset_request",
            ClientOriginatedMessage::has_color_preset_request,
            ClientOriginatedMessage::color_preset_request,
            ClientOriginatedMessage::mut_color_preset_request,
            ClientOriginatedMessage::set_color_preset_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SelectionRequest>(
            "selection_request",
            ClientOriginatedMessage::has_selection_request,
            ClientOriginatedMessage::selection_request,
            ClientOriginatedMessage::mut_selection_request,
            ClientOriginatedMessage::set_selection_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StatusBarComponentRequest>(
            "status_bar_component_request",
            ClientOriginatedMessage::has_status_bar_component_request,
            ClientOriginatedMessage::status_bar_component_request,
            ClientOriginatedMessage::mut_status_bar_component_request,
            ClientOriginatedMessage::set_status_bar_component_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SetBroadcastDomainsRequest>(
            "set_broadcast_domains_request",
            ClientOriginatedMessage::has_set_broadcast_domains_request,
            ClientOriginatedMessage::set_broadcast_domains_request,
            ClientOriginatedMessage::mut_set_broadcast_domains_request,
            ClientOriginatedMessage::set_set_broadcast_domains_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CloseRequest>(
            "close_request",
            ClientOriginatedMessage::has_close_request,
            ClientOriginatedMessage::close_request,
            ClientOriginatedMessage::mut_close_request,
            ClientOriginatedMessage::set_close_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, InvokeFunctionRequest>(
            "invoke_function_request",
            ClientOriginatedMessage::has_invoke_function_request,
            ClientOriginatedMessage::invoke_function_request,
            ClientOriginatedMessage::mut_invoke_function_request,
            ClientOriginatedMessage::set_invoke_function_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ListPromptsRequest>(
            "list_prompts_request",
            ClientOriginatedMessage::has_list_prompts_request,
            ClientOriginatedMessage::list_prompts_request,
            ClientOriginatedMessage::mut_list_prompts_request,
            ClientOriginatedMessage::set_list_prompts_request,
        ));
        oneofs.push(client_originated_message::Submessage::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientOriginatedMessage>(
            "ClientOriginatedMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientOriginatedMessage {
    const NAME: &'static str = "ClientOriginatedMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int64()?);
                },
                802 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::GetBufferRequest(is.read_message()?));
                },
                810 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::GetPromptRequest(is.read_message()?));
                },
                818 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::TransactionRequest(is.read_message()?));
                },
                826 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::NotificationRequest(is.read_message()?));
                },
                834 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::RegisterToolRequest(is.read_message()?));
                },
                842 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SetProfilePropertyRequest(is.read_message()?));
                },
                850 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ListSessionsRequest(is.read_message()?));
                },
                858 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SendTextRequest(is.read_message()?));
                },
                866 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::CreateTabRequest(is.read_message()?));
                },
                874 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SplitPaneRequest(is.read_message()?));
                },
                882 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::GetProfilePropertyRequest(is.read_message()?));
                },
                890 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SetPropertyRequest(is.read_message()?));
                },
                898 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::GetPropertyRequest(is.read_message()?));
                },
                906 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::InjectRequest(is.read_message()?));
                },
                914 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ActivateRequest(is.read_message()?));
                },
                922 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::VariableRequest(is.read_message()?));
                },
                930 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SavedArrangementRequest(is.read_message()?));
                },
                938 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::FocusRequest(is.read_message()?));
                },
                946 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ListProfilesRequest(is.read_message()?));
                },
                954 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ServerOriginatedRpcResultRequest(is.read_message()?));
                },
                962 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::RestartSessionRequest(is.read_message()?));
                },
                970 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::MenuItemRequest(is.read_message()?));
                },
                978 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SetTabLayoutRequest(is.read_message()?));
                },
                986 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::GetBroadcastDomainsRequest(is.read_message()?));
                },
                994 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::TmuxRequest(is.read_message()?));
                },
                1002 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ReorderTabsRequest(is.read_message()?));
                },
                1010 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::PreferencesRequest(is.read_message()?));
                },
                1018 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ColorPresetRequest(is.read_message()?));
                },
                1026 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SelectionRequest(is.read_message()?));
                },
                1034 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::StatusBarComponentRequest(is.read_message()?));
                },
                1042 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::SetBroadcastDomainsRequest(is.read_message()?));
                },
                1050 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::CloseRequest(is.read_message()?));
                },
                1058 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::InvokeFunctionRequest(is.read_message()?));
                },
                1066 => {
                    self.submessage = ::std::option::Option::Some(client_originated_message::Submessage::ListPromptsRequest(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let ::std::option::Option::Some(ref v) = self.submessage {
            match v {
                &client_originated_message::Submessage::GetBufferRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::GetPromptRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::TransactionRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::NotificationRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::RegisterToolRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::SetProfilePropertyRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::ListSessionsRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::SendTextRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::CreateTabRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::SplitPaneRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::GetProfilePropertyRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::SetPropertyRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::GetPropertyRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::InjectRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::ActivateRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::VariableRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::SavedArrangementRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::FocusRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::ListProfilesRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::ServerOriginatedRpcResultRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::RestartSessionRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::MenuItemRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::SetTabLayoutRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::GetBroadcastDomainsRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::TmuxRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::ReorderTabsRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::PreferencesRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::ColorPresetRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::SelectionRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::StatusBarComponentRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::SetBroadcastDomainsRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::CloseRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::InvokeFunctionRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &client_originated_message::Submessage::ListPromptsRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.submessage {
            match v {
                &client_originated_message::Submessage::GetBufferRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(100, v, os)?;
                },
                &client_originated_message::Submessage::GetPromptRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(101, v, os)?;
                },
                &client_originated_message::Submessage::TransactionRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(102, v, os)?;
                },
                &client_originated_message::Submessage::NotificationRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(103, v, os)?;
                },
                &client_originated_message::Submessage::RegisterToolRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(104, v, os)?;
                },
                &client_originated_message::Submessage::SetProfilePropertyRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(105, v, os)?;
                },
                &client_originated_message::Submessage::ListSessionsRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(106, v, os)?;
                },
                &client_originated_message::Submessage::SendTextRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(107, v, os)?;
                },
                &client_originated_message::Submessage::CreateTabRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(108, v, os)?;
                },
                &client_originated_message::Submessage::SplitPaneRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(109, v, os)?;
                },
                &client_originated_message::Submessage::GetProfilePropertyRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(110, v, os)?;
                },
                &client_originated_message::Submessage::SetPropertyRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(111, v, os)?;
                },
                &client_originated_message::Submessage::GetPropertyRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(112, v, os)?;
                },
                &client_originated_message::Submessage::InjectRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(113, v, os)?;
                },
                &client_originated_message::Submessage::ActivateRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(114, v, os)?;
                },
                &client_originated_message::Submessage::VariableRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(115, v, os)?;
                },
                &client_originated_message::Submessage::SavedArrangementRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(116, v, os)?;
                },
                &client_originated_message::Submessage::FocusRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(117, v, os)?;
                },
                &client_originated_message::Submessage::ListProfilesRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(118, v, os)?;
                },
                &client_originated_message::Submessage::ServerOriginatedRpcResultRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(119, v, os)?;
                },
                &client_originated_message::Submessage::RestartSessionRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(120, v, os)?;
                },
                &client_originated_message::Submessage::MenuItemRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(121, v, os)?;
                },
                &client_originated_message::Submessage::SetTabLayoutRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(122, v, os)?;
                },
                &client_originated_message::Submessage::GetBroadcastDomainsRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(123, v, os)?;
                },
                &client_originated_message::Submessage::TmuxRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(124, v, os)?;
                },
                &client_originated_message::Submessage::ReorderTabsRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(125, v, os)?;
                },
                &client_originated_message::Submessage::PreferencesRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(126, v, os)?;
                },
                &client_originated_message::Submessage::ColorPresetRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(127, v, os)?;
                },
                &client_originated_message::Submessage::SelectionRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(128, v, os)?;
                },
                &client_originated_message::Submessage::StatusBarComponentRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(129, v, os)?;
                },
                &client_originated_message::Submessage::SetBroadcastDomainsRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(130, v, os)?;
                },
                &client_originated_message::Submessage::CloseRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(131, v, os)?;
                },
                &client_originated_message::Submessage::InvokeFunctionRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(132, v, os)?;
                },
                &client_originated_message::Submessage::ListPromptsRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(133, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientOriginatedMessage {
        ClientOriginatedMessage::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientOriginatedMessage {
        static instance: ClientOriginatedMessage = ClientOriginatedMessage {
            id: ::std::option::Option::None,
            submessage: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientOriginatedMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientOriginatedMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientOriginatedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientOriginatedMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ClientOriginatedMessage`
pub mod client_originated_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.ClientOriginatedMessage.submessage)
    pub enum Submessage {
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.get_buffer_request)
        GetBufferRequest(super::GetBufferRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.get_prompt_request)
        GetPromptRequest(super::GetPromptRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.transaction_request)
        TransactionRequest(super::TransactionRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.notification_request)
        NotificationRequest(super::NotificationRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.register_tool_request)
        RegisterToolRequest(super::RegisterToolRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.set_profile_property_request)
        SetProfilePropertyRequest(super::SetProfilePropertyRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.list_sessions_request)
        ListSessionsRequest(super::ListSessionsRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.send_text_request)
        SendTextRequest(super::SendTextRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.create_tab_request)
        CreateTabRequest(super::CreateTabRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.split_pane_request)
        SplitPaneRequest(super::SplitPaneRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.get_profile_property_request)
        GetProfilePropertyRequest(super::GetProfilePropertyRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.set_property_request)
        SetPropertyRequest(super::SetPropertyRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.get_property_request)
        GetPropertyRequest(super::GetPropertyRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.inject_request)
        InjectRequest(super::InjectRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.activate_request)
        ActivateRequest(super::ActivateRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.variable_request)
        VariableRequest(super::VariableRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.saved_arrangement_request)
        SavedArrangementRequest(super::SavedArrangementRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.focus_request)
        FocusRequest(super::FocusRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.list_profiles_request)
        ListProfilesRequest(super::ListProfilesRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.server_originated_rpc_result_request)
        ServerOriginatedRpcResultRequest(super::ServerOriginatedRPCResultRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.restart_session_request)
        RestartSessionRequest(super::RestartSessionRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.menu_item_request)
        MenuItemRequest(super::MenuItemRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.set_tab_layout_request)
        SetTabLayoutRequest(super::SetTabLayoutRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.get_broadcast_domains_request)
        GetBroadcastDomainsRequest(super::GetBroadcastDomainsRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.tmux_request)
        TmuxRequest(super::TmuxRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.reorder_tabs_request)
        ReorderTabsRequest(super::ReorderTabsRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.preferences_request)
        PreferencesRequest(super::PreferencesRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.color_preset_request)
        ColorPresetRequest(super::ColorPresetRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.selection_request)
        SelectionRequest(super::SelectionRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.status_bar_component_request)
        StatusBarComponentRequest(super::StatusBarComponentRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.set_broadcast_domains_request)
        SetBroadcastDomainsRequest(super::SetBroadcastDomainsRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.close_request)
        CloseRequest(super::CloseRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.invoke_function_request)
        InvokeFunctionRequest(super::InvokeFunctionRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.ClientOriginatedMessage.list_prompts_request)
        ListPromptsRequest(super::ListPromptsRequest),
    }

    impl ::protobuf::Oneof for Submessage {
    }

    impl ::protobuf::OneofFull for Submessage {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ClientOriginatedMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("submessage").unwrap()).clone()
        }
    }

    impl Submessage {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Submessage>("submessage")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.ServerOriginatedMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerOriginatedMessage {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ServerOriginatedMessage.id)
    pub id: ::std::option::Option<i64>,
    // message oneof groups
    pub submessage: ::std::option::Option<server_originated_message::Submessage>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ServerOriginatedMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerOriginatedMessage {
    fn default() -> &'a ServerOriginatedMessage {
        <ServerOriginatedMessage as ::protobuf::Message>::default_instance()
    }
}

impl ServerOriginatedMessage {
    pub fn new() -> ServerOriginatedMessage {
        ::std::default::Default::default()
    }

    // optional int64 id = 1;

    pub fn id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string error = 2;

    pub fn error(&self) -> &str {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::Error(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::Error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::Error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(server_originated_message::Submessage::Error(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::Error(::std::string::String::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::Error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        if self.has_error() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::Error(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional .iterm2.GetBufferResponse get_buffer_response = 100;

    pub fn get_buffer_response(&self) -> &GetBufferResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::GetBufferResponse(ref v)) => v,
            _ => <GetBufferResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_buffer_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_get_buffer_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::GetBufferResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_buffer_response(&mut self, v: GetBufferResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::GetBufferResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_buffer_response(&mut self) -> &mut GetBufferResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::GetBufferResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::GetBufferResponse(GetBufferResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::GetBufferResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_buffer_response(&mut self) -> GetBufferResponse {
        if self.has_get_buffer_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::GetBufferResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            GetBufferResponse::new()
        }
    }

    // optional .iterm2.GetPromptResponse get_prompt_response = 101;

    pub fn get_prompt_response(&self) -> &GetPromptResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::GetPromptResponse(ref v)) => v,
            _ => <GetPromptResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_prompt_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_get_prompt_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::GetPromptResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_prompt_response(&mut self, v: GetPromptResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::GetPromptResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_prompt_response(&mut self) -> &mut GetPromptResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::GetPromptResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::GetPromptResponse(GetPromptResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::GetPromptResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_prompt_response(&mut self) -> GetPromptResponse {
        if self.has_get_prompt_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::GetPromptResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            GetPromptResponse::new()
        }
    }

    // optional .iterm2.TransactionResponse transaction_response = 102;

    pub fn transaction_response(&self) -> &TransactionResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::TransactionResponse(ref v)) => v,
            _ => <TransactionResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_transaction_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_transaction_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::TransactionResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transaction_response(&mut self, v: TransactionResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::TransactionResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transaction_response(&mut self) -> &mut TransactionResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::TransactionResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::TransactionResponse(TransactionResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::TransactionResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transaction_response(&mut self) -> TransactionResponse {
        if self.has_transaction_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::TransactionResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionResponse::new()
        }
    }

    // optional .iterm2.NotificationResponse notification_response = 103;

    pub fn notification_response(&self) -> &NotificationResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::NotificationResponse(ref v)) => v,
            _ => <NotificationResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_notification_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_notification_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::NotificationResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_notification_response(&mut self, v: NotificationResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::NotificationResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_notification_response(&mut self) -> &mut NotificationResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::NotificationResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::NotificationResponse(NotificationResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::NotificationResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_notification_response(&mut self) -> NotificationResponse {
        if self.has_notification_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::NotificationResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            NotificationResponse::new()
        }
    }

    // optional .iterm2.RegisterToolResponse register_tool_response = 104;

    pub fn register_tool_response(&self) -> &RegisterToolResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::RegisterToolResponse(ref v)) => v,
            _ => <RegisterToolResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_register_tool_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_register_tool_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::RegisterToolResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_register_tool_response(&mut self, v: RegisterToolResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::RegisterToolResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_register_tool_response(&mut self) -> &mut RegisterToolResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::RegisterToolResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::RegisterToolResponse(RegisterToolResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::RegisterToolResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_register_tool_response(&mut self) -> RegisterToolResponse {
        if self.has_register_tool_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::RegisterToolResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            RegisterToolResponse::new()
        }
    }

    // optional .iterm2.SetProfilePropertyResponse set_profile_property_response = 105;

    pub fn set_profile_property_response(&self) -> &SetProfilePropertyResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SetProfilePropertyResponse(ref v)) => v,
            _ => <SetProfilePropertyResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_profile_property_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_set_profile_property_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SetProfilePropertyResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_profile_property_response(&mut self, v: SetProfilePropertyResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SetProfilePropertyResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_profile_property_response(&mut self) -> &mut SetProfilePropertyResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::SetProfilePropertyResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SetProfilePropertyResponse(SetProfilePropertyResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SetProfilePropertyResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_profile_property_response(&mut self) -> SetProfilePropertyResponse {
        if self.has_set_profile_property_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::SetProfilePropertyResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            SetProfilePropertyResponse::new()
        }
    }

    // optional .iterm2.ListSessionsResponse list_sessions_response = 106;

    pub fn list_sessions_response(&self) -> &ListSessionsResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ListSessionsResponse(ref v)) => v,
            _ => <ListSessionsResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_list_sessions_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_list_sessions_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ListSessionsResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_sessions_response(&mut self, v: ListSessionsResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ListSessionsResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_sessions_response(&mut self) -> &mut ListSessionsResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::ListSessionsResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ListSessionsResponse(ListSessionsResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ListSessionsResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_sessions_response(&mut self) -> ListSessionsResponse {
        if self.has_list_sessions_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::ListSessionsResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            ListSessionsResponse::new()
        }
    }

    // optional .iterm2.SendTextResponse send_text_response = 107;

    pub fn send_text_response(&self) -> &SendTextResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SendTextResponse(ref v)) => v,
            _ => <SendTextResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_send_text_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_send_text_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SendTextResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_send_text_response(&mut self, v: SendTextResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SendTextResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_send_text_response(&mut self) -> &mut SendTextResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::SendTextResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SendTextResponse(SendTextResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SendTextResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_send_text_response(&mut self) -> SendTextResponse {
        if self.has_send_text_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::SendTextResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            SendTextResponse::new()
        }
    }

    // optional .iterm2.CreateTabResponse create_tab_response = 108;

    pub fn create_tab_response(&self) -> &CreateTabResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::CreateTabResponse(ref v)) => v,
            _ => <CreateTabResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_create_tab_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_create_tab_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::CreateTabResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_tab_response(&mut self, v: CreateTabResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::CreateTabResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_tab_response(&mut self) -> &mut CreateTabResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::CreateTabResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::CreateTabResponse(CreateTabResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::CreateTabResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_tab_response(&mut self) -> CreateTabResponse {
        if self.has_create_tab_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::CreateTabResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            CreateTabResponse::new()
        }
    }

    // optional .iterm2.SplitPaneResponse split_pane_response = 109;

    pub fn split_pane_response(&self) -> &SplitPaneResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SplitPaneResponse(ref v)) => v,
            _ => <SplitPaneResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_split_pane_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_split_pane_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SplitPaneResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_split_pane_response(&mut self, v: SplitPaneResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SplitPaneResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_split_pane_response(&mut self) -> &mut SplitPaneResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::SplitPaneResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SplitPaneResponse(SplitPaneResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SplitPaneResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_split_pane_response(&mut self) -> SplitPaneResponse {
        if self.has_split_pane_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::SplitPaneResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            SplitPaneResponse::new()
        }
    }

    // optional .iterm2.GetProfilePropertyResponse get_profile_property_response = 110;

    pub fn get_profile_property_response(&self) -> &GetProfilePropertyResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::GetProfilePropertyResponse(ref v)) => v,
            _ => <GetProfilePropertyResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_profile_property_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_get_profile_property_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::GetProfilePropertyResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_profile_property_response(&mut self, v: GetProfilePropertyResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::GetProfilePropertyResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_profile_property_response(&mut self) -> &mut GetProfilePropertyResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::GetProfilePropertyResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::GetProfilePropertyResponse(GetProfilePropertyResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::GetProfilePropertyResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_profile_property_response(&mut self) -> GetProfilePropertyResponse {
        if self.has_get_profile_property_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::GetProfilePropertyResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            GetProfilePropertyResponse::new()
        }
    }

    // optional .iterm2.SetPropertyResponse set_property_response = 111;

    pub fn set_property_response(&self) -> &SetPropertyResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SetPropertyResponse(ref v)) => v,
            _ => <SetPropertyResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_property_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_set_property_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SetPropertyResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_property_response(&mut self, v: SetPropertyResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SetPropertyResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_property_response(&mut self) -> &mut SetPropertyResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::SetPropertyResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SetPropertyResponse(SetPropertyResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SetPropertyResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_property_response(&mut self) -> SetPropertyResponse {
        if self.has_set_property_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::SetPropertyResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            SetPropertyResponse::new()
        }
    }

    // optional .iterm2.GetPropertyResponse get_property_response = 112;

    pub fn get_property_response(&self) -> &GetPropertyResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::GetPropertyResponse(ref v)) => v,
            _ => <GetPropertyResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_property_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_get_property_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::GetPropertyResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_property_response(&mut self, v: GetPropertyResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::GetPropertyResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_property_response(&mut self) -> &mut GetPropertyResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::GetPropertyResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::GetPropertyResponse(GetPropertyResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::GetPropertyResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_property_response(&mut self) -> GetPropertyResponse {
        if self.has_get_property_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::GetPropertyResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            GetPropertyResponse::new()
        }
    }

    // optional .iterm2.InjectResponse inject_response = 113;

    pub fn inject_response(&self) -> &InjectResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::InjectResponse(ref v)) => v,
            _ => <InjectResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_inject_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_inject_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::InjectResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_inject_response(&mut self, v: InjectResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::InjectResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_inject_response(&mut self) -> &mut InjectResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::InjectResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::InjectResponse(InjectResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::InjectResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_inject_response(&mut self) -> InjectResponse {
        if self.has_inject_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::InjectResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            InjectResponse::new()
        }
    }

    // optional .iterm2.ActivateResponse activate_response = 114;

    pub fn activate_response(&self) -> &ActivateResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ActivateResponse(ref v)) => v,
            _ => <ActivateResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_activate_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_activate_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ActivateResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_activate_response(&mut self, v: ActivateResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ActivateResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_activate_response(&mut self) -> &mut ActivateResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::ActivateResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ActivateResponse(ActivateResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ActivateResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_activate_response(&mut self) -> ActivateResponse {
        if self.has_activate_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::ActivateResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            ActivateResponse::new()
        }
    }

    // optional .iterm2.VariableResponse variable_response = 115;

    pub fn variable_response(&self) -> &VariableResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::VariableResponse(ref v)) => v,
            _ => <VariableResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_variable_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_variable_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::VariableResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_variable_response(&mut self, v: VariableResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::VariableResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_variable_response(&mut self) -> &mut VariableResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::VariableResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::VariableResponse(VariableResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::VariableResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_variable_response(&mut self) -> VariableResponse {
        if self.has_variable_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::VariableResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            VariableResponse::new()
        }
    }

    // optional .iterm2.SavedArrangementResponse saved_arrangement_response = 116;

    pub fn saved_arrangement_response(&self) -> &SavedArrangementResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SavedArrangementResponse(ref v)) => v,
            _ => <SavedArrangementResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_saved_arrangement_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_saved_arrangement_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SavedArrangementResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_saved_arrangement_response(&mut self, v: SavedArrangementResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SavedArrangementResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_saved_arrangement_response(&mut self) -> &mut SavedArrangementResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::SavedArrangementResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SavedArrangementResponse(SavedArrangementResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SavedArrangementResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_saved_arrangement_response(&mut self) -> SavedArrangementResponse {
        if self.has_saved_arrangement_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::SavedArrangementResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedArrangementResponse::new()
        }
    }

    // optional .iterm2.FocusResponse focus_response = 117;

    pub fn focus_response(&self) -> &FocusResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::FocusResponse(ref v)) => v,
            _ => <FocusResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_focus_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_focus_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::FocusResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_focus_response(&mut self, v: FocusResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::FocusResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_focus_response(&mut self) -> &mut FocusResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::FocusResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::FocusResponse(FocusResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::FocusResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_focus_response(&mut self) -> FocusResponse {
        if self.has_focus_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::FocusResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            FocusResponse::new()
        }
    }

    // optional .iterm2.ListProfilesResponse list_profiles_response = 118;

    pub fn list_profiles_response(&self) -> &ListProfilesResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ListProfilesResponse(ref v)) => v,
            _ => <ListProfilesResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_list_profiles_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_list_profiles_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ListProfilesResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_profiles_response(&mut self, v: ListProfilesResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ListProfilesResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_profiles_response(&mut self) -> &mut ListProfilesResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::ListProfilesResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ListProfilesResponse(ListProfilesResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ListProfilesResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_profiles_response(&mut self) -> ListProfilesResponse {
        if self.has_list_profiles_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::ListProfilesResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            ListProfilesResponse::new()
        }
    }

    // optional .iterm2.ServerOriginatedRPCResultResponse server_originated_rpc_result_response = 119;

    pub fn server_originated_rpc_result_response(&self) -> &ServerOriginatedRPCResultResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ServerOriginatedRpcResultResponse(ref v)) => v,
            _ => <ServerOriginatedRPCResultResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_server_originated_rpc_result_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_server_originated_rpc_result_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ServerOriginatedRpcResultResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_server_originated_rpc_result_response(&mut self, v: ServerOriginatedRPCResultResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ServerOriginatedRpcResultResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_server_originated_rpc_result_response(&mut self) -> &mut ServerOriginatedRPCResultResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::ServerOriginatedRpcResultResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ServerOriginatedRpcResultResponse(ServerOriginatedRPCResultResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ServerOriginatedRpcResultResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_server_originated_rpc_result_response(&mut self) -> ServerOriginatedRPCResultResponse {
        if self.has_server_originated_rpc_result_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::ServerOriginatedRpcResultResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            ServerOriginatedRPCResultResponse::new()
        }
    }

    // optional .iterm2.RestartSessionResponse restart_session_response = 120;

    pub fn restart_session_response(&self) -> &RestartSessionResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::RestartSessionResponse(ref v)) => v,
            _ => <RestartSessionResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_restart_session_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_restart_session_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::RestartSessionResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_restart_session_response(&mut self, v: RestartSessionResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::RestartSessionResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_restart_session_response(&mut self) -> &mut RestartSessionResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::RestartSessionResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::RestartSessionResponse(RestartSessionResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::RestartSessionResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_restart_session_response(&mut self) -> RestartSessionResponse {
        if self.has_restart_session_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::RestartSessionResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            RestartSessionResponse::new()
        }
    }

    // optional .iterm2.MenuItemResponse menu_item_response = 121;

    pub fn menu_item_response(&self) -> &MenuItemResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::MenuItemResponse(ref v)) => v,
            _ => <MenuItemResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_menu_item_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_menu_item_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::MenuItemResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_menu_item_response(&mut self, v: MenuItemResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::MenuItemResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_menu_item_response(&mut self) -> &mut MenuItemResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::MenuItemResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::MenuItemResponse(MenuItemResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::MenuItemResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_menu_item_response(&mut self) -> MenuItemResponse {
        if self.has_menu_item_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::MenuItemResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            MenuItemResponse::new()
        }
    }

    // optional .iterm2.SetTabLayoutResponse set_tab_layout_response = 122;

    pub fn set_tab_layout_response(&self) -> &SetTabLayoutResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SetTabLayoutResponse(ref v)) => v,
            _ => <SetTabLayoutResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_tab_layout_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_set_tab_layout_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SetTabLayoutResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_tab_layout_response(&mut self, v: SetTabLayoutResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SetTabLayoutResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_tab_layout_response(&mut self) -> &mut SetTabLayoutResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::SetTabLayoutResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SetTabLayoutResponse(SetTabLayoutResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SetTabLayoutResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_tab_layout_response(&mut self) -> SetTabLayoutResponse {
        if self.has_set_tab_layout_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::SetTabLayoutResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            SetTabLayoutResponse::new()
        }
    }

    // optional .iterm2.GetBroadcastDomainsResponse get_broadcast_domains_response = 123;

    pub fn get_broadcast_domains_response(&self) -> &GetBroadcastDomainsResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::GetBroadcastDomainsResponse(ref v)) => v,
            _ => <GetBroadcastDomainsResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_broadcast_domains_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_get_broadcast_domains_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::GetBroadcastDomainsResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_broadcast_domains_response(&mut self, v: GetBroadcastDomainsResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::GetBroadcastDomainsResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_broadcast_domains_response(&mut self) -> &mut GetBroadcastDomainsResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::GetBroadcastDomainsResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::GetBroadcastDomainsResponse(GetBroadcastDomainsResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::GetBroadcastDomainsResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_broadcast_domains_response(&mut self) -> GetBroadcastDomainsResponse {
        if self.has_get_broadcast_domains_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::GetBroadcastDomainsResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            GetBroadcastDomainsResponse::new()
        }
    }

    // optional .iterm2.TmuxResponse tmux_response = 124;

    pub fn tmux_response(&self) -> &TmuxResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::TmuxResponse(ref v)) => v,
            _ => <TmuxResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_tmux_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_tmux_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::TmuxResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tmux_response(&mut self, v: TmuxResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::TmuxResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tmux_response(&mut self) -> &mut TmuxResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::TmuxResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::TmuxResponse(TmuxResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::TmuxResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tmux_response(&mut self) -> TmuxResponse {
        if self.has_tmux_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::TmuxResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            TmuxResponse::new()
        }
    }

    // optional .iterm2.ReorderTabsResponse reorder_tabs_response = 125;

    pub fn reorder_tabs_response(&self) -> &ReorderTabsResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ReorderTabsResponse(ref v)) => v,
            _ => <ReorderTabsResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_reorder_tabs_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_reorder_tabs_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ReorderTabsResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reorder_tabs_response(&mut self, v: ReorderTabsResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ReorderTabsResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reorder_tabs_response(&mut self) -> &mut ReorderTabsResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::ReorderTabsResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ReorderTabsResponse(ReorderTabsResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ReorderTabsResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reorder_tabs_response(&mut self) -> ReorderTabsResponse {
        if self.has_reorder_tabs_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::ReorderTabsResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            ReorderTabsResponse::new()
        }
    }

    // optional .iterm2.PreferencesResponse preferences_response = 126;

    pub fn preferences_response(&self) -> &PreferencesResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::PreferencesResponse(ref v)) => v,
            _ => <PreferencesResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_preferences_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_preferences_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::PreferencesResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_preferences_response(&mut self, v: PreferencesResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::PreferencesResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_preferences_response(&mut self) -> &mut PreferencesResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::PreferencesResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::PreferencesResponse(PreferencesResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::PreferencesResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_preferences_response(&mut self) -> PreferencesResponse {
        if self.has_preferences_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::PreferencesResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            PreferencesResponse::new()
        }
    }

    // optional .iterm2.ColorPresetResponse color_preset_response = 127;

    pub fn color_preset_response(&self) -> &ColorPresetResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ColorPresetResponse(ref v)) => v,
            _ => <ColorPresetResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_color_preset_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_color_preset_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ColorPresetResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_color_preset_response(&mut self, v: ColorPresetResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ColorPresetResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_color_preset_response(&mut self) -> &mut ColorPresetResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::ColorPresetResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ColorPresetResponse(ColorPresetResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ColorPresetResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_color_preset_response(&mut self) -> ColorPresetResponse {
        if self.has_color_preset_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::ColorPresetResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            ColorPresetResponse::new()
        }
    }

    // optional .iterm2.SelectionResponse selection_response = 128;

    pub fn selection_response(&self) -> &SelectionResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SelectionResponse(ref v)) => v,
            _ => <SelectionResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_selection_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_selection_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SelectionResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_selection_response(&mut self, v: SelectionResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SelectionResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_selection_response(&mut self) -> &mut SelectionResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::SelectionResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SelectionResponse(SelectionResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SelectionResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_selection_response(&mut self) -> SelectionResponse {
        if self.has_selection_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::SelectionResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            SelectionResponse::new()
        }
    }

    // optional .iterm2.StatusBarComponentResponse status_bar_component_response = 129;

    pub fn status_bar_component_response(&self) -> &StatusBarComponentResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::StatusBarComponentResponse(ref v)) => v,
            _ => <StatusBarComponentResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_status_bar_component_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_status_bar_component_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::StatusBarComponentResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_status_bar_component_response(&mut self, v: StatusBarComponentResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::StatusBarComponentResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_status_bar_component_response(&mut self) -> &mut StatusBarComponentResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::StatusBarComponentResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::StatusBarComponentResponse(StatusBarComponentResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::StatusBarComponentResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_status_bar_component_response(&mut self) -> StatusBarComponentResponse {
        if self.has_status_bar_component_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::StatusBarComponentResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            StatusBarComponentResponse::new()
        }
    }

    // optional .iterm2.SetBroadcastDomainsResponse set_broadcast_domains_response = 130;

    pub fn set_broadcast_domains_response(&self) -> &SetBroadcastDomainsResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SetBroadcastDomainsResponse(ref v)) => v,
            _ => <SetBroadcastDomainsResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_broadcast_domains_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_set_broadcast_domains_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SetBroadcastDomainsResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_broadcast_domains_response(&mut self, v: SetBroadcastDomainsResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SetBroadcastDomainsResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_broadcast_domains_response(&mut self) -> &mut SetBroadcastDomainsResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::SetBroadcastDomainsResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SetBroadcastDomainsResponse(SetBroadcastDomainsResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::SetBroadcastDomainsResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_broadcast_domains_response(&mut self) -> SetBroadcastDomainsResponse {
        if self.has_set_broadcast_domains_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::SetBroadcastDomainsResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            SetBroadcastDomainsResponse::new()
        }
    }

    // optional .iterm2.CloseResponse close_response = 131;

    pub fn close_response(&self) -> &CloseResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::CloseResponse(ref v)) => v,
            _ => <CloseResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_close_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_close_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::CloseResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_close_response(&mut self, v: CloseResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::CloseResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_close_response(&mut self) -> &mut CloseResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::CloseResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::CloseResponse(CloseResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::CloseResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_close_response(&mut self) -> CloseResponse {
        if self.has_close_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::CloseResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            CloseResponse::new()
        }
    }

    // optional .iterm2.InvokeFunctionResponse invoke_function_response = 132;

    pub fn invoke_function_response(&self) -> &InvokeFunctionResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::InvokeFunctionResponse(ref v)) => v,
            _ => <InvokeFunctionResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_invoke_function_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_invoke_function_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::InvokeFunctionResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_invoke_function_response(&mut self, v: InvokeFunctionResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::InvokeFunctionResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_invoke_function_response(&mut self) -> &mut InvokeFunctionResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::InvokeFunctionResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::InvokeFunctionResponse(InvokeFunctionResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::InvokeFunctionResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_invoke_function_response(&mut self) -> InvokeFunctionResponse {
        if self.has_invoke_function_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::InvokeFunctionResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            InvokeFunctionResponse::new()
        }
    }

    // optional .iterm2.ListPromptsResponse list_prompts_response = 133;

    pub fn list_prompts_response(&self) -> &ListPromptsResponse {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ListPromptsResponse(ref v)) => v,
            _ => <ListPromptsResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_list_prompts_response(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_list_prompts_response(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ListPromptsResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_prompts_response(&mut self, v: ListPromptsResponse) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ListPromptsResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_prompts_response(&mut self) -> &mut ListPromptsResponse {
        if let ::std::option::Option::Some(server_originated_message::Submessage::ListPromptsResponse(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ListPromptsResponse(ListPromptsResponse::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::ListPromptsResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_prompts_response(&mut self) -> ListPromptsResponse {
        if self.has_list_prompts_response() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::ListPromptsResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            ListPromptsResponse::new()
        }
    }

    // optional .iterm2.Notification notification = 1000;

    pub fn notification(&self) -> &Notification {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::Notification(ref v)) => v,
            _ => <Notification as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_notification(&mut self) {
        self.submessage = ::std::option::Option::None;
    }

    pub fn has_notification(&self) -> bool {
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::Notification(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_notification(&mut self, v: Notification) {
        self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::Notification(v))
    }

    // Mutable pointer to the field.
    pub fn mut_notification(&mut self) -> &mut Notification {
        if let ::std::option::Option::Some(server_originated_message::Submessage::Notification(_)) = self.submessage {
        } else {
            self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::Notification(Notification::new()));
        }
        match self.submessage {
            ::std::option::Option::Some(server_originated_message::Submessage::Notification(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_notification(&mut self) -> Notification {
        if self.has_notification() {
            match self.submessage.take() {
                ::std::option::Option::Some(server_originated_message::Submessage::Notification(v)) => v,
                _ => panic!(),
            }
        } else {
            Notification::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(37);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &ServerOriginatedMessage| { &m.id },
            |m: &mut ServerOriginatedMessage| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "error",
            ServerOriginatedMessage::has_error,
            ServerOriginatedMessage::error,
            ServerOriginatedMessage::set_error,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetBufferResponse>(
            "get_buffer_response",
            ServerOriginatedMessage::has_get_buffer_response,
            ServerOriginatedMessage::get_buffer_response,
            ServerOriginatedMessage::mut_get_buffer_response,
            ServerOriginatedMessage::set_get_buffer_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetPromptResponse>(
            "get_prompt_response",
            ServerOriginatedMessage::has_get_prompt_response,
            ServerOriginatedMessage::get_prompt_response,
            ServerOriginatedMessage::mut_get_prompt_response,
            ServerOriginatedMessage::set_get_prompt_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TransactionResponse>(
            "transaction_response",
            ServerOriginatedMessage::has_transaction_response,
            ServerOriginatedMessage::transaction_response,
            ServerOriginatedMessage::mut_transaction_response,
            ServerOriginatedMessage::set_transaction_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, NotificationResponse>(
            "notification_response",
            ServerOriginatedMessage::has_notification_response,
            ServerOriginatedMessage::notification_response,
            ServerOriginatedMessage::mut_notification_response,
            ServerOriginatedMessage::set_notification_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RegisterToolResponse>(
            "register_tool_response",
            ServerOriginatedMessage::has_register_tool_response,
            ServerOriginatedMessage::register_tool_response,
            ServerOriginatedMessage::mut_register_tool_response,
            ServerOriginatedMessage::set_register_tool_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SetProfilePropertyResponse>(
            "set_profile_property_response",
            ServerOriginatedMessage::has_set_profile_property_response,
            ServerOriginatedMessage::set_profile_property_response,
            ServerOriginatedMessage::mut_set_profile_property_response,
            ServerOriginatedMessage::set_set_profile_property_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ListSessionsResponse>(
            "list_sessions_response",
            ServerOriginatedMessage::has_list_sessions_response,
            ServerOriginatedMessage::list_sessions_response,
            ServerOriginatedMessage::mut_list_sessions_response,
            ServerOriginatedMessage::set_list_sessions_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SendTextResponse>(
            "send_text_response",
            ServerOriginatedMessage::has_send_text_response,
            ServerOriginatedMessage::send_text_response,
            ServerOriginatedMessage::mut_send_text_response,
            ServerOriginatedMessage::set_send_text_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CreateTabResponse>(
            "create_tab_response",
            ServerOriginatedMessage::has_create_tab_response,
            ServerOriginatedMessage::create_tab_response,
            ServerOriginatedMessage::mut_create_tab_response,
            ServerOriginatedMessage::set_create_tab_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SplitPaneResponse>(
            "split_pane_response",
            ServerOriginatedMessage::has_split_pane_response,
            ServerOriginatedMessage::split_pane_response,
            ServerOriginatedMessage::mut_split_pane_response,
            ServerOriginatedMessage::set_split_pane_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetProfilePropertyResponse>(
            "get_profile_property_response",
            ServerOriginatedMessage::has_get_profile_property_response,
            ServerOriginatedMessage::get_profile_property_response,
            ServerOriginatedMessage::mut_get_profile_property_response,
            ServerOriginatedMessage::set_get_profile_property_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SetPropertyResponse>(
            "set_property_response",
            ServerOriginatedMessage::has_set_property_response,
            ServerOriginatedMessage::set_property_response,
            ServerOriginatedMessage::mut_set_property_response,
            ServerOriginatedMessage::set_set_property_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetPropertyResponse>(
            "get_property_response",
            ServerOriginatedMessage::has_get_property_response,
            ServerOriginatedMessage::get_property_response,
            ServerOriginatedMessage::mut_get_property_response,
            ServerOriginatedMessage::set_get_property_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, InjectResponse>(
            "inject_response",
            ServerOriginatedMessage::has_inject_response,
            ServerOriginatedMessage::inject_response,
            ServerOriginatedMessage::mut_inject_response,
            ServerOriginatedMessage::set_inject_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActivateResponse>(
            "activate_response",
            ServerOriginatedMessage::has_activate_response,
            ServerOriginatedMessage::activate_response,
            ServerOriginatedMessage::mut_activate_response,
            ServerOriginatedMessage::set_activate_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VariableResponse>(
            "variable_response",
            ServerOriginatedMessage::has_variable_response,
            ServerOriginatedMessage::variable_response,
            ServerOriginatedMessage::mut_variable_response,
            ServerOriginatedMessage::set_variable_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SavedArrangementResponse>(
            "saved_arrangement_response",
            ServerOriginatedMessage::has_saved_arrangement_response,
            ServerOriginatedMessage::saved_arrangement_response,
            ServerOriginatedMessage::mut_saved_arrangement_response,
            ServerOriginatedMessage::set_saved_arrangement_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FocusResponse>(
            "focus_response",
            ServerOriginatedMessage::has_focus_response,
            ServerOriginatedMessage::focus_response,
            ServerOriginatedMessage::mut_focus_response,
            ServerOriginatedMessage::set_focus_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ListProfilesResponse>(
            "list_profiles_response",
            ServerOriginatedMessage::has_list_profiles_response,
            ServerOriginatedMessage::list_profiles_response,
            ServerOriginatedMessage::mut_list_profiles_response,
            ServerOriginatedMessage::set_list_profiles_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ServerOriginatedRPCResultResponse>(
            "server_originated_rpc_result_response",
            ServerOriginatedMessage::has_server_originated_rpc_result_response,
            ServerOriginatedMessage::server_originated_rpc_result_response,
            ServerOriginatedMessage::mut_server_originated_rpc_result_response,
            ServerOriginatedMessage::set_server_originated_rpc_result_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RestartSessionResponse>(
            "restart_session_response",
            ServerOriginatedMessage::has_restart_session_response,
            ServerOriginatedMessage::restart_session_response,
            ServerOriginatedMessage::mut_restart_session_response,
            ServerOriginatedMessage::set_restart_session_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MenuItemResponse>(
            "menu_item_response",
            ServerOriginatedMessage::has_menu_item_response,
            ServerOriginatedMessage::menu_item_response,
            ServerOriginatedMessage::mut_menu_item_response,
            ServerOriginatedMessage::set_menu_item_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SetTabLayoutResponse>(
            "set_tab_layout_response",
            ServerOriginatedMessage::has_set_tab_layout_response,
            ServerOriginatedMessage::set_tab_layout_response,
            ServerOriginatedMessage::mut_set_tab_layout_response,
            ServerOriginatedMessage::set_set_tab_layout_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GetBroadcastDomainsResponse>(
            "get_broadcast_domains_response",
            ServerOriginatedMessage::has_get_broadcast_domains_response,
            ServerOriginatedMessage::get_broadcast_domains_response,
            ServerOriginatedMessage::mut_get_broadcast_domains_response,
            ServerOriginatedMessage::set_get_broadcast_domains_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TmuxResponse>(
            "tmux_response",
            ServerOriginatedMessage::has_tmux_response,
            ServerOriginatedMessage::tmux_response,
            ServerOriginatedMessage::mut_tmux_response,
            ServerOriginatedMessage::set_tmux_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ReorderTabsResponse>(
            "reorder_tabs_response",
            ServerOriginatedMessage::has_reorder_tabs_response,
            ServerOriginatedMessage::reorder_tabs_response,
            ServerOriginatedMessage::mut_reorder_tabs_response,
            ServerOriginatedMessage::set_reorder_tabs_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PreferencesResponse>(
            "preferences_response",
            ServerOriginatedMessage::has_preferences_response,
            ServerOriginatedMessage::preferences_response,
            ServerOriginatedMessage::mut_preferences_response,
            ServerOriginatedMessage::set_preferences_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ColorPresetResponse>(
            "color_preset_response",
            ServerOriginatedMessage::has_color_preset_response,
            ServerOriginatedMessage::color_preset_response,
            ServerOriginatedMessage::mut_color_preset_response,
            ServerOriginatedMessage::set_color_preset_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SelectionResponse>(
            "selection_response",
            ServerOriginatedMessage::has_selection_response,
            ServerOriginatedMessage::selection_response,
            ServerOriginatedMessage::mut_selection_response,
            ServerOriginatedMessage::set_selection_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StatusBarComponentResponse>(
            "status_bar_component_response",
            ServerOriginatedMessage::has_status_bar_component_response,
            ServerOriginatedMessage::status_bar_component_response,
            ServerOriginatedMessage::mut_status_bar_component_response,
            ServerOriginatedMessage::set_status_bar_component_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SetBroadcastDomainsResponse>(
            "set_broadcast_domains_response",
            ServerOriginatedMessage::has_set_broadcast_domains_response,
            ServerOriginatedMessage::set_broadcast_domains_response,
            ServerOriginatedMessage::mut_set_broadcast_domains_response,
            ServerOriginatedMessage::set_set_broadcast_domains_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CloseResponse>(
            "close_response",
            ServerOriginatedMessage::has_close_response,
            ServerOriginatedMessage::close_response,
            ServerOriginatedMessage::mut_close_response,
            ServerOriginatedMessage::set_close_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, InvokeFunctionResponse>(
            "invoke_function_response",
            ServerOriginatedMessage::has_invoke_function_response,
            ServerOriginatedMessage::invoke_function_response,
            ServerOriginatedMessage::mut_invoke_function_response,
            ServerOriginatedMessage::set_invoke_function_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ListPromptsResponse>(
            "list_prompts_response",
            ServerOriginatedMessage::has_list_prompts_response,
            ServerOriginatedMessage::list_prompts_response,
            ServerOriginatedMessage::mut_list_prompts_response,
            ServerOriginatedMessage::set_list_prompts_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Notification>(
            "notification",
            ServerOriginatedMessage::has_notification,
            ServerOriginatedMessage::notification,
            ServerOriginatedMessage::mut_notification,
            ServerOriginatedMessage::set_notification,
        ));
        oneofs.push(server_originated_message::Submessage::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerOriginatedMessage>(
            "ServerOriginatedMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerOriginatedMessage {
    const NAME: &'static str = "ServerOriginatedMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::Error(is.read_string()?));
                },
                802 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::GetBufferResponse(is.read_message()?));
                },
                810 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::GetPromptResponse(is.read_message()?));
                },
                818 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::TransactionResponse(is.read_message()?));
                },
                826 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::NotificationResponse(is.read_message()?));
                },
                834 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::RegisterToolResponse(is.read_message()?));
                },
                842 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SetProfilePropertyResponse(is.read_message()?));
                },
                850 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ListSessionsResponse(is.read_message()?));
                },
                858 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SendTextResponse(is.read_message()?));
                },
                866 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::CreateTabResponse(is.read_message()?));
                },
                874 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SplitPaneResponse(is.read_message()?));
                },
                882 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::GetProfilePropertyResponse(is.read_message()?));
                },
                890 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SetPropertyResponse(is.read_message()?));
                },
                898 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::GetPropertyResponse(is.read_message()?));
                },
                906 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::InjectResponse(is.read_message()?));
                },
                914 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ActivateResponse(is.read_message()?));
                },
                922 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::VariableResponse(is.read_message()?));
                },
                930 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SavedArrangementResponse(is.read_message()?));
                },
                938 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::FocusResponse(is.read_message()?));
                },
                946 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ListProfilesResponse(is.read_message()?));
                },
                954 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ServerOriginatedRpcResultResponse(is.read_message()?));
                },
                962 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::RestartSessionResponse(is.read_message()?));
                },
                970 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::MenuItemResponse(is.read_message()?));
                },
                978 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SetTabLayoutResponse(is.read_message()?));
                },
                986 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::GetBroadcastDomainsResponse(is.read_message()?));
                },
                994 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::TmuxResponse(is.read_message()?));
                },
                1002 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ReorderTabsResponse(is.read_message()?));
                },
                1010 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::PreferencesResponse(is.read_message()?));
                },
                1018 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ColorPresetResponse(is.read_message()?));
                },
                1026 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SelectionResponse(is.read_message()?));
                },
                1034 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::StatusBarComponentResponse(is.read_message()?));
                },
                1042 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::SetBroadcastDomainsResponse(is.read_message()?));
                },
                1050 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::CloseResponse(is.read_message()?));
                },
                1058 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::InvokeFunctionResponse(is.read_message()?));
                },
                1066 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::ListPromptsResponse(is.read_message()?));
                },
                8002 => {
                    self.submessage = ::std::option::Option::Some(server_originated_message::Submessage::Notification(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let ::std::option::Option::Some(ref v) = self.submessage {
            match v {
                &server_originated_message::Submessage::Error(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &server_originated_message::Submessage::GetBufferResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::GetPromptResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::TransactionResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::NotificationResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::RegisterToolResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::SetProfilePropertyResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::ListSessionsResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::SendTextResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::CreateTabResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::SplitPaneResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::GetProfilePropertyResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::SetPropertyResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::GetPropertyResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::InjectResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::ActivateResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::VariableResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::SavedArrangementResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::FocusResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::ListProfilesResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::ServerOriginatedRpcResultResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::RestartSessionResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::MenuItemResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::SetTabLayoutResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::GetBroadcastDomainsResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::TmuxResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::ReorderTabsResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::PreferencesResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::ColorPresetResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::SelectionResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::StatusBarComponentResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::SetBroadcastDomainsResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::CloseResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::InvokeFunctionResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::ListPromptsResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &server_originated_message::Submessage::Notification(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.submessage {
            match v {
                &server_originated_message::Submessage::Error(ref v) => {
                    os.write_string(2, v)?;
                },
                &server_originated_message::Submessage::GetBufferResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(100, v, os)?;
                },
                &server_originated_message::Submessage::GetPromptResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(101, v, os)?;
                },
                &server_originated_message::Submessage::TransactionResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(102, v, os)?;
                },
                &server_originated_message::Submessage::NotificationResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(103, v, os)?;
                },
                &server_originated_message::Submessage::RegisterToolResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(104, v, os)?;
                },
                &server_originated_message::Submessage::SetProfilePropertyResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(105, v, os)?;
                },
                &server_originated_message::Submessage::ListSessionsResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(106, v, os)?;
                },
                &server_originated_message::Submessage::SendTextResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(107, v, os)?;
                },
                &server_originated_message::Submessage::CreateTabResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(108, v, os)?;
                },
                &server_originated_message::Submessage::SplitPaneResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(109, v, os)?;
                },
                &server_originated_message::Submessage::GetProfilePropertyResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(110, v, os)?;
                },
                &server_originated_message::Submessage::SetPropertyResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(111, v, os)?;
                },
                &server_originated_message::Submessage::GetPropertyResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(112, v, os)?;
                },
                &server_originated_message::Submessage::InjectResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(113, v, os)?;
                },
                &server_originated_message::Submessage::ActivateResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(114, v, os)?;
                },
                &server_originated_message::Submessage::VariableResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(115, v, os)?;
                },
                &server_originated_message::Submessage::SavedArrangementResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(116, v, os)?;
                },
                &server_originated_message::Submessage::FocusResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(117, v, os)?;
                },
                &server_originated_message::Submessage::ListProfilesResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(118, v, os)?;
                },
                &server_originated_message::Submessage::ServerOriginatedRpcResultResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(119, v, os)?;
                },
                &server_originated_message::Submessage::RestartSessionResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(120, v, os)?;
                },
                &server_originated_message::Submessage::MenuItemResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(121, v, os)?;
                },
                &server_originated_message::Submessage::SetTabLayoutResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(122, v, os)?;
                },
                &server_originated_message::Submessage::GetBroadcastDomainsResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(123, v, os)?;
                },
                &server_originated_message::Submessage::TmuxResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(124, v, os)?;
                },
                &server_originated_message::Submessage::ReorderTabsResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(125, v, os)?;
                },
                &server_originated_message::Submessage::PreferencesResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(126, v, os)?;
                },
                &server_originated_message::Submessage::ColorPresetResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(127, v, os)?;
                },
                &server_originated_message::Submessage::SelectionResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(128, v, os)?;
                },
                &server_originated_message::Submessage::StatusBarComponentResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(129, v, os)?;
                },
                &server_originated_message::Submessage::SetBroadcastDomainsResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(130, v, os)?;
                },
                &server_originated_message::Submessage::CloseResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(131, v, os)?;
                },
                &server_originated_message::Submessage::InvokeFunctionResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(132, v, os)?;
                },
                &server_originated_message::Submessage::ListPromptsResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(133, v, os)?;
                },
                &server_originated_message::Submessage::Notification(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1000, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerOriginatedMessage {
        ServerOriginatedMessage::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.submessage = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerOriginatedMessage {
        static instance: ServerOriginatedMessage = ServerOriginatedMessage {
            id: ::std::option::Option::None,
            submessage: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerOriginatedMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerOriginatedMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerOriginatedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerOriginatedMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ServerOriginatedMessage`
pub mod server_originated_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.ServerOriginatedMessage.submessage)
    pub enum Submessage {
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.error)
        Error(::std::string::String),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.get_buffer_response)
        GetBufferResponse(super::GetBufferResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.get_prompt_response)
        GetPromptResponse(super::GetPromptResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.transaction_response)
        TransactionResponse(super::TransactionResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.notification_response)
        NotificationResponse(super::NotificationResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.register_tool_response)
        RegisterToolResponse(super::RegisterToolResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.set_profile_property_response)
        SetProfilePropertyResponse(super::SetProfilePropertyResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.list_sessions_response)
        ListSessionsResponse(super::ListSessionsResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.send_text_response)
        SendTextResponse(super::SendTextResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.create_tab_response)
        CreateTabResponse(super::CreateTabResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.split_pane_response)
        SplitPaneResponse(super::SplitPaneResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.get_profile_property_response)
        GetProfilePropertyResponse(super::GetProfilePropertyResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.set_property_response)
        SetPropertyResponse(super::SetPropertyResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.get_property_response)
        GetPropertyResponse(super::GetPropertyResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.inject_response)
        InjectResponse(super::InjectResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.activate_response)
        ActivateResponse(super::ActivateResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.variable_response)
        VariableResponse(super::VariableResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.saved_arrangement_response)
        SavedArrangementResponse(super::SavedArrangementResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.focus_response)
        FocusResponse(super::FocusResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.list_profiles_response)
        ListProfilesResponse(super::ListProfilesResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.server_originated_rpc_result_response)
        ServerOriginatedRpcResultResponse(super::ServerOriginatedRPCResultResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.restart_session_response)
        RestartSessionResponse(super::RestartSessionResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.menu_item_response)
        MenuItemResponse(super::MenuItemResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.set_tab_layout_response)
        SetTabLayoutResponse(super::SetTabLayoutResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.get_broadcast_domains_response)
        GetBroadcastDomainsResponse(super::GetBroadcastDomainsResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.tmux_response)
        TmuxResponse(super::TmuxResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.reorder_tabs_response)
        ReorderTabsResponse(super::ReorderTabsResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.preferences_response)
        PreferencesResponse(super::PreferencesResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.color_preset_response)
        ColorPresetResponse(super::ColorPresetResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.selection_response)
        SelectionResponse(super::SelectionResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.status_bar_component_response)
        StatusBarComponentResponse(super::StatusBarComponentResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.set_broadcast_domains_response)
        SetBroadcastDomainsResponse(super::SetBroadcastDomainsResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.close_response)
        CloseResponse(super::CloseResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.invoke_function_response)
        InvokeFunctionResponse(super::InvokeFunctionResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.list_prompts_response)
        ListPromptsResponse(super::ListPromptsResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedMessage.notification)
        Notification(super::Notification),
    }

    impl ::protobuf::Oneof for Submessage {
    }

    impl ::protobuf::OneofFull for Submessage {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ServerOriginatedMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("submessage").unwrap()).clone()
        }
    }

    impl Submessage {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Submessage>("submessage")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.InvokeFunctionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InvokeFunctionRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.InvokeFunctionRequest.invocation)
    pub invocation: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.InvokeFunctionRequest.timeout)
    pub timeout: ::std::option::Option<f64>,
    // message oneof groups
    pub context: ::std::option::Option<invoke_function_request::Context>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.InvokeFunctionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InvokeFunctionRequest {
    fn default() -> &'a InvokeFunctionRequest {
        <InvokeFunctionRequest as ::protobuf::Message>::default_instance()
    }
}

impl InvokeFunctionRequest {
    pub fn new() -> InvokeFunctionRequest {
        ::std::default::Default::default()
    }

    // optional .iterm2.InvokeFunctionRequest.Tab tab = 1;

    pub fn tab(&self) -> &invoke_function_request::Tab {
        match self.context {
            ::std::option::Option::Some(invoke_function_request::Context::Tab(ref v)) => v,
            _ => <invoke_function_request::Tab as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_tab(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_tab(&self) -> bool {
        match self.context {
            ::std::option::Option::Some(invoke_function_request::Context::Tab(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tab(&mut self, v: invoke_function_request::Tab) {
        self.context = ::std::option::Option::Some(invoke_function_request::Context::Tab(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tab(&mut self) -> &mut invoke_function_request::Tab {
        if let ::std::option::Option::Some(invoke_function_request::Context::Tab(_)) = self.context {
        } else {
            self.context = ::std::option::Option::Some(invoke_function_request::Context::Tab(invoke_function_request::Tab::new()));
        }
        match self.context {
            ::std::option::Option::Some(invoke_function_request::Context::Tab(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tab(&mut self) -> invoke_function_request::Tab {
        if self.has_tab() {
            match self.context.take() {
                ::std::option::Option::Some(invoke_function_request::Context::Tab(v)) => v,
                _ => panic!(),
            }
        } else {
            invoke_function_request::Tab::new()
        }
    }

    // optional .iterm2.InvokeFunctionRequest.Session session = 2;

    pub fn session(&self) -> &invoke_function_request::Session {
        match self.context {
            ::std::option::Option::Some(invoke_function_request::Context::Session(ref v)) => v,
            _ => <invoke_function_request::Session as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_session(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        match self.context {
            ::std::option::Option::Some(invoke_function_request::Context::Session(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: invoke_function_request::Session) {
        self.context = ::std::option::Option::Some(invoke_function_request::Context::Session(v))
    }

    // Mutable pointer to the field.
    pub fn mut_session(&mut self) -> &mut invoke_function_request::Session {
        if let ::std::option::Option::Some(invoke_function_request::Context::Session(_)) = self.context {
        } else {
            self.context = ::std::option::Option::Some(invoke_function_request::Context::Session(invoke_function_request::Session::new()));
        }
        match self.context {
            ::std::option::Option::Some(invoke_function_request::Context::Session(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_session(&mut self) -> invoke_function_request::Session {
        if self.has_session() {
            match self.context.take() {
                ::std::option::Option::Some(invoke_function_request::Context::Session(v)) => v,
                _ => panic!(),
            }
        } else {
            invoke_function_request::Session::new()
        }
    }

    // optional .iterm2.InvokeFunctionRequest.Window window = 3;

    pub fn window(&self) -> &invoke_function_request::Window {
        match self.context {
            ::std::option::Option::Some(invoke_function_request::Context::Window(ref v)) => v,
            _ => <invoke_function_request::Window as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_window(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_window(&self) -> bool {
        match self.context {
            ::std::option::Option::Some(invoke_function_request::Context::Window(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_window(&mut self, v: invoke_function_request::Window) {
        self.context = ::std::option::Option::Some(invoke_function_request::Context::Window(v))
    }

    // Mutable pointer to the field.
    pub fn mut_window(&mut self) -> &mut invoke_function_request::Window {
        if let ::std::option::Option::Some(invoke_function_request::Context::Window(_)) = self.context {
        } else {
            self.context = ::std::option::Option::Some(invoke_function_request::Context::Window(invoke_function_request::Window::new()));
        }
        match self.context {
            ::std::option::Option::Some(invoke_function_request::Context::Window(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_window(&mut self) -> invoke_function_request::Window {
        if self.has_window() {
            match self.context.take() {
                ::std::option::Option::Some(invoke_function_request::Context::Window(v)) => v,
                _ => panic!(),
            }
        } else {
            invoke_function_request::Window::new()
        }
    }

    // optional .iterm2.InvokeFunctionRequest.App app = 4;

    pub fn app(&self) -> &invoke_function_request::App {
        match self.context {
            ::std::option::Option::Some(invoke_function_request::Context::App(ref v)) => v,
            _ => <invoke_function_request::App as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_app(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_app(&self) -> bool {
        match self.context {
            ::std::option::Option::Some(invoke_function_request::Context::App(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_app(&mut self, v: invoke_function_request::App) {
        self.context = ::std::option::Option::Some(invoke_function_request::Context::App(v))
    }

    // Mutable pointer to the field.
    pub fn mut_app(&mut self) -> &mut invoke_function_request::App {
        if let ::std::option::Option::Some(invoke_function_request::Context::App(_)) = self.context {
        } else {
            self.context = ::std::option::Option::Some(invoke_function_request::Context::App(invoke_function_request::App::new()));
        }
        match self.context {
            ::std::option::Option::Some(invoke_function_request::Context::App(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_app(&mut self) -> invoke_function_request::App {
        if self.has_app() {
            match self.context.take() {
                ::std::option::Option::Some(invoke_function_request::Context::App(v)) => v,
                _ => panic!(),
            }
        } else {
            invoke_function_request::App::new()
        }
    }

    // optional .iterm2.InvokeFunctionRequest.Method method = 7;

    pub fn method(&self) -> &invoke_function_request::Method {
        match self.context {
            ::std::option::Option::Some(invoke_function_request::Context::Method(ref v)) => v,
            _ => <invoke_function_request::Method as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_method(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_method(&self) -> bool {
        match self.context {
            ::std::option::Option::Some(invoke_function_request::Context::Method(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: invoke_function_request::Method) {
        self.context = ::std::option::Option::Some(invoke_function_request::Context::Method(v))
    }

    // Mutable pointer to the field.
    pub fn mut_method(&mut self) -> &mut invoke_function_request::Method {
        if let ::std::option::Option::Some(invoke_function_request::Context::Method(_)) = self.context {
        } else {
            self.context = ::std::option::Option::Some(invoke_function_request::Context::Method(invoke_function_request::Method::new()));
        }
        match self.context {
            ::std::option::Option::Some(invoke_function_request::Context::Method(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_method(&mut self) -> invoke_function_request::Method {
        if self.has_method() {
            match self.context.take() {
                ::std::option::Option::Some(invoke_function_request::Context::Method(v)) => v,
                _ => panic!(),
            }
        } else {
            invoke_function_request::Method::new()
        }
    }

    // optional string invocation = 5;

    pub fn invocation(&self) -> &str {
        match self.invocation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invocation(&mut self) {
        self.invocation = ::std::option::Option::None;
    }

    pub fn has_invocation(&self) -> bool {
        self.invocation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invocation(&mut self, v: ::std::string::String) {
        self.invocation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invocation(&mut self) -> &mut ::std::string::String {
        if self.invocation.is_none() {
            self.invocation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invocation.as_mut().unwrap()
    }

    // Take field
    pub fn take_invocation(&mut self) -> ::std::string::String {
        self.invocation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double timeout = 6;

    pub fn timeout(&self) -> f64 {
        self.timeout.unwrap_or(-1.0f64)
    }

    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: f64) {
        self.timeout = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, invoke_function_request::Tab>(
            "tab",
            InvokeFunctionRequest::has_tab,
            InvokeFunctionRequest::tab,
            InvokeFunctionRequest::mut_tab,
            InvokeFunctionRequest::set_tab,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, invoke_function_request::Session>(
            "session",
            InvokeFunctionRequest::has_session,
            InvokeFunctionRequest::session,
            InvokeFunctionRequest::mut_session,
            InvokeFunctionRequest::set_session,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, invoke_function_request::Window>(
            "window",
            InvokeFunctionRequest::has_window,
            InvokeFunctionRequest::window,
            InvokeFunctionRequest::mut_window,
            InvokeFunctionRequest::set_window,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, invoke_function_request::App>(
            "app",
            InvokeFunctionRequest::has_app,
            InvokeFunctionRequest::app,
            InvokeFunctionRequest::mut_app,
            InvokeFunctionRequest::set_app,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, invoke_function_request::Method>(
            "method",
            InvokeFunctionRequest::has_method,
            InvokeFunctionRequest::method,
            InvokeFunctionRequest::mut_method,
            InvokeFunctionRequest::set_method,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "invocation",
            |m: &InvokeFunctionRequest| { &m.invocation },
            |m: &mut InvokeFunctionRequest| { &mut m.invocation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeout",
            |m: &InvokeFunctionRequest| { &m.timeout },
            |m: &mut InvokeFunctionRequest| { &mut m.timeout },
        ));
        oneofs.push(invoke_function_request::Context::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InvokeFunctionRequest>(
            "InvokeFunctionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InvokeFunctionRequest {
    const NAME: &'static str = "InvokeFunctionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.context = ::std::option::Option::Some(invoke_function_request::Context::Tab(is.read_message()?));
                },
                18 => {
                    self.context = ::std::option::Option::Some(invoke_function_request::Context::Session(is.read_message()?));
                },
                26 => {
                    self.context = ::std::option::Option::Some(invoke_function_request::Context::Window(is.read_message()?));
                },
                34 => {
                    self.context = ::std::option::Option::Some(invoke_function_request::Context::App(is.read_message()?));
                },
                58 => {
                    self.context = ::std::option::Option::Some(invoke_function_request::Context::Method(is.read_message()?));
                },
                42 => {
                    self.invocation = ::std::option::Option::Some(is.read_string()?);
                },
                49 => {
                    self.timeout = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.invocation.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.timeout {
            my_size += 1 + 8;
        }
        if let ::std::option::Option::Some(ref v) = self.context {
            match v {
                &invoke_function_request::Context::Tab(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &invoke_function_request::Context::Session(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &invoke_function_request::Context::Window(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &invoke_function_request::Context::App(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &invoke_function_request::Context::Method(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.invocation.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_double(6, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.context {
            match v {
                &invoke_function_request::Context::Tab(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &invoke_function_request::Context::Session(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &invoke_function_request::Context::Window(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &invoke_function_request::Context::App(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &invoke_function_request::Context::Method(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InvokeFunctionRequest {
        InvokeFunctionRequest::new()
    }

    fn clear(&mut self) {
        self.context = ::std::option::Option::None;
        self.context = ::std::option::Option::None;
        self.context = ::std::option::Option::None;
        self.context = ::std::option::Option::None;
        self.context = ::std::option::Option::None;
        self.invocation = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InvokeFunctionRequest {
        static instance: InvokeFunctionRequest = InvokeFunctionRequest {
            invocation: ::std::option::Option::None,
            timeout: ::std::option::Option::None,
            context: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InvokeFunctionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InvokeFunctionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InvokeFunctionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvokeFunctionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InvokeFunctionRequest`
pub mod invoke_function_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.InvokeFunctionRequest.context)
    pub enum Context {
        // @@protoc_insertion_point(oneof_field:iterm2.InvokeFunctionRequest.tab)
        Tab(Tab),
        // @@protoc_insertion_point(oneof_field:iterm2.InvokeFunctionRequest.session)
        Session(Session),
        // @@protoc_insertion_point(oneof_field:iterm2.InvokeFunctionRequest.window)
        Window(Window),
        // @@protoc_insertion_point(oneof_field:iterm2.InvokeFunctionRequest.app)
        App(App),
        // @@protoc_insertion_point(oneof_field:iterm2.InvokeFunctionRequest.method)
        Method(Method),
    }

    impl ::protobuf::Oneof for Context {
    }

    impl ::protobuf::OneofFull for Context {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::InvokeFunctionRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("context").unwrap()).clone()
        }
    }

    impl Context {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Context>("context")
        }
    }
    // @@protoc_insertion_point(message:iterm2.InvokeFunctionRequest.Tab)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tab {
        // message fields
        // @@protoc_insertion_point(field:iterm2.InvokeFunctionRequest.Tab.tab_id)
        pub tab_id: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.InvokeFunctionRequest.Tab.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tab {
        fn default() -> &'a Tab {
            <Tab as ::protobuf::Message>::default_instance()
        }
    }

    impl Tab {
        pub fn new() -> Tab {
            ::std::default::Default::default()
        }

        // optional string tab_id = 1;

        pub fn tab_id(&self) -> &str {
            match self.tab_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_tab_id(&mut self) {
            self.tab_id = ::std::option::Option::None;
        }

        pub fn has_tab_id(&self) -> bool {
            self.tab_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tab_id(&mut self, v: ::std::string::String) {
            self.tab_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tab_id(&mut self) -> &mut ::std::string::String {
            if self.tab_id.is_none() {
                self.tab_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.tab_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_tab_id(&mut self) -> ::std::string::String {
            self.tab_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tab_id",
                |m: &Tab| { &m.tab_id },
                |m: &mut Tab| { &mut m.tab_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tab>(
                "InvokeFunctionRequest.Tab",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Tab {
        const NAME: &'static str = "Tab";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.tab_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tab_id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.tab_id.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tab {
            Tab::new()
        }

        fn clear(&mut self) {
            self.tab_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tab {
            static instance: Tab = Tab {
                tab_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Tab {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InvokeFunctionRequest.Tab").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Tab {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Tab {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.InvokeFunctionRequest.Session)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Session {
        // message fields
        // @@protoc_insertion_point(field:iterm2.InvokeFunctionRequest.Session.session_id)
        pub session_id: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.InvokeFunctionRequest.Session.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Session {
        fn default() -> &'a Session {
            <Session as ::protobuf::Message>::default_instance()
        }
    }

    impl Session {
        pub fn new() -> Session {
            ::std::default::Default::default()
        }

        // optional string session_id = 1;

        pub fn session_id(&self) -> &str {
            match self.session_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_session_id(&mut self) {
            self.session_id = ::std::option::Option::None;
        }

        pub fn has_session_id(&self) -> bool {
            self.session_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_session_id(&mut self, v: ::std::string::String) {
            self.session_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
            if self.session_id.is_none() {
                self.session_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.session_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_session_id(&mut self) -> ::std::string::String {
            self.session_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "session_id",
                |m: &Session| { &m.session_id },
                |m: &mut Session| { &mut m.session_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Session>(
                "InvokeFunctionRequest.Session",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Session {
        const NAME: &'static str = "Session";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.session_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.session_id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.session_id.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Session {
            Session::new()
        }

        fn clear(&mut self) {
            self.session_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Session {
            static instance: Session = Session {
                session_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Session {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InvokeFunctionRequest.Session").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Session {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Session {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.InvokeFunctionRequest.Window)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Window {
        // message fields
        // @@protoc_insertion_point(field:iterm2.InvokeFunctionRequest.Window.window_id)
        pub window_id: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.InvokeFunctionRequest.Window.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Window {
        fn default() -> &'a Window {
            <Window as ::protobuf::Message>::default_instance()
        }
    }

    impl Window {
        pub fn new() -> Window {
            ::std::default::Default::default()
        }

        // optional string window_id = 1;

        pub fn window_id(&self) -> &str {
            match self.window_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_window_id(&mut self) {
            self.window_id = ::std::option::Option::None;
        }

        pub fn has_window_id(&self) -> bool {
            self.window_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_window_id(&mut self, v: ::std::string::String) {
            self.window_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_window_id(&mut self) -> &mut ::std::string::String {
            if self.window_id.is_none() {
                self.window_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.window_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_window_id(&mut self) -> ::std::string::String {
            self.window_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "window_id",
                |m: &Window| { &m.window_id },
                |m: &mut Window| { &mut m.window_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Window>(
                "InvokeFunctionRequest.Window",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Window {
        const NAME: &'static str = "Window";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.window_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.window_id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.window_id.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Window {
            Window::new()
        }

        fn clear(&mut self) {
            self.window_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Window {
            static instance: Window = Window {
                window_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Window {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InvokeFunctionRequest.Window").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Window {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Window {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.InvokeFunctionRequest.App)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct App {
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.InvokeFunctionRequest.App.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a App {
        fn default() -> &'a App {
            <App as ::protobuf::Message>::default_instance()
        }
    }

    impl App {
        pub fn new() -> App {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<App>(
                "InvokeFunctionRequest.App",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for App {
        const NAME: &'static str = "App";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> App {
            App::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static App {
            static instance: App = App {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for App {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InvokeFunctionRequest.App").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for App {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for App {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.InvokeFunctionRequest.Method)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Method {
        // message fields
        // @@protoc_insertion_point(field:iterm2.InvokeFunctionRequest.Method.receiver)
        pub receiver: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.InvokeFunctionRequest.Method.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Method {
        fn default() -> &'a Method {
            <Method as ::protobuf::Message>::default_instance()
        }
    }

    impl Method {
        pub fn new() -> Method {
            ::std::default::Default::default()
        }

        // optional string receiver = 1;

        pub fn receiver(&self) -> &str {
            match self.receiver.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_receiver(&mut self) {
            self.receiver = ::std::option::Option::None;
        }

        pub fn has_receiver(&self) -> bool {
            self.receiver.is_some()
        }

        // Param is passed by value, moved
        pub fn set_receiver(&mut self, v: ::std::string::String) {
            self.receiver = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_receiver(&mut self) -> &mut ::std::string::String {
            if self.receiver.is_none() {
                self.receiver = ::std::option::Option::Some(::std::string::String::new());
            }
            self.receiver.as_mut().unwrap()
        }

        // Take field
        pub fn take_receiver(&mut self) -> ::std::string::String {
            self.receiver.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "receiver",
                |m: &Method| { &m.receiver },
                |m: &mut Method| { &mut m.receiver },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Method>(
                "InvokeFunctionRequest.Method",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Method {
        const NAME: &'static str = "Method";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.receiver = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.receiver.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.receiver.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Method {
            Method::new()
        }

        fn clear(&mut self) {
            self.receiver = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Method {
            static instance: Method = Method {
                receiver: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Method {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InvokeFunctionRequest.Method").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Method {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Method {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:iterm2.InvokeFunctionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InvokeFunctionResponse {
    // message oneof groups
    pub disposition: ::std::option::Option<invoke_function_response::Disposition>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.InvokeFunctionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InvokeFunctionResponse {
    fn default() -> &'a InvokeFunctionResponse {
        <InvokeFunctionResponse as ::protobuf::Message>::default_instance()
    }
}

impl InvokeFunctionResponse {
    pub fn new() -> InvokeFunctionResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.InvokeFunctionResponse.Error error = 1;

    pub fn error(&self) -> &invoke_function_response::Error {
        match self.disposition {
            ::std::option::Option::Some(invoke_function_response::Disposition::Error(ref v)) => v,
            _ => <invoke_function_response::Error as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_error(&mut self) {
        self.disposition = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.disposition {
            ::std::option::Option::Some(invoke_function_response::Disposition::Error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: invoke_function_response::Error) {
        self.disposition = ::std::option::Option::Some(invoke_function_response::Disposition::Error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut invoke_function_response::Error {
        if let ::std::option::Option::Some(invoke_function_response::Disposition::Error(_)) = self.disposition {
        } else {
            self.disposition = ::std::option::Option::Some(invoke_function_response::Disposition::Error(invoke_function_response::Error::new()));
        }
        match self.disposition {
            ::std::option::Option::Some(invoke_function_response::Disposition::Error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> invoke_function_response::Error {
        if self.has_error() {
            match self.disposition.take() {
                ::std::option::Option::Some(invoke_function_response::Disposition::Error(v)) => v,
                _ => panic!(),
            }
        } else {
            invoke_function_response::Error::new()
        }
    }

    // optional .iterm2.InvokeFunctionResponse.Success success = 2;

    pub fn success(&self) -> &invoke_function_response::Success {
        match self.disposition {
            ::std::option::Option::Some(invoke_function_response::Disposition::Success(ref v)) => v,
            _ => <invoke_function_response::Success as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_success(&mut self) {
        self.disposition = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        match self.disposition {
            ::std::option::Option::Some(invoke_function_response::Disposition::Success(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: invoke_function_response::Success) {
        self.disposition = ::std::option::Option::Some(invoke_function_response::Disposition::Success(v))
    }

    // Mutable pointer to the field.
    pub fn mut_success(&mut self) -> &mut invoke_function_response::Success {
        if let ::std::option::Option::Some(invoke_function_response::Disposition::Success(_)) = self.disposition {
        } else {
            self.disposition = ::std::option::Option::Some(invoke_function_response::Disposition::Success(invoke_function_response::Success::new()));
        }
        match self.disposition {
            ::std::option::Option::Some(invoke_function_response::Disposition::Success(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_success(&mut self) -> invoke_function_response::Success {
        if self.has_success() {
            match self.disposition.take() {
                ::std::option::Option::Some(invoke_function_response::Disposition::Success(v)) => v,
                _ => panic!(),
            }
        } else {
            invoke_function_response::Success::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, invoke_function_response::Error>(
            "error",
            InvokeFunctionResponse::has_error,
            InvokeFunctionResponse::error,
            InvokeFunctionResponse::mut_error,
            InvokeFunctionResponse::set_error,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, invoke_function_response::Success>(
            "success",
            InvokeFunctionResponse::has_success,
            InvokeFunctionResponse::success,
            InvokeFunctionResponse::mut_success,
            InvokeFunctionResponse::set_success,
        ));
        oneofs.push(invoke_function_response::Disposition::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InvokeFunctionResponse>(
            "InvokeFunctionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InvokeFunctionResponse {
    const NAME: &'static str = "InvokeFunctionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.disposition = ::std::option::Option::Some(invoke_function_response::Disposition::Error(is.read_message()?));
                },
                18 => {
                    self.disposition = ::std::option::Option::Some(invoke_function_response::Disposition::Success(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.disposition {
            match v {
                &invoke_function_response::Disposition::Error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &invoke_function_response::Disposition::Success(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.disposition {
            match v {
                &invoke_function_response::Disposition::Error(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &invoke_function_response::Disposition::Success(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InvokeFunctionResponse {
        InvokeFunctionResponse::new()
    }

    fn clear(&mut self) {
        self.disposition = ::std::option::Option::None;
        self.disposition = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InvokeFunctionResponse {
        static instance: InvokeFunctionResponse = InvokeFunctionResponse {
            disposition: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InvokeFunctionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InvokeFunctionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InvokeFunctionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvokeFunctionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InvokeFunctionResponse`
pub mod invoke_function_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.InvokeFunctionResponse.disposition)
    pub enum Disposition {
        // @@protoc_insertion_point(oneof_field:iterm2.InvokeFunctionResponse.error)
        Error(Error),
        // @@protoc_insertion_point(oneof_field:iterm2.InvokeFunctionResponse.success)
        Success(Success),
    }

    impl ::protobuf::Oneof for Disposition {
    }

    impl ::protobuf::OneofFull for Disposition {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::InvokeFunctionResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("disposition").unwrap()).clone()
        }
    }

    impl Disposition {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Disposition>("disposition")
        }
    }
    // @@protoc_insertion_point(message:iterm2.InvokeFunctionResponse.Error)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Error {
        // message fields
        // @@protoc_insertion_point(field:iterm2.InvokeFunctionResponse.Error.status)
        pub status: ::std::option::Option<::protobuf::EnumOrUnknown<Status>>,
        // @@protoc_insertion_point(field:iterm2.InvokeFunctionResponse.Error.error_reason)
        pub error_reason: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.InvokeFunctionResponse.Error.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Error {
        fn default() -> &'a Error {
            <Error as ::protobuf::Message>::default_instance()
        }
    }

    impl Error {
        pub fn new() -> Error {
            ::std::default::Default::default()
        }

        // optional .iterm2.InvokeFunctionResponse.Status status = 1;

        pub fn status(&self) -> Status {
            match self.status {
                Some(e) => e.enum_value_or(Status::TIMEOUT),
                None => Status::TIMEOUT,
            }
        }

        pub fn clear_status(&mut self) {
            self.status = ::std::option::Option::None;
        }

        pub fn has_status(&self) -> bool {
            self.status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_status(&mut self, v: Status) {
            self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string error_reason = 2;

        pub fn error_reason(&self) -> &str {
            match self.error_reason.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_error_reason(&mut self) {
            self.error_reason = ::std::option::Option::None;
        }

        pub fn has_error_reason(&self) -> bool {
            self.error_reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_error_reason(&mut self, v: ::std::string::String) {
            self.error_reason = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_error_reason(&mut self) -> &mut ::std::string::String {
            if self.error_reason.is_none() {
                self.error_reason = ::std::option::Option::Some(::std::string::String::new());
            }
            self.error_reason.as_mut().unwrap()
        }

        // Take field
        pub fn take_error_reason(&mut self) -> ::std::string::String {
            self.error_reason.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "status",
                |m: &Error| { &m.status },
                |m: &mut Error| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "error_reason",
                |m: &Error| { &m.error_reason },
                |m: &mut Error| { &mut m.error_reason },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Error>(
                "InvokeFunctionResponse.Error",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Error {
        const NAME: &'static str = "Error";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        self.error_reason = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.status {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.error_reason.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.status {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.error_reason.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Error {
            Error::new()
        }

        fn clear(&mut self) {
            self.status = ::std::option::Option::None;
            self.error_reason = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Error {
            static instance: Error = Error {
                status: ::std::option::Option::None,
                error_reason: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Error {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InvokeFunctionResponse.Error").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Error {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Error {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.InvokeFunctionResponse.Success)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Success {
        // message fields
        // @@protoc_insertion_point(field:iterm2.InvokeFunctionResponse.Success.json_result)
        pub json_result: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.InvokeFunctionResponse.Success.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Success {
        fn default() -> &'a Success {
            <Success as ::protobuf::Message>::default_instance()
        }
    }

    impl Success {
        pub fn new() -> Success {
            ::std::default::Default::default()
        }

        // optional string json_result = 1;

        pub fn json_result(&self) -> &str {
            match self.json_result.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_json_result(&mut self) {
            self.json_result = ::std::option::Option::None;
        }

        pub fn has_json_result(&self) -> bool {
            self.json_result.is_some()
        }

        // Param is passed by value, moved
        pub fn set_json_result(&mut self, v: ::std::string::String) {
            self.json_result = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_json_result(&mut self) -> &mut ::std::string::String {
            if self.json_result.is_none() {
                self.json_result = ::std::option::Option::Some(::std::string::String::new());
            }
            self.json_result.as_mut().unwrap()
        }

        // Take field
        pub fn take_json_result(&mut self) -> ::std::string::String {
            self.json_result.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "json_result",
                |m: &Success| { &m.json_result },
                |m: &mut Success| { &mut m.json_result },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Success>(
                "InvokeFunctionResponse.Success",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Success {
        const NAME: &'static str = "Success";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.json_result = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.json_result.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.json_result.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Success {
            Success::new()
        }

        fn clear(&mut self) {
            self.json_result = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Success {
            static instance: Success = Success {
                json_result: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Success {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InvokeFunctionResponse.Success").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Success {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Success {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.InvokeFunctionResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.InvokeFunctionResponse.Status.TIMEOUT)
        TIMEOUT = 1,
        // @@protoc_insertion_point(enum_value:iterm2.InvokeFunctionResponse.Status.FAILED)
        FAILED = 2,
        // @@protoc_insertion_point(enum_value:iterm2.InvokeFunctionResponse.Status.REQUEST_MALFORMED)
        REQUEST_MALFORMED = 3,
        // @@protoc_insertion_point(enum_value:iterm2.InvokeFunctionResponse.Status.INVALID_ID)
        INVALID_ID = 4,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                1 => ::std::option::Option::Some(Status::TIMEOUT),
                2 => ::std::option::Option::Some(Status::FAILED),
                3 => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                4 => ::std::option::Option::Some(Status::INVALID_ID),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "TIMEOUT" => ::std::option::Option::Some(Status::TIMEOUT),
                "FAILED" => ::std::option::Option::Some(Status::FAILED),
                "REQUEST_MALFORMED" => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                "INVALID_ID" => ::std::option::Option::Some(Status::INVALID_ID),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::TIMEOUT,
            Status::FAILED,
            Status::REQUEST_MALFORMED,
            Status::INVALID_ID,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("InvokeFunctionResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Status::TIMEOUT => 0,
                Status::FAILED => 1,
                Status::REQUEST_MALFORMED => 2,
                Status::INVALID_ID => 3,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::TIMEOUT
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("InvokeFunctionResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.CloseRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CloseRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.CloseRequest.force)
    pub force: ::std::option::Option<bool>,
    // message oneof groups
    pub target: ::std::option::Option<close_request::Target>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.CloseRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CloseRequest {
    fn default() -> &'a CloseRequest {
        <CloseRequest as ::protobuf::Message>::default_instance()
    }
}

impl CloseRequest {
    pub fn new() -> CloseRequest {
        ::std::default::Default::default()
    }

    // optional .iterm2.CloseRequest.CloseTabs tabs = 1;

    pub fn tabs(&self) -> &close_request::CloseTabs {
        match self.target {
            ::std::option::Option::Some(close_request::Target::Tabs(ref v)) => v,
            _ => <close_request::CloseTabs as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_tabs(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_tabs(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(close_request::Target::Tabs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tabs(&mut self, v: close_request::CloseTabs) {
        self.target = ::std::option::Option::Some(close_request::Target::Tabs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tabs(&mut self) -> &mut close_request::CloseTabs {
        if let ::std::option::Option::Some(close_request::Target::Tabs(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(close_request::Target::Tabs(close_request::CloseTabs::new()));
        }
        match self.target {
            ::std::option::Option::Some(close_request::Target::Tabs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tabs(&mut self) -> close_request::CloseTabs {
        if self.has_tabs() {
            match self.target.take() {
                ::std::option::Option::Some(close_request::Target::Tabs(v)) => v,
                _ => panic!(),
            }
        } else {
            close_request::CloseTabs::new()
        }
    }

    // optional .iterm2.CloseRequest.CloseSessions sessions = 2;

    pub fn sessions(&self) -> &close_request::CloseSessions {
        match self.target {
            ::std::option::Option::Some(close_request::Target::Sessions(ref v)) => v,
            _ => <close_request::CloseSessions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sessions(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_sessions(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(close_request::Target::Sessions(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sessions(&mut self, v: close_request::CloseSessions) {
        self.target = ::std::option::Option::Some(close_request::Target::Sessions(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sessions(&mut self) -> &mut close_request::CloseSessions {
        if let ::std::option::Option::Some(close_request::Target::Sessions(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(close_request::Target::Sessions(close_request::CloseSessions::new()));
        }
        match self.target {
            ::std::option::Option::Some(close_request::Target::Sessions(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sessions(&mut self) -> close_request::CloseSessions {
        if self.has_sessions() {
            match self.target.take() {
                ::std::option::Option::Some(close_request::Target::Sessions(v)) => v,
                _ => panic!(),
            }
        } else {
            close_request::CloseSessions::new()
        }
    }

    // optional .iterm2.CloseRequest.CloseWindows windows = 3;

    pub fn windows(&self) -> &close_request::CloseWindows {
        match self.target {
            ::std::option::Option::Some(close_request::Target::Windows(ref v)) => v,
            _ => <close_request::CloseWindows as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_windows(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_windows(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(close_request::Target::Windows(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_windows(&mut self, v: close_request::CloseWindows) {
        self.target = ::std::option::Option::Some(close_request::Target::Windows(v))
    }

    // Mutable pointer to the field.
    pub fn mut_windows(&mut self) -> &mut close_request::CloseWindows {
        if let ::std::option::Option::Some(close_request::Target::Windows(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(close_request::Target::Windows(close_request::CloseWindows::new()));
        }
        match self.target {
            ::std::option::Option::Some(close_request::Target::Windows(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_windows(&mut self) -> close_request::CloseWindows {
        if self.has_windows() {
            match self.target.take() {
                ::std::option::Option::Some(close_request::Target::Windows(v)) => v,
                _ => panic!(),
            }
        } else {
            close_request::CloseWindows::new()
        }
    }

    // optional bool force = 4;

    pub fn force(&self) -> bool {
        self.force.unwrap_or(false)
    }

    pub fn clear_force(&mut self) {
        self.force = ::std::option::Option::None;
    }

    pub fn has_force(&self) -> bool {
        self.force.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, close_request::CloseTabs>(
            "tabs",
            CloseRequest::has_tabs,
            CloseRequest::tabs,
            CloseRequest::mut_tabs,
            CloseRequest::set_tabs,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, close_request::CloseSessions>(
            "sessions",
            CloseRequest::has_sessions,
            CloseRequest::sessions,
            CloseRequest::mut_sessions,
            CloseRequest::set_sessions,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, close_request::CloseWindows>(
            "windows",
            CloseRequest::has_windows,
            CloseRequest::windows,
            CloseRequest::mut_windows,
            CloseRequest::set_windows,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "force",
            |m: &CloseRequest| { &m.force },
            |m: &mut CloseRequest| { &mut m.force },
        ));
        oneofs.push(close_request::Target::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CloseRequest>(
            "CloseRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CloseRequest {
    const NAME: &'static str = "CloseRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.target = ::std::option::Option::Some(close_request::Target::Tabs(is.read_message()?));
                },
                18 => {
                    self.target = ::std::option::Option::Some(close_request::Target::Sessions(is.read_message()?));
                },
                26 => {
                    self.target = ::std::option::Option::Some(close_request::Target::Windows(is.read_message()?));
                },
                32 => {
                    self.force = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.force {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &close_request::Target::Tabs(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &close_request::Target::Sessions(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &close_request::Target::Windows(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.force {
            os.write_bool(4, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &close_request::Target::Tabs(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &close_request::Target::Sessions(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &close_request::Target::Windows(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CloseRequest {
        CloseRequest::new()
    }

    fn clear(&mut self) {
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.force = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CloseRequest {
        static instance: CloseRequest = CloseRequest {
            force: ::std::option::Option::None,
            target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CloseRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CloseRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CloseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CloseRequest`
pub mod close_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.CloseRequest.target)
    pub enum Target {
        // @@protoc_insertion_point(oneof_field:iterm2.CloseRequest.tabs)
        Tabs(CloseTabs),
        // @@protoc_insertion_point(oneof_field:iterm2.CloseRequest.sessions)
        Sessions(CloseSessions),
        // @@protoc_insertion_point(oneof_field:iterm2.CloseRequest.windows)
        Windows(CloseWindows),
    }

    impl ::protobuf::Oneof for Target {
    }

    impl ::protobuf::OneofFull for Target {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CloseRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("target").unwrap()).clone()
        }
    }

    impl Target {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Target>("target")
        }
    }
    // @@protoc_insertion_point(message:iterm2.CloseRequest.CloseTabs)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CloseTabs {
        // message fields
        // @@protoc_insertion_point(field:iterm2.CloseRequest.CloseTabs.tab_ids)
        pub tab_ids: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.CloseRequest.CloseTabs.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CloseTabs {
        fn default() -> &'a CloseTabs {
            <CloseTabs as ::protobuf::Message>::default_instance()
        }
    }

    impl CloseTabs {
        pub fn new() -> CloseTabs {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "tab_ids",
                |m: &CloseTabs| { &m.tab_ids },
                |m: &mut CloseTabs| { &mut m.tab_ids },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CloseTabs>(
                "CloseRequest.CloseTabs",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CloseTabs {
        const NAME: &'static str = "CloseTabs";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.tab_ids.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.tab_ids {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.tab_ids {
                os.write_string(1, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CloseTabs {
            CloseTabs::new()
        }

        fn clear(&mut self) {
            self.tab_ids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CloseTabs {
            static instance: CloseTabs = CloseTabs {
                tab_ids: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CloseTabs {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CloseRequest.CloseTabs").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CloseTabs {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CloseTabs {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.CloseRequest.CloseSessions)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CloseSessions {
        // message fields
        // @@protoc_insertion_point(field:iterm2.CloseRequest.CloseSessions.session_ids)
        pub session_ids: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.CloseRequest.CloseSessions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CloseSessions {
        fn default() -> &'a CloseSessions {
            <CloseSessions as ::protobuf::Message>::default_instance()
        }
    }

    impl CloseSessions {
        pub fn new() -> CloseSessions {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "session_ids",
                |m: &CloseSessions| { &m.session_ids },
                |m: &mut CloseSessions| { &mut m.session_ids },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CloseSessions>(
                "CloseRequest.CloseSessions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CloseSessions {
        const NAME: &'static str = "CloseSessions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.session_ids.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.session_ids {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.session_ids {
                os.write_string(1, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CloseSessions {
            CloseSessions::new()
        }

        fn clear(&mut self) {
            self.session_ids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CloseSessions {
            static instance: CloseSessions = CloseSessions {
                session_ids: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CloseSessions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CloseRequest.CloseSessions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CloseSessions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CloseSessions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.CloseRequest.CloseWindows)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CloseWindows {
        // message fields
        // @@protoc_insertion_point(field:iterm2.CloseRequest.CloseWindows.window_ids)
        pub window_ids: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.CloseRequest.CloseWindows.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CloseWindows {
        fn default() -> &'a CloseWindows {
            <CloseWindows as ::protobuf::Message>::default_instance()
        }
    }

    impl CloseWindows {
        pub fn new() -> CloseWindows {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "window_ids",
                |m: &CloseWindows| { &m.window_ids },
                |m: &mut CloseWindows| { &mut m.window_ids },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CloseWindows>(
                "CloseRequest.CloseWindows",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CloseWindows {
        const NAME: &'static str = "CloseWindows";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.window_ids.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.window_ids {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.window_ids {
                os.write_string(1, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CloseWindows {
            CloseWindows::new()
        }

        fn clear(&mut self) {
            self.window_ids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CloseWindows {
            static instance: CloseWindows = CloseWindows {
                window_ids: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CloseWindows {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CloseRequest.CloseWindows").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CloseWindows {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CloseWindows {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:iterm2.CloseResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CloseResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.CloseResponse.statuses)
    pub statuses: ::std::vec::Vec<::protobuf::EnumOrUnknown<close_response::Status>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.CloseResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CloseResponse {
    fn default() -> &'a CloseResponse {
        <CloseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CloseResponse {
    pub fn new() -> CloseResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "statuses",
            |m: &CloseResponse| { &m.statuses },
            |m: &mut CloseResponse| { &mut m.statuses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CloseResponse>(
            "CloseResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CloseResponse {
    const NAME: &'static str = "CloseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.statuses.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.statuses)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.statuses {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.statuses {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CloseResponse {
        CloseResponse::new()
    }

    fn clear(&mut self) {
        self.statuses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CloseResponse {
        static instance: CloseResponse = CloseResponse {
            statuses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CloseResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CloseResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CloseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CloseResponse`
pub mod close_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.CloseResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.CloseResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.CloseResponse.Status.NOT_FOUND)
        NOT_FOUND = 1,
        // @@protoc_insertion_point(enum_value:iterm2.CloseResponse.Status.USER_DECLINED)
        USER_DECLINED = 2,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::NOT_FOUND),
                2 => ::std::option::Option::Some(Status::USER_DECLINED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "NOT_FOUND" => ::std::option::Option::Some(Status::NOT_FOUND),
                "USER_DECLINED" => ::std::option::Option::Some(Status::USER_DECLINED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::NOT_FOUND,
            Status::USER_DECLINED,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CloseResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("CloseResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.SetBroadcastDomainsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetBroadcastDomainsRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SetBroadcastDomainsRequest.broadcast_domains)
    pub broadcast_domains: ::std::vec::Vec<BroadcastDomain>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SetBroadcastDomainsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetBroadcastDomainsRequest {
    fn default() -> &'a SetBroadcastDomainsRequest {
        <SetBroadcastDomainsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetBroadcastDomainsRequest {
    pub fn new() -> SetBroadcastDomainsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "broadcast_domains",
            |m: &SetBroadcastDomainsRequest| { &m.broadcast_domains },
            |m: &mut SetBroadcastDomainsRequest| { &mut m.broadcast_domains },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetBroadcastDomainsRequest>(
            "SetBroadcastDomainsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetBroadcastDomainsRequest {
    const NAME: &'static str = "SetBroadcastDomainsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.broadcast_domains.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.broadcast_domains {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.broadcast_domains {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetBroadcastDomainsRequest {
        SetBroadcastDomainsRequest::new()
    }

    fn clear(&mut self) {
        self.broadcast_domains.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetBroadcastDomainsRequest {
        static instance: SetBroadcastDomainsRequest = SetBroadcastDomainsRequest {
            broadcast_domains: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetBroadcastDomainsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetBroadcastDomainsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetBroadcastDomainsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetBroadcastDomainsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.SetBroadcastDomainsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetBroadcastDomainsResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SetBroadcastDomainsResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<set_broadcast_domains_response::Status>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SetBroadcastDomainsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetBroadcastDomainsResponse {
    fn default() -> &'a SetBroadcastDomainsResponse {
        <SetBroadcastDomainsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetBroadcastDomainsResponse {
    pub fn new() -> SetBroadcastDomainsResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.SetBroadcastDomainsResponse.Status status = 1;

    pub fn status(&self) -> set_broadcast_domains_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(set_broadcast_domains_response::Status::OK),
            None => set_broadcast_domains_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: set_broadcast_domains_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &SetBroadcastDomainsResponse| { &m.status },
            |m: &mut SetBroadcastDomainsResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetBroadcastDomainsResponse>(
            "SetBroadcastDomainsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetBroadcastDomainsResponse {
    const NAME: &'static str = "SetBroadcastDomainsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetBroadcastDomainsResponse {
        SetBroadcastDomainsResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetBroadcastDomainsResponse {
        static instance: SetBroadcastDomainsResponse = SetBroadcastDomainsResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetBroadcastDomainsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetBroadcastDomainsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetBroadcastDomainsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetBroadcastDomainsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SetBroadcastDomainsResponse`
pub mod set_broadcast_domains_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.SetBroadcastDomainsResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.SetBroadcastDomainsResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.SetBroadcastDomainsResponse.Status.SESSION_NOT_FOUND)
        SESSION_NOT_FOUND = 1,
        // @@protoc_insertion_point(enum_value:iterm2.SetBroadcastDomainsResponse.Status.BROADCAST_DOMAINS_NOT_DISJOINT)
        BROADCAST_DOMAINS_NOT_DISJOINT = 2,
        // @@protoc_insertion_point(enum_value:iterm2.SetBroadcastDomainsResponse.Status.SESSIONS_NOT_IN_SAME_WINDOW)
        SESSIONS_NOT_IN_SAME_WINDOW = 3,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                2 => ::std::option::Option::Some(Status::BROADCAST_DOMAINS_NOT_DISJOINT),
                3 => ::std::option::Option::Some(Status::SESSIONS_NOT_IN_SAME_WINDOW),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "SESSION_NOT_FOUND" => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                "BROADCAST_DOMAINS_NOT_DISJOINT" => ::std::option::Option::Some(Status::BROADCAST_DOMAINS_NOT_DISJOINT),
                "SESSIONS_NOT_IN_SAME_WINDOW" => ::std::option::Option::Some(Status::SESSIONS_NOT_IN_SAME_WINDOW),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::SESSION_NOT_FOUND,
            Status::BROADCAST_DOMAINS_NOT_DISJOINT,
            Status::SESSIONS_NOT_IN_SAME_WINDOW,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SetBroadcastDomainsResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("SetBroadcastDomainsResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.StatusBarComponentRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatusBarComponentRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.StatusBarComponentRequest.identifier)
    pub identifier: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub request: ::std::option::Option<status_bar_component_request::Request>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.StatusBarComponentRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatusBarComponentRequest {
    fn default() -> &'a StatusBarComponentRequest {
        <StatusBarComponentRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatusBarComponentRequest {
    pub fn new() -> StatusBarComponentRequest {
        ::std::default::Default::default()
    }

    // optional .iterm2.StatusBarComponentRequest.OpenPopover open_popover = 1;

    pub fn open_popover(&self) -> &status_bar_component_request::OpenPopover {
        match self.request {
            ::std::option::Option::Some(status_bar_component_request::Request::OpenPopover(ref v)) => v,
            _ => <status_bar_component_request::OpenPopover as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_open_popover(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_open_popover(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(status_bar_component_request::Request::OpenPopover(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_open_popover(&mut self, v: status_bar_component_request::OpenPopover) {
        self.request = ::std::option::Option::Some(status_bar_component_request::Request::OpenPopover(v))
    }

    // Mutable pointer to the field.
    pub fn mut_open_popover(&mut self) -> &mut status_bar_component_request::OpenPopover {
        if let ::std::option::Option::Some(status_bar_component_request::Request::OpenPopover(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(status_bar_component_request::Request::OpenPopover(status_bar_component_request::OpenPopover::new()));
        }
        match self.request {
            ::std::option::Option::Some(status_bar_component_request::Request::OpenPopover(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_open_popover(&mut self) -> status_bar_component_request::OpenPopover {
        if self.has_open_popover() {
            match self.request.take() {
                ::std::option::Option::Some(status_bar_component_request::Request::OpenPopover(v)) => v,
                _ => panic!(),
            }
        } else {
            status_bar_component_request::OpenPopover::new()
        }
    }

    // optional string identifier = 2;

    pub fn identifier(&self) -> &str {
        match self.identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identifier(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::string::String) {
        self.identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
        if self.identifier.is_none() {
            self.identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::string::String {
        self.identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, status_bar_component_request::OpenPopover>(
            "open_popover",
            StatusBarComponentRequest::has_open_popover,
            StatusBarComponentRequest::open_popover,
            StatusBarComponentRequest::mut_open_popover,
            StatusBarComponentRequest::set_open_popover,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identifier",
            |m: &StatusBarComponentRequest| { &m.identifier },
            |m: &mut StatusBarComponentRequest| { &mut m.identifier },
        ));
        oneofs.push(status_bar_component_request::Request::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatusBarComponentRequest>(
            "StatusBarComponentRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatusBarComponentRequest {
    const NAME: &'static str = "StatusBarComponentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.request = ::std::option::Option::Some(status_bar_component_request::Request::OpenPopover(is.read_message()?));
                },
                18 => {
                    self.identifier = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &status_bar_component_request::Request::OpenPopover(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.identifier.as_ref() {
            os.write_string(2, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &status_bar_component_request::Request::OpenPopover(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatusBarComponentRequest {
        StatusBarComponentRequest::new()
    }

    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatusBarComponentRequest {
        static instance: StatusBarComponentRequest = StatusBarComponentRequest {
            identifier: ::std::option::Option::None,
            request: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatusBarComponentRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatusBarComponentRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatusBarComponentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusBarComponentRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StatusBarComponentRequest`
pub mod status_bar_component_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.StatusBarComponentRequest.request)
    pub enum Request {
        // @@protoc_insertion_point(oneof_field:iterm2.StatusBarComponentRequest.open_popover)
        OpenPopover(OpenPopover),
    }

    impl ::protobuf::Oneof for Request {
    }

    impl ::protobuf::OneofFull for Request {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::StatusBarComponentRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("request").unwrap()).clone()
        }
    }

    impl Request {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Request>("request")
        }
    }
    // @@protoc_insertion_point(message:iterm2.StatusBarComponentRequest.OpenPopover)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct OpenPopover {
        // message fields
        // @@protoc_insertion_point(field:iterm2.StatusBarComponentRequest.OpenPopover.session_id)
        pub session_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.StatusBarComponentRequest.OpenPopover.html)
        pub html: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.StatusBarComponentRequest.OpenPopover.size)
        pub size: ::protobuf::MessageField<super::Size>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.StatusBarComponentRequest.OpenPopover.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a OpenPopover {
        fn default() -> &'a OpenPopover {
            <OpenPopover as ::protobuf::Message>::default_instance()
        }
    }

    impl OpenPopover {
        pub fn new() -> OpenPopover {
            ::std::default::Default::default()
        }

        // optional string session_id = 1;

        pub fn session_id(&self) -> &str {
            match self.session_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_session_id(&mut self) {
            self.session_id = ::std::option::Option::None;
        }

        pub fn has_session_id(&self) -> bool {
            self.session_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_session_id(&mut self, v: ::std::string::String) {
            self.session_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
            if self.session_id.is_none() {
                self.session_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.session_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_session_id(&mut self) -> ::std::string::String {
            self.session_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string html = 2;

        pub fn html(&self) -> &str {
            match self.html.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_html(&mut self) {
            self.html = ::std::option::Option::None;
        }

        pub fn has_html(&self) -> bool {
            self.html.is_some()
        }

        // Param is passed by value, moved
        pub fn set_html(&mut self, v: ::std::string::String) {
            self.html = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_html(&mut self) -> &mut ::std::string::String {
            if self.html.is_none() {
                self.html = ::std::option::Option::Some(::std::string::String::new());
            }
            self.html.as_mut().unwrap()
        }

        // Take field
        pub fn take_html(&mut self) -> ::std::string::String {
            self.html.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "session_id",
                |m: &OpenPopover| { &m.session_id },
                |m: &mut OpenPopover| { &mut m.session_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "html",
                |m: &OpenPopover| { &m.html },
                |m: &mut OpenPopover| { &mut m.html },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Size>(
                "size",
                |m: &OpenPopover| { &m.size },
                |m: &mut OpenPopover| { &mut m.size },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OpenPopover>(
                "StatusBarComponentRequest.OpenPopover",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for OpenPopover {
        const NAME: &'static str = "OpenPopover";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.session_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.html = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.size)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.session_id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.html.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.size.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.session_id.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.html.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.size.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> OpenPopover {
            OpenPopover::new()
        }

        fn clear(&mut self) {
            self.session_id = ::std::option::Option::None;
            self.html = ::std::option::Option::None;
            self.size.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static OpenPopover {
            static instance: OpenPopover = OpenPopover {
                session_id: ::std::option::Option::None,
                html: ::std::option::Option::None,
                size: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for OpenPopover {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StatusBarComponentRequest.OpenPopover").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for OpenPopover {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for OpenPopover {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:iterm2.StatusBarComponentResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatusBarComponentResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.StatusBarComponentResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<status_bar_component_response::Status>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.StatusBarComponentResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatusBarComponentResponse {
    fn default() -> &'a StatusBarComponentResponse {
        <StatusBarComponentResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatusBarComponentResponse {
    pub fn new() -> StatusBarComponentResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.StatusBarComponentResponse.Status status = 1;

    pub fn status(&self) -> status_bar_component_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(status_bar_component_response::Status::OK),
            None => status_bar_component_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: status_bar_component_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &StatusBarComponentResponse| { &m.status },
            |m: &mut StatusBarComponentResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatusBarComponentResponse>(
            "StatusBarComponentResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatusBarComponentResponse {
    const NAME: &'static str = "StatusBarComponentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatusBarComponentResponse {
        StatusBarComponentResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatusBarComponentResponse {
        static instance: StatusBarComponentResponse = StatusBarComponentResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatusBarComponentResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatusBarComponentResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatusBarComponentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusBarComponentResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StatusBarComponentResponse`
pub mod status_bar_component_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.StatusBarComponentResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.StatusBarComponentResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.StatusBarComponentResponse.Status.SESSION_NOT_FOUND)
        SESSION_NOT_FOUND = 1,
        // @@protoc_insertion_point(enum_value:iterm2.StatusBarComponentResponse.Status.REQUEST_MALFORMED)
        REQUEST_MALFORMED = 2,
        // @@protoc_insertion_point(enum_value:iterm2.StatusBarComponentResponse.Status.INVALID_IDENTIFIER)
        INVALID_IDENTIFIER = 3,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                2 => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                3 => ::std::option::Option::Some(Status::INVALID_IDENTIFIER),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "SESSION_NOT_FOUND" => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                "REQUEST_MALFORMED" => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                "INVALID_IDENTIFIER" => ::std::option::Option::Some(Status::INVALID_IDENTIFIER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::SESSION_NOT_FOUND,
            Status::REQUEST_MALFORMED,
            Status::INVALID_IDENTIFIER,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StatusBarComponentResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("StatusBarComponentResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.WindowedCoordRange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WindowedCoordRange {
    // message fields
    // @@protoc_insertion_point(field:iterm2.WindowedCoordRange.coord_range)
    pub coord_range: ::protobuf::MessageField<CoordRange>,
    // @@protoc_insertion_point(field:iterm2.WindowedCoordRange.columns)
    pub columns: ::protobuf::MessageField<Range>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.WindowedCoordRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WindowedCoordRange {
    fn default() -> &'a WindowedCoordRange {
        <WindowedCoordRange as ::protobuf::Message>::default_instance()
    }
}

impl WindowedCoordRange {
    pub fn new() -> WindowedCoordRange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CoordRange>(
            "coord_range",
            |m: &WindowedCoordRange| { &m.coord_range },
            |m: &mut WindowedCoordRange| { &mut m.coord_range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Range>(
            "columns",
            |m: &WindowedCoordRange| { &m.columns },
            |m: &mut WindowedCoordRange| { &mut m.columns },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WindowedCoordRange>(
            "WindowedCoordRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WindowedCoordRange {
    const NAME: &'static str = "WindowedCoordRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.coord_range)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.columns)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coord_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.columns.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coord_range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.columns.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WindowedCoordRange {
        WindowedCoordRange::new()
    }

    fn clear(&mut self) {
        self.coord_range.clear();
        self.columns.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WindowedCoordRange {
        static instance: WindowedCoordRange = WindowedCoordRange {
            coord_range: ::protobuf::MessageField::none(),
            columns: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WindowedCoordRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WindowedCoordRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WindowedCoordRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowedCoordRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.SubSelection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubSelection {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SubSelection.windowed_coord_range)
    pub windowed_coord_range: ::protobuf::MessageField<WindowedCoordRange>,
    // @@protoc_insertion_point(field:iterm2.SubSelection.selection_mode)
    pub selection_mode: ::std::option::Option<::protobuf::EnumOrUnknown<SelectionMode>>,
    // @@protoc_insertion_point(field:iterm2.SubSelection.connected)
    pub connected: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SubSelection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubSelection {
    fn default() -> &'a SubSelection {
        <SubSelection as ::protobuf::Message>::default_instance()
    }
}

impl SubSelection {
    pub fn new() -> SubSelection {
        ::std::default::Default::default()
    }

    // optional .iterm2.SelectionMode selection_mode = 2;

    pub fn selection_mode(&self) -> SelectionMode {
        match self.selection_mode {
            Some(e) => e.enum_value_or(SelectionMode::CHARACTER),
            None => SelectionMode::CHARACTER,
        }
    }

    pub fn clear_selection_mode(&mut self) {
        self.selection_mode = ::std::option::Option::None;
    }

    pub fn has_selection_mode(&self) -> bool {
        self.selection_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_mode(&mut self, v: SelectionMode) {
        self.selection_mode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool connected = 3;

    pub fn connected(&self) -> bool {
        self.connected.unwrap_or(false)
    }

    pub fn clear_connected(&mut self) {
        self.connected = ::std::option::Option::None;
    }

    pub fn has_connected(&self) -> bool {
        self.connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connected(&mut self, v: bool) {
        self.connected = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WindowedCoordRange>(
            "windowed_coord_range",
            |m: &SubSelection| { &m.windowed_coord_range },
            |m: &mut SubSelection| { &mut m.windowed_coord_range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selection_mode",
            |m: &SubSelection| { &m.selection_mode },
            |m: &mut SubSelection| { &mut m.selection_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connected",
            |m: &SubSelection| { &m.connected },
            |m: &mut SubSelection| { &mut m.connected },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubSelection>(
            "SubSelection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubSelection {
    const NAME: &'static str = "SubSelection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.windowed_coord_range)?;
                },
                16 => {
                    self.selection_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.connected = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.windowed_coord_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.selection_mode {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.connected {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.windowed_coord_range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.selection_mode {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.connected {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubSelection {
        SubSelection::new()
    }

    fn clear(&mut self) {
        self.windowed_coord_range.clear();
        self.selection_mode = ::std::option::Option::None;
        self.connected = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubSelection {
        static instance: SubSelection = SubSelection {
            windowed_coord_range: ::protobuf::MessageField::none(),
            selection_mode: ::std::option::Option::None,
            connected: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubSelection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubSelection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubSelection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubSelection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.Selection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Selection {
    // message fields
    // @@protoc_insertion_point(field:iterm2.Selection.sub_selections)
    pub sub_selections: ::std::vec::Vec<SubSelection>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.Selection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Selection {
    fn default() -> &'a Selection {
        <Selection as ::protobuf::Message>::default_instance()
    }
}

impl Selection {
    pub fn new() -> Selection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sub_selections",
            |m: &Selection| { &m.sub_selections },
            |m: &mut Selection| { &mut m.sub_selections },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Selection>(
            "Selection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Selection {
    const NAME: &'static str = "Selection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sub_selections.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sub_selections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.sub_selections {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Selection {
        Selection::new()
    }

    fn clear(&mut self) {
        self.sub_selections.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Selection {
        static instance: Selection = Selection {
            sub_selections: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Selection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Selection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Selection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Selection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.SelectionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SelectionRequest {
    // message oneof groups
    pub request: ::std::option::Option<selection_request::Request>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SelectionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelectionRequest {
    fn default() -> &'a SelectionRequest {
        <SelectionRequest as ::protobuf::Message>::default_instance()
    }
}

impl SelectionRequest {
    pub fn new() -> SelectionRequest {
        ::std::default::Default::default()
    }

    // optional .iterm2.SelectionRequest.GetSelectionRequest get_selection_request = 1;

    pub fn get_selection_request(&self) -> &selection_request::GetSelectionRequest {
        match self.request {
            ::std::option::Option::Some(selection_request::Request::GetSelectionRequest(ref v)) => v,
            _ => <selection_request::GetSelectionRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_selection_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_get_selection_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(selection_request::Request::GetSelectionRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_selection_request(&mut self, v: selection_request::GetSelectionRequest) {
        self.request = ::std::option::Option::Some(selection_request::Request::GetSelectionRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_selection_request(&mut self) -> &mut selection_request::GetSelectionRequest {
        if let ::std::option::Option::Some(selection_request::Request::GetSelectionRequest(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(selection_request::Request::GetSelectionRequest(selection_request::GetSelectionRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(selection_request::Request::GetSelectionRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_selection_request(&mut self) -> selection_request::GetSelectionRequest {
        if self.has_get_selection_request() {
            match self.request.take() {
                ::std::option::Option::Some(selection_request::Request::GetSelectionRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            selection_request::GetSelectionRequest::new()
        }
    }

    // optional .iterm2.SelectionRequest.SetSelectionRequest set_selection_request = 2;

    pub fn set_selection_request(&self) -> &selection_request::SetSelectionRequest {
        match self.request {
            ::std::option::Option::Some(selection_request::Request::SetSelectionRequest(ref v)) => v,
            _ => <selection_request::SetSelectionRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_selection_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_set_selection_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(selection_request::Request::SetSelectionRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_selection_request(&mut self, v: selection_request::SetSelectionRequest) {
        self.request = ::std::option::Option::Some(selection_request::Request::SetSelectionRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_selection_request(&mut self) -> &mut selection_request::SetSelectionRequest {
        if let ::std::option::Option::Some(selection_request::Request::SetSelectionRequest(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(selection_request::Request::SetSelectionRequest(selection_request::SetSelectionRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(selection_request::Request::SetSelectionRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_selection_request(&mut self) -> selection_request::SetSelectionRequest {
        if self.has_set_selection_request() {
            match self.request.take() {
                ::std::option::Option::Some(selection_request::Request::SetSelectionRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            selection_request::SetSelectionRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, selection_request::GetSelectionRequest>(
            "get_selection_request",
            SelectionRequest::has_get_selection_request,
            SelectionRequest::get_selection_request,
            SelectionRequest::mut_get_selection_request,
            SelectionRequest::set_get_selection_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, selection_request::SetSelectionRequest>(
            "set_selection_request",
            SelectionRequest::has_set_selection_request,
            SelectionRequest::set_selection_request,
            SelectionRequest::mut_set_selection_request,
            SelectionRequest::set_set_selection_request,
        ));
        oneofs.push(selection_request::Request::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectionRequest>(
            "SelectionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelectionRequest {
    const NAME: &'static str = "SelectionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.request = ::std::option::Option::Some(selection_request::Request::GetSelectionRequest(is.read_message()?));
                },
                18 => {
                    self.request = ::std::option::Option::Some(selection_request::Request::SetSelectionRequest(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &selection_request::Request::GetSelectionRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &selection_request::Request::SetSelectionRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &selection_request::Request::GetSelectionRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &selection_request::Request::SetSelectionRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelectionRequest {
        SelectionRequest::new()
    }

    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelectionRequest {
        static instance: SelectionRequest = SelectionRequest {
            request: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelectionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelectionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelectionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SelectionRequest`
pub mod selection_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.SelectionRequest.request)
    pub enum Request {
        // @@protoc_insertion_point(oneof_field:iterm2.SelectionRequest.get_selection_request)
        GetSelectionRequest(GetSelectionRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.SelectionRequest.set_selection_request)
        SetSelectionRequest(SetSelectionRequest),
    }

    impl ::protobuf::Oneof for Request {
    }

    impl ::protobuf::OneofFull for Request {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::SelectionRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("request").unwrap()).clone()
        }
    }

    impl Request {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Request>("request")
        }
    }
    // @@protoc_insertion_point(message:iterm2.SelectionRequest.GetSelectionRequest)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GetSelectionRequest {
        // message fields
        // @@protoc_insertion_point(field:iterm2.SelectionRequest.GetSelectionRequest.session_id)
        pub session_id: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.SelectionRequest.GetSelectionRequest.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GetSelectionRequest {
        fn default() -> &'a GetSelectionRequest {
            <GetSelectionRequest as ::protobuf::Message>::default_instance()
        }
    }

    impl GetSelectionRequest {
        pub fn new() -> GetSelectionRequest {
            ::std::default::Default::default()
        }

        // optional string session_id = 1;

        pub fn session_id(&self) -> &str {
            match self.session_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_session_id(&mut self) {
            self.session_id = ::std::option::Option::None;
        }

        pub fn has_session_id(&self) -> bool {
            self.session_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_session_id(&mut self, v: ::std::string::String) {
            self.session_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
            if self.session_id.is_none() {
                self.session_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.session_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_session_id(&mut self) -> ::std::string::String {
            self.session_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "session_id",
                |m: &GetSelectionRequest| { &m.session_id },
                |m: &mut GetSelectionRequest| { &mut m.session_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSelectionRequest>(
                "SelectionRequest.GetSelectionRequest",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GetSelectionRequest {
        const NAME: &'static str = "GetSelectionRequest";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.session_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.session_id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.session_id.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GetSelectionRequest {
            GetSelectionRequest::new()
        }

        fn clear(&mut self) {
            self.session_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GetSelectionRequest {
            static instance: GetSelectionRequest = GetSelectionRequest {
                session_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GetSelectionRequest {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SelectionRequest.GetSelectionRequest").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GetSelectionRequest {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GetSelectionRequest {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.SelectionRequest.SetSelectionRequest)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetSelectionRequest {
        // message fields
        // @@protoc_insertion_point(field:iterm2.SelectionRequest.SetSelectionRequest.session_id)
        pub session_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.SelectionRequest.SetSelectionRequest.selection)
        pub selection: ::protobuf::MessageField<super::Selection>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.SelectionRequest.SetSelectionRequest.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetSelectionRequest {
        fn default() -> &'a SetSelectionRequest {
            <SetSelectionRequest as ::protobuf::Message>::default_instance()
        }
    }

    impl SetSelectionRequest {
        pub fn new() -> SetSelectionRequest {
            ::std::default::Default::default()
        }

        // optional string session_id = 1;

        pub fn session_id(&self) -> &str {
            match self.session_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_session_id(&mut self) {
            self.session_id = ::std::option::Option::None;
        }

        pub fn has_session_id(&self) -> bool {
            self.session_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_session_id(&mut self, v: ::std::string::String) {
            self.session_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
            if self.session_id.is_none() {
                self.session_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.session_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_session_id(&mut self) -> ::std::string::String {
            self.session_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "session_id",
                |m: &SetSelectionRequest| { &m.session_id },
                |m: &mut SetSelectionRequest| { &mut m.session_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Selection>(
                "selection",
                |m: &SetSelectionRequest| { &m.selection },
                |m: &mut SetSelectionRequest| { &mut m.selection },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetSelectionRequest>(
                "SelectionRequest.SetSelectionRequest",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SetSelectionRequest {
        const NAME: &'static str = "SetSelectionRequest";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.session_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.selection)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.session_id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.selection.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.session_id.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.selection.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetSelectionRequest {
            SetSelectionRequest::new()
        }

        fn clear(&mut self) {
            self.session_id = ::std::option::Option::None;
            self.selection.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetSelectionRequest {
            static instance: SetSelectionRequest = SetSelectionRequest {
                session_id: ::std::option::Option::None,
                selection: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SetSelectionRequest {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SelectionRequest.SetSelectionRequest").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SetSelectionRequest {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SetSelectionRequest {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:iterm2.SelectionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SelectionResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SelectionResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<selection_response::Status>>,
    // message oneof groups
    pub response: ::std::option::Option<selection_response::Response>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SelectionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelectionResponse {
    fn default() -> &'a SelectionResponse {
        <SelectionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SelectionResponse {
    pub fn new() -> SelectionResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.SelectionResponse.Status status = 1;

    pub fn status(&self) -> selection_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(selection_response::Status::OK),
            None => selection_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: selection_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .iterm2.SelectionResponse.GetSelectionResponse get_selection_response = 2;

    pub fn get_selection_response(&self) -> &selection_response::GetSelectionResponse {
        match self.response {
            ::std::option::Option::Some(selection_response::Response::GetSelectionResponse(ref v)) => v,
            _ => <selection_response::GetSelectionResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_selection_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_get_selection_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(selection_response::Response::GetSelectionResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_selection_response(&mut self, v: selection_response::GetSelectionResponse) {
        self.response = ::std::option::Option::Some(selection_response::Response::GetSelectionResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_selection_response(&mut self) -> &mut selection_response::GetSelectionResponse {
        if let ::std::option::Option::Some(selection_response::Response::GetSelectionResponse(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(selection_response::Response::GetSelectionResponse(selection_response::GetSelectionResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(selection_response::Response::GetSelectionResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_selection_response(&mut self) -> selection_response::GetSelectionResponse {
        if self.has_get_selection_response() {
            match self.response.take() {
                ::std::option::Option::Some(selection_response::Response::GetSelectionResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            selection_response::GetSelectionResponse::new()
        }
    }

    // optional .iterm2.SelectionResponse.SetSelectionResponse set_selection_response = 3;

    pub fn set_selection_response(&self) -> &selection_response::SetSelectionResponse {
        match self.response {
            ::std::option::Option::Some(selection_response::Response::SetSelectionResponse(ref v)) => v,
            _ => <selection_response::SetSelectionResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_selection_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_set_selection_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(selection_response::Response::SetSelectionResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_selection_response(&mut self, v: selection_response::SetSelectionResponse) {
        self.response = ::std::option::Option::Some(selection_response::Response::SetSelectionResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_selection_response(&mut self) -> &mut selection_response::SetSelectionResponse {
        if let ::std::option::Option::Some(selection_response::Response::SetSelectionResponse(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(selection_response::Response::SetSelectionResponse(selection_response::SetSelectionResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(selection_response::Response::SetSelectionResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_selection_response(&mut self) -> selection_response::SetSelectionResponse {
        if self.has_set_selection_response() {
            match self.response.take() {
                ::std::option::Option::Some(selection_response::Response::SetSelectionResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            selection_response::SetSelectionResponse::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &SelectionResponse| { &m.status },
            |m: &mut SelectionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, selection_response::GetSelectionResponse>(
            "get_selection_response",
            SelectionResponse::has_get_selection_response,
            SelectionResponse::get_selection_response,
            SelectionResponse::mut_get_selection_response,
            SelectionResponse::set_get_selection_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, selection_response::SetSelectionResponse>(
            "set_selection_response",
            SelectionResponse::has_set_selection_response,
            SelectionResponse::set_selection_response,
            SelectionResponse::mut_set_selection_response,
            SelectionResponse::set_set_selection_response,
        ));
        oneofs.push(selection_response::Response::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectionResponse>(
            "SelectionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelectionResponse {
    const NAME: &'static str = "SelectionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.response = ::std::option::Option::Some(selection_response::Response::GetSelectionResponse(is.read_message()?));
                },
                26 => {
                    self.response = ::std::option::Option::Some(selection_response::Response::SetSelectionResponse(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &selection_response::Response::GetSelectionResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &selection_response::Response::SetSelectionResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &selection_response::Response::GetSelectionResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &selection_response::Response::SetSelectionResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelectionResponse {
        SelectionResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelectionResponse {
        static instance: SelectionResponse = SelectionResponse {
            status: ::std::option::Option::None,
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelectionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelectionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelectionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SelectionResponse`
pub mod selection_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.SelectionResponse.response)
    pub enum Response {
        // @@protoc_insertion_point(oneof_field:iterm2.SelectionResponse.get_selection_response)
        GetSelectionResponse(GetSelectionResponse),
        // @@protoc_insertion_point(oneof_field:iterm2.SelectionResponse.set_selection_response)
        SetSelectionResponse(SetSelectionResponse),
    }

    impl ::protobuf::Oneof for Response {
    }

    impl ::protobuf::OneofFull for Response {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::SelectionResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("response").unwrap()).clone()
        }
    }

    impl Response {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Response>("response")
        }
    }
    // @@protoc_insertion_point(message:iterm2.SelectionResponse.GetSelectionResponse)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GetSelectionResponse {
        // message fields
        // @@protoc_insertion_point(field:iterm2.SelectionResponse.GetSelectionResponse.selection)
        pub selection: ::protobuf::MessageField<super::Selection>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.SelectionResponse.GetSelectionResponse.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GetSelectionResponse {
        fn default() -> &'a GetSelectionResponse {
            <GetSelectionResponse as ::protobuf::Message>::default_instance()
        }
    }

    impl GetSelectionResponse {
        pub fn new() -> GetSelectionResponse {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Selection>(
                "selection",
                |m: &GetSelectionResponse| { &m.selection },
                |m: &mut GetSelectionResponse| { &mut m.selection },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSelectionResponse>(
                "SelectionResponse.GetSelectionResponse",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GetSelectionResponse {
        const NAME: &'static str = "GetSelectionResponse";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.selection)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.selection.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.selection.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GetSelectionResponse {
            GetSelectionResponse::new()
        }

        fn clear(&mut self) {
            self.selection.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GetSelectionResponse {
            static instance: GetSelectionResponse = GetSelectionResponse {
                selection: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GetSelectionResponse {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SelectionResponse.GetSelectionResponse").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GetSelectionResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GetSelectionResponse {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.SelectionResponse.SetSelectionResponse)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetSelectionResponse {
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.SelectionResponse.SetSelectionResponse.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetSelectionResponse {
        fn default() -> &'a SetSelectionResponse {
            <SetSelectionResponse as ::protobuf::Message>::default_instance()
        }
    }

    impl SetSelectionResponse {
        pub fn new() -> SetSelectionResponse {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetSelectionResponse>(
                "SelectionResponse.SetSelectionResponse",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SetSelectionResponse {
        const NAME: &'static str = "SetSelectionResponse";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetSelectionResponse {
            SetSelectionResponse::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetSelectionResponse {
            static instance: SetSelectionResponse = SetSelectionResponse {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SetSelectionResponse {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SelectionResponse.SetSelectionResponse").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SetSelectionResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SetSelectionResponse {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.SelectionResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.SelectionResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.SelectionResponse.Status.INVALID_SESSION)
        INVALID_SESSION = 1,
        // @@protoc_insertion_point(enum_value:iterm2.SelectionResponse.Status.INVALID_RANGE)
        INVALID_RANGE = 2,
        // @@protoc_insertion_point(enum_value:iterm2.SelectionResponse.Status.REQUEST_MALFORMED)
        REQUEST_MALFORMED = 3,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::INVALID_SESSION),
                2 => ::std::option::Option::Some(Status::INVALID_RANGE),
                3 => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "INVALID_SESSION" => ::std::option::Option::Some(Status::INVALID_SESSION),
                "INVALID_RANGE" => ::std::option::Option::Some(Status::INVALID_RANGE),
                "REQUEST_MALFORMED" => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::INVALID_SESSION,
            Status::INVALID_RANGE,
            Status::REQUEST_MALFORMED,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SelectionResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("SelectionResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.ColorPresetRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ColorPresetRequest {
    // message oneof groups
    pub request: ::std::option::Option<color_preset_request::Request>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ColorPresetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ColorPresetRequest {
    fn default() -> &'a ColorPresetRequest {
        <ColorPresetRequest as ::protobuf::Message>::default_instance()
    }
}

impl ColorPresetRequest {
    pub fn new() -> ColorPresetRequest {
        ::std::default::Default::default()
    }

    // optional .iterm2.ColorPresetRequest.ListPresets list_presets = 1;

    pub fn list_presets(&self) -> &color_preset_request::ListPresets {
        match self.request {
            ::std::option::Option::Some(color_preset_request::Request::ListPresets(ref v)) => v,
            _ => <color_preset_request::ListPresets as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_list_presets(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_list_presets(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(color_preset_request::Request::ListPresets(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_presets(&mut self, v: color_preset_request::ListPresets) {
        self.request = ::std::option::Option::Some(color_preset_request::Request::ListPresets(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_presets(&mut self) -> &mut color_preset_request::ListPresets {
        if let ::std::option::Option::Some(color_preset_request::Request::ListPresets(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(color_preset_request::Request::ListPresets(color_preset_request::ListPresets::new()));
        }
        match self.request {
            ::std::option::Option::Some(color_preset_request::Request::ListPresets(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_presets(&mut self) -> color_preset_request::ListPresets {
        if self.has_list_presets() {
            match self.request.take() {
                ::std::option::Option::Some(color_preset_request::Request::ListPresets(v)) => v,
                _ => panic!(),
            }
        } else {
            color_preset_request::ListPresets::new()
        }
    }

    // optional .iterm2.ColorPresetRequest.GetPreset get_preset = 2;

    pub fn get_preset(&self) -> &color_preset_request::GetPreset {
        match self.request {
            ::std::option::Option::Some(color_preset_request::Request::GetPreset(ref v)) => v,
            _ => <color_preset_request::GetPreset as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_preset(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_get_preset(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(color_preset_request::Request::GetPreset(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_preset(&mut self, v: color_preset_request::GetPreset) {
        self.request = ::std::option::Option::Some(color_preset_request::Request::GetPreset(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_preset(&mut self) -> &mut color_preset_request::GetPreset {
        if let ::std::option::Option::Some(color_preset_request::Request::GetPreset(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(color_preset_request::Request::GetPreset(color_preset_request::GetPreset::new()));
        }
        match self.request {
            ::std::option::Option::Some(color_preset_request::Request::GetPreset(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_preset(&mut self) -> color_preset_request::GetPreset {
        if self.has_get_preset() {
            match self.request.take() {
                ::std::option::Option::Some(color_preset_request::Request::GetPreset(v)) => v,
                _ => panic!(),
            }
        } else {
            color_preset_request::GetPreset::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, color_preset_request::ListPresets>(
            "list_presets",
            ColorPresetRequest::has_list_presets,
            ColorPresetRequest::list_presets,
            ColorPresetRequest::mut_list_presets,
            ColorPresetRequest::set_list_presets,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, color_preset_request::GetPreset>(
            "get_preset",
            ColorPresetRequest::has_get_preset,
            ColorPresetRequest::get_preset,
            ColorPresetRequest::mut_get_preset,
            ColorPresetRequest::set_get_preset,
        ));
        oneofs.push(color_preset_request::Request::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ColorPresetRequest>(
            "ColorPresetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ColorPresetRequest {
    const NAME: &'static str = "ColorPresetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.request = ::std::option::Option::Some(color_preset_request::Request::ListPresets(is.read_message()?));
                },
                18 => {
                    self.request = ::std::option::Option::Some(color_preset_request::Request::GetPreset(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &color_preset_request::Request::ListPresets(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &color_preset_request::Request::GetPreset(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &color_preset_request::Request::ListPresets(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &color_preset_request::Request::GetPreset(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ColorPresetRequest {
        ColorPresetRequest::new()
    }

    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ColorPresetRequest {
        static instance: ColorPresetRequest = ColorPresetRequest {
            request: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ColorPresetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ColorPresetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ColorPresetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorPresetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ColorPresetRequest`
pub mod color_preset_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.ColorPresetRequest.request)
    pub enum Request {
        // @@protoc_insertion_point(oneof_field:iterm2.ColorPresetRequest.list_presets)
        ListPresets(ListPresets),
        // @@protoc_insertion_point(oneof_field:iterm2.ColorPresetRequest.get_preset)
        GetPreset(GetPreset),
    }

    impl ::protobuf::Oneof for Request {
    }

    impl ::protobuf::OneofFull for Request {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ColorPresetRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("request").unwrap()).clone()
        }
    }

    impl Request {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Request>("request")
        }
    }
    // @@protoc_insertion_point(message:iterm2.ColorPresetRequest.ListPresets)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ListPresets {
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.ColorPresetRequest.ListPresets.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ListPresets {
        fn default() -> &'a ListPresets {
            <ListPresets as ::protobuf::Message>::default_instance()
        }
    }

    impl ListPresets {
        pub fn new() -> ListPresets {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListPresets>(
                "ColorPresetRequest.ListPresets",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ListPresets {
        const NAME: &'static str = "ListPresets";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ListPresets {
            ListPresets::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ListPresets {
            static instance: ListPresets = ListPresets {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ListPresets {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ColorPresetRequest.ListPresets").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ListPresets {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ListPresets {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.ColorPresetRequest.GetPreset)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GetPreset {
        // message fields
        // @@protoc_insertion_point(field:iterm2.ColorPresetRequest.GetPreset.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.ColorPresetRequest.GetPreset.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GetPreset {
        fn default() -> &'a GetPreset {
            <GetPreset as ::protobuf::Message>::default_instance()
        }
    }

    impl GetPreset {
        pub fn new() -> GetPreset {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &GetPreset| { &m.name },
                |m: &mut GetPreset| { &mut m.name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetPreset>(
                "ColorPresetRequest.GetPreset",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GetPreset {
        const NAME: &'static str = "GetPreset";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GetPreset {
            GetPreset::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GetPreset {
            static instance: GetPreset = GetPreset {
                name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GetPreset {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ColorPresetRequest.GetPreset").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GetPreset {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GetPreset {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:iterm2.ColorPresetResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ColorPresetResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ColorPresetResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<color_preset_response::Status>>,
    // message oneof groups
    pub response: ::std::option::Option<color_preset_response::Response>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ColorPresetResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ColorPresetResponse {
    fn default() -> &'a ColorPresetResponse {
        <ColorPresetResponse as ::protobuf::Message>::default_instance()
    }
}

impl ColorPresetResponse {
    pub fn new() -> ColorPresetResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.ColorPresetResponse.ListPresets list_presets = 1;

    pub fn list_presets(&self) -> &color_preset_response::ListPresets {
        match self.response {
            ::std::option::Option::Some(color_preset_response::Response::ListPresets(ref v)) => v,
            _ => <color_preset_response::ListPresets as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_list_presets(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_list_presets(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(color_preset_response::Response::ListPresets(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_presets(&mut self, v: color_preset_response::ListPresets) {
        self.response = ::std::option::Option::Some(color_preset_response::Response::ListPresets(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_presets(&mut self) -> &mut color_preset_response::ListPresets {
        if let ::std::option::Option::Some(color_preset_response::Response::ListPresets(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(color_preset_response::Response::ListPresets(color_preset_response::ListPresets::new()));
        }
        match self.response {
            ::std::option::Option::Some(color_preset_response::Response::ListPresets(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_presets(&mut self) -> color_preset_response::ListPresets {
        if self.has_list_presets() {
            match self.response.take() {
                ::std::option::Option::Some(color_preset_response::Response::ListPresets(v)) => v,
                _ => panic!(),
            }
        } else {
            color_preset_response::ListPresets::new()
        }
    }

    // optional .iterm2.ColorPresetResponse.GetPreset get_preset = 2;

    pub fn get_preset(&self) -> &color_preset_response::GetPreset {
        match self.response {
            ::std::option::Option::Some(color_preset_response::Response::GetPreset(ref v)) => v,
            _ => <color_preset_response::GetPreset as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_get_preset(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_get_preset(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(color_preset_response::Response::GetPreset(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_preset(&mut self, v: color_preset_response::GetPreset) {
        self.response = ::std::option::Option::Some(color_preset_response::Response::GetPreset(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_preset(&mut self) -> &mut color_preset_response::GetPreset {
        if let ::std::option::Option::Some(color_preset_response::Response::GetPreset(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(color_preset_response::Response::GetPreset(color_preset_response::GetPreset::new()));
        }
        match self.response {
            ::std::option::Option::Some(color_preset_response::Response::GetPreset(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_preset(&mut self) -> color_preset_response::GetPreset {
        if self.has_get_preset() {
            match self.response.take() {
                ::std::option::Option::Some(color_preset_response::Response::GetPreset(v)) => v,
                _ => panic!(),
            }
        } else {
            color_preset_response::GetPreset::new()
        }
    }

    // optional .iterm2.ColorPresetResponse.Status status = 3;

    pub fn status(&self) -> color_preset_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(color_preset_response::Status::OK),
            None => color_preset_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: color_preset_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, color_preset_response::ListPresets>(
            "list_presets",
            ColorPresetResponse::has_list_presets,
            ColorPresetResponse::list_presets,
            ColorPresetResponse::mut_list_presets,
            ColorPresetResponse::set_list_presets,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, color_preset_response::GetPreset>(
            "get_preset",
            ColorPresetResponse::has_get_preset,
            ColorPresetResponse::get_preset,
            ColorPresetResponse::mut_get_preset,
            ColorPresetResponse::set_get_preset,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &ColorPresetResponse| { &m.status },
            |m: &mut ColorPresetResponse| { &mut m.status },
        ));
        oneofs.push(color_preset_response::Response::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ColorPresetResponse>(
            "ColorPresetResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ColorPresetResponse {
    const NAME: &'static str = "ColorPresetResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.response = ::std::option::Option::Some(color_preset_response::Response::ListPresets(is.read_message()?));
                },
                18 => {
                    self.response = ::std::option::Option::Some(color_preset_response::Response::GetPreset(is.read_message()?));
                },
                24 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &color_preset_response::Response::ListPresets(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &color_preset_response::Response::GetPreset(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &color_preset_response::Response::ListPresets(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &color_preset_response::Response::GetPreset(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ColorPresetResponse {
        ColorPresetResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ColorPresetResponse {
        static instance: ColorPresetResponse = ColorPresetResponse {
            status: ::std::option::Option::None,
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ColorPresetResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ColorPresetResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ColorPresetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorPresetResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ColorPresetResponse`
pub mod color_preset_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.ColorPresetResponse.response)
    pub enum Response {
        // @@protoc_insertion_point(oneof_field:iterm2.ColorPresetResponse.list_presets)
        ListPresets(ListPresets),
        // @@protoc_insertion_point(oneof_field:iterm2.ColorPresetResponse.get_preset)
        GetPreset(GetPreset),
    }

    impl ::protobuf::Oneof for Response {
    }

    impl ::protobuf::OneofFull for Response {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ColorPresetResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("response").unwrap()).clone()
        }
    }

    impl Response {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Response>("response")
        }
    }
    // @@protoc_insertion_point(message:iterm2.ColorPresetResponse.ListPresets)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ListPresets {
        // message fields
        // @@protoc_insertion_point(field:iterm2.ColorPresetResponse.ListPresets.name)
        pub name: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.ColorPresetResponse.ListPresets.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ListPresets {
        fn default() -> &'a ListPresets {
            <ListPresets as ::protobuf::Message>::default_instance()
        }
    }

    impl ListPresets {
        pub fn new() -> ListPresets {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "name",
                |m: &ListPresets| { &m.name },
                |m: &mut ListPresets| { &mut m.name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListPresets>(
                "ColorPresetResponse.ListPresets",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ListPresets {
        const NAME: &'static str = "ListPresets";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.name {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.name {
                os.write_string(1, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ListPresets {
            ListPresets::new()
        }

        fn clear(&mut self) {
            self.name.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ListPresets {
            static instance: ListPresets = ListPresets {
                name: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ListPresets {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ColorPresetResponse.ListPresets").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ListPresets {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ListPresets {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.ColorPresetResponse.GetPreset)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GetPreset {
        // message fields
        // @@protoc_insertion_point(field:iterm2.ColorPresetResponse.GetPreset.color_settings)
        pub color_settings: ::std::vec::Vec<get_preset::ColorSetting>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.ColorPresetResponse.GetPreset.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GetPreset {
        fn default() -> &'a GetPreset {
            <GetPreset as ::protobuf::Message>::default_instance()
        }
    }

    impl GetPreset {
        pub fn new() -> GetPreset {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "color_settings",
                |m: &GetPreset| { &m.color_settings },
                |m: &mut GetPreset| { &mut m.color_settings },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetPreset>(
                "ColorPresetResponse.GetPreset",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GetPreset {
        const NAME: &'static str = "GetPreset";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.color_settings.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.color_settings {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.color_settings {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GetPreset {
            GetPreset::new()
        }

        fn clear(&mut self) {
            self.color_settings.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GetPreset {
            static instance: GetPreset = GetPreset {
                color_settings: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GetPreset {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ColorPresetResponse.GetPreset").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GetPreset {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GetPreset {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `GetPreset`
    pub mod get_preset {
        // @@protoc_insertion_point(message:iterm2.ColorPresetResponse.GetPreset.ColorSetting)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ColorSetting {
            // message fields
            // @@protoc_insertion_point(field:iterm2.ColorPresetResponse.GetPreset.ColorSetting.red)
            pub red: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:iterm2.ColorPresetResponse.GetPreset.ColorSetting.green)
            pub green: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:iterm2.ColorPresetResponse.GetPreset.ColorSetting.blue)
            pub blue: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:iterm2.ColorPresetResponse.GetPreset.ColorSetting.alpha)
            pub alpha: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:iterm2.ColorPresetResponse.GetPreset.ColorSetting.color_space)
            pub color_space: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:iterm2.ColorPresetResponse.GetPreset.ColorSetting.key)
            pub key: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:iterm2.ColorPresetResponse.GetPreset.ColorSetting.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ColorSetting {
            fn default() -> &'a ColorSetting {
                <ColorSetting as ::protobuf::Message>::default_instance()
            }
        }

        impl ColorSetting {
            pub fn new() -> ColorSetting {
                ::std::default::Default::default()
            }

            // optional float red = 1;

            pub fn red(&self) -> f32 {
                self.red.unwrap_or(0.)
            }

            pub fn clear_red(&mut self) {
                self.red = ::std::option::Option::None;
            }

            pub fn has_red(&self) -> bool {
                self.red.is_some()
            }

            // Param is passed by value, moved
            pub fn set_red(&mut self, v: f32) {
                self.red = ::std::option::Option::Some(v);
            }

            // optional float green = 2;

            pub fn green(&self) -> f32 {
                self.green.unwrap_or(0.)
            }

            pub fn clear_green(&mut self) {
                self.green = ::std::option::Option::None;
            }

            pub fn has_green(&self) -> bool {
                self.green.is_some()
            }

            // Param is passed by value, moved
            pub fn set_green(&mut self, v: f32) {
                self.green = ::std::option::Option::Some(v);
            }

            // optional float blue = 3;

            pub fn blue(&self) -> f32 {
                self.blue.unwrap_or(0.)
            }

            pub fn clear_blue(&mut self) {
                self.blue = ::std::option::Option::None;
            }

            pub fn has_blue(&self) -> bool {
                self.blue.is_some()
            }

            // Param is passed by value, moved
            pub fn set_blue(&mut self, v: f32) {
                self.blue = ::std::option::Option::Some(v);
            }

            // optional float alpha = 4;

            pub fn alpha(&self) -> f32 {
                self.alpha.unwrap_or(0.)
            }

            pub fn clear_alpha(&mut self) {
                self.alpha = ::std::option::Option::None;
            }

            pub fn has_alpha(&self) -> bool {
                self.alpha.is_some()
            }

            // Param is passed by value, moved
            pub fn set_alpha(&mut self, v: f32) {
                self.alpha = ::std::option::Option::Some(v);
            }

            // optional string color_space = 5;

            pub fn color_space(&self) -> &str {
                match self.color_space.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_color_space(&mut self) {
                self.color_space = ::std::option::Option::None;
            }

            pub fn has_color_space(&self) -> bool {
                self.color_space.is_some()
            }

            // Param is passed by value, moved
            pub fn set_color_space(&mut self, v: ::std::string::String) {
                self.color_space = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_color_space(&mut self) -> &mut ::std::string::String {
                if self.color_space.is_none() {
                    self.color_space = ::std::option::Option::Some(::std::string::String::new());
                }
                self.color_space.as_mut().unwrap()
            }

            // Take field
            pub fn take_color_space(&mut self) -> ::std::string::String {
                self.color_space.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string key = 6;

            pub fn key(&self) -> &str {
                match self.key.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_key(&mut self) {
                self.key = ::std::option::Option::None;
            }

            pub fn has_key(&self) -> bool {
                self.key.is_some()
            }

            // Param is passed by value, moved
            pub fn set_key(&mut self, v: ::std::string::String) {
                self.key = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_key(&mut self) -> &mut ::std::string::String {
                if self.key.is_none() {
                    self.key = ::std::option::Option::Some(::std::string::String::new());
                }
                self.key.as_mut().unwrap()
            }

            // Take field
            pub fn take_key(&mut self) -> ::std::string::String {
                self.key.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(6);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "red",
                    |m: &ColorSetting| { &m.red },
                    |m: &mut ColorSetting| { &mut m.red },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "green",
                    |m: &ColorSetting| { &m.green },
                    |m: &mut ColorSetting| { &mut m.green },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "blue",
                    |m: &ColorSetting| { &m.blue },
                    |m: &mut ColorSetting| { &mut m.blue },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "alpha",
                    |m: &ColorSetting| { &m.alpha },
                    |m: &mut ColorSetting| { &mut m.alpha },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "color_space",
                    |m: &ColorSetting| { &m.color_space },
                    |m: &mut ColorSetting| { &mut m.color_space },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "key",
                    |m: &ColorSetting| { &m.key },
                    |m: &mut ColorSetting| { &mut m.key },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ColorSetting>(
                    "ColorPresetResponse.GetPreset.ColorSetting",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ColorSetting {
            const NAME: &'static str = "ColorSetting";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        13 => {
                            self.red = ::std::option::Option::Some(is.read_float()?);
                        },
                        21 => {
                            self.green = ::std::option::Option::Some(is.read_float()?);
                        },
                        29 => {
                            self.blue = ::std::option::Option::Some(is.read_float()?);
                        },
                        37 => {
                            self.alpha = ::std::option::Option::Some(is.read_float()?);
                        },
                        42 => {
                            self.color_space = ::std::option::Option::Some(is.read_string()?);
                        },
                        50 => {
                            self.key = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.red {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.green {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.blue {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.alpha {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.color_space.as_ref() {
                    my_size += ::protobuf::rt::string_size(5, &v);
                }
                if let Some(v) = self.key.as_ref() {
                    my_size += ::protobuf::rt::string_size(6, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.red {
                    os.write_float(1, v)?;
                }
                if let Some(v) = self.green {
                    os.write_float(2, v)?;
                }
                if let Some(v) = self.blue {
                    os.write_float(3, v)?;
                }
                if let Some(v) = self.alpha {
                    os.write_float(4, v)?;
                }
                if let Some(v) = self.color_space.as_ref() {
                    os.write_string(5, v)?;
                }
                if let Some(v) = self.key.as_ref() {
                    os.write_string(6, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ColorSetting {
                ColorSetting::new()
            }

            fn clear(&mut self) {
                self.red = ::std::option::Option::None;
                self.green = ::std::option::Option::None;
                self.blue = ::std::option::Option::None;
                self.alpha = ::std::option::Option::None;
                self.color_space = ::std::option::Option::None;
                self.key = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ColorSetting {
                static instance: ColorSetting = ColorSetting {
                    red: ::std::option::Option::None,
                    green: ::std::option::Option::None,
                    blue: ::std::option::Option::None,
                    alpha: ::std::option::Option::None,
                    color_space: ::std::option::Option::None,
                    key: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ColorSetting {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("ColorPresetResponse.GetPreset.ColorSetting").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ColorSetting {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ColorSetting {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.ColorPresetResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.ColorPresetResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.ColorPresetResponse.Status.PRESET_NOT_FOUND)
        PRESET_NOT_FOUND = 1,
        // @@protoc_insertion_point(enum_value:iterm2.ColorPresetResponse.Status.REQUEST_MALFORMED)
        REQUEST_MALFORMED = 2,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::PRESET_NOT_FOUND),
                2 => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "PRESET_NOT_FOUND" => ::std::option::Option::Some(Status::PRESET_NOT_FOUND),
                "REQUEST_MALFORMED" => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::PRESET_NOT_FOUND,
            Status::REQUEST_MALFORMED,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ColorPresetResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("ColorPresetResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.PreferencesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PreferencesRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.PreferencesRequest.requests)
    pub requests: ::std::vec::Vec<preferences_request::Request>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.PreferencesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PreferencesRequest {
    fn default() -> &'a PreferencesRequest {
        <PreferencesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PreferencesRequest {
    pub fn new() -> PreferencesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requests",
            |m: &PreferencesRequest| { &m.requests },
            |m: &mut PreferencesRequest| { &mut m.requests },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PreferencesRequest>(
            "PreferencesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PreferencesRequest {
    const NAME: &'static str = "PreferencesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.requests.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.requests {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PreferencesRequest {
        PreferencesRequest::new()
    }

    fn clear(&mut self) {
        self.requests.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PreferencesRequest {
        static instance: PreferencesRequest = PreferencesRequest {
            requests: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PreferencesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PreferencesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PreferencesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreferencesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PreferencesRequest`
pub mod preferences_request {
    // @@protoc_insertion_point(message:iterm2.PreferencesRequest.Request)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Request {
        // message oneof groups
        pub request: ::std::option::Option<request::Request>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.PreferencesRequest.Request.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Request {
        fn default() -> &'a Request {
            <Request as ::protobuf::Message>::default_instance()
        }
    }

    impl Request {
        pub fn new() -> Request {
            ::std::default::Default::default()
        }

        // optional .iterm2.PreferencesRequest.Request.SetPreference set_preference_request = 1;

        pub fn set_preference_request(&self) -> &request::SetPreference {
            match self.request {
                ::std::option::Option::Some(request::Request::SetPreferenceRequest(ref v)) => v,
                _ => <request::SetPreference as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_set_preference_request(&mut self) {
            self.request = ::std::option::Option::None;
        }

        pub fn has_set_preference_request(&self) -> bool {
            match self.request {
                ::std::option::Option::Some(request::Request::SetPreferenceRequest(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_set_preference_request(&mut self, v: request::SetPreference) {
            self.request = ::std::option::Option::Some(request::Request::SetPreferenceRequest(v))
        }

        // Mutable pointer to the field.
        pub fn mut_set_preference_request(&mut self) -> &mut request::SetPreference {
            if let ::std::option::Option::Some(request::Request::SetPreferenceRequest(_)) = self.request {
            } else {
                self.request = ::std::option::Option::Some(request::Request::SetPreferenceRequest(request::SetPreference::new()));
            }
            match self.request {
                ::std::option::Option::Some(request::Request::SetPreferenceRequest(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_set_preference_request(&mut self) -> request::SetPreference {
            if self.has_set_preference_request() {
                match self.request.take() {
                    ::std::option::Option::Some(request::Request::SetPreferenceRequest(v)) => v,
                    _ => panic!(),
                }
            } else {
                request::SetPreference::new()
            }
        }

        // optional .iterm2.PreferencesRequest.Request.GetPreference get_preference_request = 2;

        pub fn get_preference_request(&self) -> &request::GetPreference {
            match self.request {
                ::std::option::Option::Some(request::Request::GetPreferenceRequest(ref v)) => v,
                _ => <request::GetPreference as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_get_preference_request(&mut self) {
            self.request = ::std::option::Option::None;
        }

        pub fn has_get_preference_request(&self) -> bool {
            match self.request {
                ::std::option::Option::Some(request::Request::GetPreferenceRequest(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_get_preference_request(&mut self, v: request::GetPreference) {
            self.request = ::std::option::Option::Some(request::Request::GetPreferenceRequest(v))
        }

        // Mutable pointer to the field.
        pub fn mut_get_preference_request(&mut self) -> &mut request::GetPreference {
            if let ::std::option::Option::Some(request::Request::GetPreferenceRequest(_)) = self.request {
            } else {
                self.request = ::std::option::Option::Some(request::Request::GetPreferenceRequest(request::GetPreference::new()));
            }
            match self.request {
                ::std::option::Option::Some(request::Request::GetPreferenceRequest(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_get_preference_request(&mut self) -> request::GetPreference {
            if self.has_get_preference_request() {
                match self.request.take() {
                    ::std::option::Option::Some(request::Request::GetPreferenceRequest(v)) => v,
                    _ => panic!(),
                }
            } else {
                request::GetPreference::new()
            }
        }

        // optional .iterm2.PreferencesRequest.Request.SetDefaultProfile set_default_profile_request = 3;

        pub fn set_default_profile_request(&self) -> &request::SetDefaultProfile {
            match self.request {
                ::std::option::Option::Some(request::Request::SetDefaultProfileRequest(ref v)) => v,
                _ => <request::SetDefaultProfile as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_set_default_profile_request(&mut self) {
            self.request = ::std::option::Option::None;
        }

        pub fn has_set_default_profile_request(&self) -> bool {
            match self.request {
                ::std::option::Option::Some(request::Request::SetDefaultProfileRequest(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_set_default_profile_request(&mut self, v: request::SetDefaultProfile) {
            self.request = ::std::option::Option::Some(request::Request::SetDefaultProfileRequest(v))
        }

        // Mutable pointer to the field.
        pub fn mut_set_default_profile_request(&mut self) -> &mut request::SetDefaultProfile {
            if let ::std::option::Option::Some(request::Request::SetDefaultProfileRequest(_)) = self.request {
            } else {
                self.request = ::std::option::Option::Some(request::Request::SetDefaultProfileRequest(request::SetDefaultProfile::new()));
            }
            match self.request {
                ::std::option::Option::Some(request::Request::SetDefaultProfileRequest(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_set_default_profile_request(&mut self) -> request::SetDefaultProfile {
            if self.has_set_default_profile_request() {
                match self.request.take() {
                    ::std::option::Option::Some(request::Request::SetDefaultProfileRequest(v)) => v,
                    _ => panic!(),
                }
            } else {
                request::SetDefaultProfile::new()
            }
        }

        // optional .iterm2.PreferencesRequest.Request.GetDefaultProfile get_default_profile_request = 4;

        pub fn get_default_profile_request(&self) -> &request::GetDefaultProfile {
            match self.request {
                ::std::option::Option::Some(request::Request::GetDefaultProfileRequest(ref v)) => v,
                _ => <request::GetDefaultProfile as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_get_default_profile_request(&mut self) {
            self.request = ::std::option::Option::None;
        }

        pub fn has_get_default_profile_request(&self) -> bool {
            match self.request {
                ::std::option::Option::Some(request::Request::GetDefaultProfileRequest(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_get_default_profile_request(&mut self, v: request::GetDefaultProfile) {
            self.request = ::std::option::Option::Some(request::Request::GetDefaultProfileRequest(v))
        }

        // Mutable pointer to the field.
        pub fn mut_get_default_profile_request(&mut self) -> &mut request::GetDefaultProfile {
            if let ::std::option::Option::Some(request::Request::GetDefaultProfileRequest(_)) = self.request {
            } else {
                self.request = ::std::option::Option::Some(request::Request::GetDefaultProfileRequest(request::GetDefaultProfile::new()));
            }
            match self.request {
                ::std::option::Option::Some(request::Request::GetDefaultProfileRequest(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_get_default_profile_request(&mut self) -> request::GetDefaultProfile {
            if self.has_get_default_profile_request() {
                match self.request.take() {
                    ::std::option::Option::Some(request::Request::GetDefaultProfileRequest(v)) => v,
                    _ => panic!(),
                }
            } else {
                request::GetDefaultProfile::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, request::SetPreference>(
                "set_preference_request",
                Request::has_set_preference_request,
                Request::set_preference_request,
                Request::mut_set_preference_request,
                Request::set_set_preference_request,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, request::GetPreference>(
                "get_preference_request",
                Request::has_get_preference_request,
                Request::get_preference_request,
                Request::mut_get_preference_request,
                Request::set_get_preference_request,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, request::SetDefaultProfile>(
                "set_default_profile_request",
                Request::has_set_default_profile_request,
                Request::set_default_profile_request,
                Request::mut_set_default_profile_request,
                Request::set_set_default_profile_request,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, request::GetDefaultProfile>(
                "get_default_profile_request",
                Request::has_get_default_profile_request,
                Request::get_default_profile_request,
                Request::mut_get_default_profile_request,
                Request::set_get_default_profile_request,
            ));
            oneofs.push(request::Request::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Request>(
                "PreferencesRequest.Request",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Request {
        const NAME: &'static str = "Request";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.request = ::std::option::Option::Some(request::Request::SetPreferenceRequest(is.read_message()?));
                    },
                    18 => {
                        self.request = ::std::option::Option::Some(request::Request::GetPreferenceRequest(is.read_message()?));
                    },
                    26 => {
                        self.request = ::std::option::Option::Some(request::Request::SetDefaultProfileRequest(is.read_message()?));
                    },
                    34 => {
                        self.request = ::std::option::Option::Some(request::Request::GetDefaultProfileRequest(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.request {
                match v {
                    &request::Request::SetPreferenceRequest(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &request::Request::GetPreferenceRequest(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &request::Request::SetDefaultProfileRequest(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &request::Request::GetDefaultProfileRequest(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.request {
                match v {
                    &request::Request::SetPreferenceRequest(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &request::Request::GetPreferenceRequest(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                    &request::Request::SetDefaultProfileRequest(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    },
                    &request::Request::GetDefaultProfileRequest(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Request {
            Request::new()
        }

        fn clear(&mut self) {
            self.request = ::std::option::Option::None;
            self.request = ::std::option::Option::None;
            self.request = ::std::option::Option::None;
            self.request = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Request {
            static instance: Request = Request {
                request: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Request {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PreferencesRequest.Request").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Request {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Request {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Request`
    pub mod request {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:iterm2.PreferencesRequest.Request.request)
        pub enum Request {
            // @@protoc_insertion_point(oneof_field:iterm2.PreferencesRequest.Request.set_preference_request)
            SetPreferenceRequest(SetPreference),
            // @@protoc_insertion_point(oneof_field:iterm2.PreferencesRequest.Request.get_preference_request)
            GetPreferenceRequest(GetPreference),
            // @@protoc_insertion_point(oneof_field:iterm2.PreferencesRequest.Request.set_default_profile_request)
            SetDefaultProfileRequest(SetDefaultProfile),
            // @@protoc_insertion_point(oneof_field:iterm2.PreferencesRequest.Request.get_default_profile_request)
            GetDefaultProfileRequest(GetDefaultProfile),
        }

        impl ::protobuf::Oneof for Request {
        }

        impl ::protobuf::OneofFull for Request {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Request as ::protobuf::MessageFull>::descriptor().oneof_by_name("request").unwrap()).clone()
            }
        }

        impl Request {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Request>("request")
            }
        }
        // @@protoc_insertion_point(message:iterm2.PreferencesRequest.Request.SetPreference)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SetPreference {
            // message fields
            // @@protoc_insertion_point(field:iterm2.PreferencesRequest.Request.SetPreference.key)
            pub key: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:iterm2.PreferencesRequest.Request.SetPreference.json_value)
            pub json_value: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:iterm2.PreferencesRequest.Request.SetPreference.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SetPreference {
            fn default() -> &'a SetPreference {
                <SetPreference as ::protobuf::Message>::default_instance()
            }
        }

        impl SetPreference {
            pub fn new() -> SetPreference {
                ::std::default::Default::default()
            }

            // optional string key = 1;

            pub fn key(&self) -> &str {
                match self.key.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_key(&mut self) {
                self.key = ::std::option::Option::None;
            }

            pub fn has_key(&self) -> bool {
                self.key.is_some()
            }

            // Param is passed by value, moved
            pub fn set_key(&mut self, v: ::std::string::String) {
                self.key = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_key(&mut self) -> &mut ::std::string::String {
                if self.key.is_none() {
                    self.key = ::std::option::Option::Some(::std::string::String::new());
                }
                self.key.as_mut().unwrap()
            }

            // Take field
            pub fn take_key(&mut self) -> ::std::string::String {
                self.key.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string json_value = 2;

            pub fn json_value(&self) -> &str {
                match self.json_value.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_json_value(&mut self) {
                self.json_value = ::std::option::Option::None;
            }

            pub fn has_json_value(&self) -> bool {
                self.json_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_json_value(&mut self, v: ::std::string::String) {
                self.json_value = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_json_value(&mut self) -> &mut ::std::string::String {
                if self.json_value.is_none() {
                    self.json_value = ::std::option::Option::Some(::std::string::String::new());
                }
                self.json_value.as_mut().unwrap()
            }

            // Take field
            pub fn take_json_value(&mut self) -> ::std::string::String {
                self.json_value.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "key",
                    |m: &SetPreference| { &m.key },
                    |m: &mut SetPreference| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "json_value",
                    |m: &SetPreference| { &m.json_value },
                    |m: &mut SetPreference| { &mut m.json_value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetPreference>(
                    "PreferencesRequest.Request.SetPreference",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SetPreference {
            const NAME: &'static str = "SetPreference";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.key = ::std::option::Option::Some(is.read_string()?);
                        },
                        18 => {
                            self.json_value = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.key.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.json_value.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.key.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.json_value.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SetPreference {
                SetPreference::new()
            }

            fn clear(&mut self) {
                self.key = ::std::option::Option::None;
                self.json_value = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SetPreference {
                static instance: SetPreference = SetPreference {
                    key: ::std::option::Option::None,
                    json_value: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SetPreference {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("PreferencesRequest.Request.SetPreference").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SetPreference {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SetPreference {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:iterm2.PreferencesRequest.Request.GetPreference)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct GetPreference {
            // message fields
            // @@protoc_insertion_point(field:iterm2.PreferencesRequest.Request.GetPreference.key)
            pub key: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:iterm2.PreferencesRequest.Request.GetPreference.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a GetPreference {
            fn default() -> &'a GetPreference {
                <GetPreference as ::protobuf::Message>::default_instance()
            }
        }

        impl GetPreference {
            pub fn new() -> GetPreference {
                ::std::default::Default::default()
            }

            // optional string key = 1;

            pub fn key(&self) -> &str {
                match self.key.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_key(&mut self) {
                self.key = ::std::option::Option::None;
            }

            pub fn has_key(&self) -> bool {
                self.key.is_some()
            }

            // Param is passed by value, moved
            pub fn set_key(&mut self, v: ::std::string::String) {
                self.key = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_key(&mut self) -> &mut ::std::string::String {
                if self.key.is_none() {
                    self.key = ::std::option::Option::Some(::std::string::String::new());
                }
                self.key.as_mut().unwrap()
            }

            // Take field
            pub fn take_key(&mut self) -> ::std::string::String {
                self.key.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "key",
                    |m: &GetPreference| { &m.key },
                    |m: &mut GetPreference| { &mut m.key },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetPreference>(
                    "PreferencesRequest.Request.GetPreference",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for GetPreference {
            const NAME: &'static str = "GetPreference";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.key = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.key.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.key.as_ref() {
                    os.write_string(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> GetPreference {
                GetPreference::new()
            }

            fn clear(&mut self) {
                self.key = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static GetPreference {
                static instance: GetPreference = GetPreference {
                    key: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for GetPreference {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("PreferencesRequest.Request.GetPreference").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for GetPreference {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for GetPreference {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:iterm2.PreferencesRequest.Request.SetDefaultProfile)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SetDefaultProfile {
            // message fields
            // @@protoc_insertion_point(field:iterm2.PreferencesRequest.Request.SetDefaultProfile.guid)
            pub guid: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:iterm2.PreferencesRequest.Request.SetDefaultProfile.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SetDefaultProfile {
            fn default() -> &'a SetDefaultProfile {
                <SetDefaultProfile as ::protobuf::Message>::default_instance()
            }
        }

        impl SetDefaultProfile {
            pub fn new() -> SetDefaultProfile {
                ::std::default::Default::default()
            }

            // optional string guid = 1;

            pub fn guid(&self) -> &str {
                match self.guid.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_guid(&mut self) {
                self.guid = ::std::option::Option::None;
            }

            pub fn has_guid(&self) -> bool {
                self.guid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_guid(&mut self, v: ::std::string::String) {
                self.guid = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_guid(&mut self) -> &mut ::std::string::String {
                if self.guid.is_none() {
                    self.guid = ::std::option::Option::Some(::std::string::String::new());
                }
                self.guid.as_mut().unwrap()
            }

            // Take field
            pub fn take_guid(&mut self) -> ::std::string::String {
                self.guid.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "guid",
                    |m: &SetDefaultProfile| { &m.guid },
                    |m: &mut SetDefaultProfile| { &mut m.guid },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetDefaultProfile>(
                    "PreferencesRequest.Request.SetDefaultProfile",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SetDefaultProfile {
            const NAME: &'static str = "SetDefaultProfile";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.guid = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.guid.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.guid.as_ref() {
                    os.write_string(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SetDefaultProfile {
                SetDefaultProfile::new()
            }

            fn clear(&mut self) {
                self.guid = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SetDefaultProfile {
                static instance: SetDefaultProfile = SetDefaultProfile {
                    guid: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SetDefaultProfile {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("PreferencesRequest.Request.SetDefaultProfile").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SetDefaultProfile {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SetDefaultProfile {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:iterm2.PreferencesRequest.Request.GetDefaultProfile)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct GetDefaultProfile {
            // special fields
            // @@protoc_insertion_point(special_field:iterm2.PreferencesRequest.Request.GetDefaultProfile.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a GetDefaultProfile {
            fn default() -> &'a GetDefaultProfile {
                <GetDefaultProfile as ::protobuf::Message>::default_instance()
            }
        }

        impl GetDefaultProfile {
            pub fn new() -> GetDefaultProfile {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(0);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetDefaultProfile>(
                    "PreferencesRequest.Request.GetDefaultProfile",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for GetDefaultProfile {
            const NAME: &'static str = "GetDefaultProfile";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> GetDefaultProfile {
                GetDefaultProfile::new()
            }

            fn clear(&mut self) {
                self.special_fields.clear();
            }

            fn default_instance() -> &'static GetDefaultProfile {
                static instance: GetDefaultProfile = GetDefaultProfile {
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for GetDefaultProfile {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("PreferencesRequest.Request.GetDefaultProfile").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for GetDefaultProfile {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for GetDefaultProfile {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:iterm2.PreferencesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PreferencesResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.PreferencesResponse.results)
    pub results: ::std::vec::Vec<preferences_response::Result>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.PreferencesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PreferencesResponse {
    fn default() -> &'a PreferencesResponse {
        <PreferencesResponse as ::protobuf::Message>::default_instance()
    }
}

impl PreferencesResponse {
    pub fn new() -> PreferencesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &PreferencesResponse| { &m.results },
            |m: &mut PreferencesResponse| { &mut m.results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PreferencesResponse>(
            "PreferencesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PreferencesResponse {
    const NAME: &'static str = "PreferencesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PreferencesResponse {
        PreferencesResponse::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PreferencesResponse {
        static instance: PreferencesResponse = PreferencesResponse {
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PreferencesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PreferencesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PreferencesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreferencesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PreferencesResponse`
pub mod preferences_response {
    // @@protoc_insertion_point(message:iterm2.PreferencesResponse.Result)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Result {
        // message oneof groups
        pub result: ::std::option::Option<result::Result>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.PreferencesResponse.Result.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Result {
        fn default() -> &'a Result {
            <Result as ::protobuf::Message>::default_instance()
        }
    }

    impl Result {
        pub fn new() -> Result {
            ::std::default::Default::default()
        }

        // optional .iterm2.PreferencesResponse.Result.UnrecognizedResult unrecognized_request = 1;

        pub fn unrecognized_request(&self) -> &result::UnrecognizedResult {
            match self.result {
                ::std::option::Option::Some(result::Result::UnrecognizedRequest(ref v)) => v,
                _ => <result::UnrecognizedResult as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_unrecognized_request(&mut self) {
            self.result = ::std::option::Option::None;
        }

        pub fn has_unrecognized_request(&self) -> bool {
            match self.result {
                ::std::option::Option::Some(result::Result::UnrecognizedRequest(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_unrecognized_request(&mut self, v: result::UnrecognizedResult) {
            self.result = ::std::option::Option::Some(result::Result::UnrecognizedRequest(v))
        }

        // Mutable pointer to the field.
        pub fn mut_unrecognized_request(&mut self) -> &mut result::UnrecognizedResult {
            if let ::std::option::Option::Some(result::Result::UnrecognizedRequest(_)) = self.result {
            } else {
                self.result = ::std::option::Option::Some(result::Result::UnrecognizedRequest(result::UnrecognizedResult::new()));
            }
            match self.result {
                ::std::option::Option::Some(result::Result::UnrecognizedRequest(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_unrecognized_request(&mut self) -> result::UnrecognizedResult {
            if self.has_unrecognized_request() {
                match self.result.take() {
                    ::std::option::Option::Some(result::Result::UnrecognizedRequest(v)) => v,
                    _ => panic!(),
                }
            } else {
                result::UnrecognizedResult::new()
            }
        }

        // optional .iterm2.PreferencesResponse.Result.SetPreferenceResult set_preference_result = 2;

        pub fn set_preference_result(&self) -> &result::SetPreferenceResult {
            match self.result {
                ::std::option::Option::Some(result::Result::SetPreferenceResult(ref v)) => v,
                _ => <result::SetPreferenceResult as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_set_preference_result(&mut self) {
            self.result = ::std::option::Option::None;
        }

        pub fn has_set_preference_result(&self) -> bool {
            match self.result {
                ::std::option::Option::Some(result::Result::SetPreferenceResult(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_set_preference_result(&mut self, v: result::SetPreferenceResult) {
            self.result = ::std::option::Option::Some(result::Result::SetPreferenceResult(v))
        }

        // Mutable pointer to the field.
        pub fn mut_set_preference_result(&mut self) -> &mut result::SetPreferenceResult {
            if let ::std::option::Option::Some(result::Result::SetPreferenceResult(_)) = self.result {
            } else {
                self.result = ::std::option::Option::Some(result::Result::SetPreferenceResult(result::SetPreferenceResult::new()));
            }
            match self.result {
                ::std::option::Option::Some(result::Result::SetPreferenceResult(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_set_preference_result(&mut self) -> result::SetPreferenceResult {
            if self.has_set_preference_result() {
                match self.result.take() {
                    ::std::option::Option::Some(result::Result::SetPreferenceResult(v)) => v,
                    _ => panic!(),
                }
            } else {
                result::SetPreferenceResult::new()
            }
        }

        // optional .iterm2.PreferencesResponse.Result.GetPreferenceResult get_preference_result = 3;

        pub fn get_preference_result(&self) -> &result::GetPreferenceResult {
            match self.result {
                ::std::option::Option::Some(result::Result::GetPreferenceResult(ref v)) => v,
                _ => <result::GetPreferenceResult as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_get_preference_result(&mut self) {
            self.result = ::std::option::Option::None;
        }

        pub fn has_get_preference_result(&self) -> bool {
            match self.result {
                ::std::option::Option::Some(result::Result::GetPreferenceResult(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_get_preference_result(&mut self, v: result::GetPreferenceResult) {
            self.result = ::std::option::Option::Some(result::Result::GetPreferenceResult(v))
        }

        // Mutable pointer to the field.
        pub fn mut_get_preference_result(&mut self) -> &mut result::GetPreferenceResult {
            if let ::std::option::Option::Some(result::Result::GetPreferenceResult(_)) = self.result {
            } else {
                self.result = ::std::option::Option::Some(result::Result::GetPreferenceResult(result::GetPreferenceResult::new()));
            }
            match self.result {
                ::std::option::Option::Some(result::Result::GetPreferenceResult(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_get_preference_result(&mut self) -> result::GetPreferenceResult {
            if self.has_get_preference_result() {
                match self.result.take() {
                    ::std::option::Option::Some(result::Result::GetPreferenceResult(v)) => v,
                    _ => panic!(),
                }
            } else {
                result::GetPreferenceResult::new()
            }
        }

        // optional .iterm2.PreferencesResponse.Result.SetDefaultProfileResult set_default_profile_result = 4;

        pub fn set_default_profile_result(&self) -> &result::SetDefaultProfileResult {
            match self.result {
                ::std::option::Option::Some(result::Result::SetDefaultProfileResult(ref v)) => v,
                _ => <result::SetDefaultProfileResult as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_set_default_profile_result(&mut self) {
            self.result = ::std::option::Option::None;
        }

        pub fn has_set_default_profile_result(&self) -> bool {
            match self.result {
                ::std::option::Option::Some(result::Result::SetDefaultProfileResult(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_set_default_profile_result(&mut self, v: result::SetDefaultProfileResult) {
            self.result = ::std::option::Option::Some(result::Result::SetDefaultProfileResult(v))
        }

        // Mutable pointer to the field.
        pub fn mut_set_default_profile_result(&mut self) -> &mut result::SetDefaultProfileResult {
            if let ::std::option::Option::Some(result::Result::SetDefaultProfileResult(_)) = self.result {
            } else {
                self.result = ::std::option::Option::Some(result::Result::SetDefaultProfileResult(result::SetDefaultProfileResult::new()));
            }
            match self.result {
                ::std::option::Option::Some(result::Result::SetDefaultProfileResult(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_set_default_profile_result(&mut self) -> result::SetDefaultProfileResult {
            if self.has_set_default_profile_result() {
                match self.result.take() {
                    ::std::option::Option::Some(result::Result::SetDefaultProfileResult(v)) => v,
                    _ => panic!(),
                }
            } else {
                result::SetDefaultProfileResult::new()
            }
        }

        // optional .iterm2.PreferencesResponse.Result.GetDefaultProfileResult get_default_profile_result = 5;

        pub fn get_default_profile_result(&self) -> &result::GetDefaultProfileResult {
            match self.result {
                ::std::option::Option::Some(result::Result::GetDefaultProfileResult(ref v)) => v,
                _ => <result::GetDefaultProfileResult as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_get_default_profile_result(&mut self) {
            self.result = ::std::option::Option::None;
        }

        pub fn has_get_default_profile_result(&self) -> bool {
            match self.result {
                ::std::option::Option::Some(result::Result::GetDefaultProfileResult(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_get_default_profile_result(&mut self, v: result::GetDefaultProfileResult) {
            self.result = ::std::option::Option::Some(result::Result::GetDefaultProfileResult(v))
        }

        // Mutable pointer to the field.
        pub fn mut_get_default_profile_result(&mut self) -> &mut result::GetDefaultProfileResult {
            if let ::std::option::Option::Some(result::Result::GetDefaultProfileResult(_)) = self.result {
            } else {
                self.result = ::std::option::Option::Some(result::Result::GetDefaultProfileResult(result::GetDefaultProfileResult::new()));
            }
            match self.result {
                ::std::option::Option::Some(result::Result::GetDefaultProfileResult(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_get_default_profile_result(&mut self) -> result::GetDefaultProfileResult {
            if self.has_get_default_profile_result() {
                match self.result.take() {
                    ::std::option::Option::Some(result::Result::GetDefaultProfileResult(v)) => v,
                    _ => panic!(),
                }
            } else {
                result::GetDefaultProfileResult::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, result::UnrecognizedResult>(
                "unrecognized_request",
                Result::has_unrecognized_request,
                Result::unrecognized_request,
                Result::mut_unrecognized_request,
                Result::set_unrecognized_request,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, result::SetPreferenceResult>(
                "set_preference_result",
                Result::has_set_preference_result,
                Result::set_preference_result,
                Result::mut_set_preference_result,
                Result::set_set_preference_result,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, result::GetPreferenceResult>(
                "get_preference_result",
                Result::has_get_preference_result,
                Result::get_preference_result,
                Result::mut_get_preference_result,
                Result::set_get_preference_result,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, result::SetDefaultProfileResult>(
                "set_default_profile_result",
                Result::has_set_default_profile_result,
                Result::set_default_profile_result,
                Result::mut_set_default_profile_result,
                Result::set_set_default_profile_result,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, result::GetDefaultProfileResult>(
                "get_default_profile_result",
                Result::has_get_default_profile_result,
                Result::get_default_profile_result,
                Result::mut_get_default_profile_result,
                Result::set_get_default_profile_result,
            ));
            oneofs.push(result::Result::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Result>(
                "PreferencesResponse.Result",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Result {
        const NAME: &'static str = "Result";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.result = ::std::option::Option::Some(result::Result::UnrecognizedRequest(is.read_message()?));
                    },
                    18 => {
                        self.result = ::std::option::Option::Some(result::Result::SetPreferenceResult(is.read_message()?));
                    },
                    26 => {
                        self.result = ::std::option::Option::Some(result::Result::GetPreferenceResult(is.read_message()?));
                    },
                    34 => {
                        self.result = ::std::option::Option::Some(result::Result::SetDefaultProfileResult(is.read_message()?));
                    },
                    42 => {
                        self.result = ::std::option::Option::Some(result::Result::GetDefaultProfileResult(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.result {
                match v {
                    &result::Result::UnrecognizedRequest(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &result::Result::SetPreferenceResult(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &result::Result::GetPreferenceResult(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &result::Result::SetDefaultProfileResult(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &result::Result::GetDefaultProfileResult(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.result {
                match v {
                    &result::Result::UnrecognizedRequest(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &result::Result::SetPreferenceResult(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                    &result::Result::GetPreferenceResult(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    },
                    &result::Result::SetDefaultProfileResult(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                    },
                    &result::Result::GetDefaultProfileResult(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Result {
            Result::new()
        }

        fn clear(&mut self) {
            self.result = ::std::option::Option::None;
            self.result = ::std::option::Option::None;
            self.result = ::std::option::Option::None;
            self.result = ::std::option::Option::None;
            self.result = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Result {
            static instance: Result = Result {
                result: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Result {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PreferencesResponse.Result").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Result {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Result {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Result`
    pub mod result {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:iterm2.PreferencesResponse.Result.result)
        pub enum Result {
            // @@protoc_insertion_point(oneof_field:iterm2.PreferencesResponse.Result.unrecognized_request)
            UnrecognizedRequest(UnrecognizedResult),
            // @@protoc_insertion_point(oneof_field:iterm2.PreferencesResponse.Result.set_preference_result)
            SetPreferenceResult(SetPreferenceResult),
            // @@protoc_insertion_point(oneof_field:iterm2.PreferencesResponse.Result.get_preference_result)
            GetPreferenceResult(GetPreferenceResult),
            // @@protoc_insertion_point(oneof_field:iterm2.PreferencesResponse.Result.set_default_profile_result)
            SetDefaultProfileResult(SetDefaultProfileResult),
            // @@protoc_insertion_point(oneof_field:iterm2.PreferencesResponse.Result.get_default_profile_result)
            GetDefaultProfileResult(GetDefaultProfileResult),
        }

        impl ::protobuf::Oneof for Result {
        }

        impl ::protobuf::OneofFull for Result {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Result as ::protobuf::MessageFull>::descriptor().oneof_by_name("result").unwrap()).clone()
            }
        }

        impl Result {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Result>("result")
            }
        }
        // @@protoc_insertion_point(message:iterm2.PreferencesResponse.Result.SetPreferenceResult)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SetPreferenceResult {
            // message fields
            // @@protoc_insertion_point(field:iterm2.PreferencesResponse.Result.SetPreferenceResult.status)
            pub status: ::std::option::Option<::protobuf::EnumOrUnknown<set_preference_result::Status>>,
            // special fields
            // @@protoc_insertion_point(special_field:iterm2.PreferencesResponse.Result.SetPreferenceResult.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SetPreferenceResult {
            fn default() -> &'a SetPreferenceResult {
                <SetPreferenceResult as ::protobuf::Message>::default_instance()
            }
        }

        impl SetPreferenceResult {
            pub fn new() -> SetPreferenceResult {
                ::std::default::Default::default()
            }

            // optional .iterm2.PreferencesResponse.Result.SetPreferenceResult.Status status = 1;

            pub fn status(&self) -> set_preference_result::Status {
                match self.status {
                    Some(e) => e.enum_value_or(set_preference_result::Status::OK),
                    None => set_preference_result::Status::OK,
                }
            }

            pub fn clear_status(&mut self) {
                self.status = ::std::option::Option::None;
            }

            pub fn has_status(&self) -> bool {
                self.status.is_some()
            }

            // Param is passed by value, moved
            pub fn set_status(&mut self, v: set_preference_result::Status) {
                self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "status",
                    |m: &SetPreferenceResult| { &m.status },
                    |m: &mut SetPreferenceResult| { &mut m.status },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetPreferenceResult>(
                    "PreferencesResponse.Result.SetPreferenceResult",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SetPreferenceResult {
            const NAME: &'static str = "SetPreferenceResult";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.status {
                    my_size += ::protobuf::rt::int32_size(1, v.value());
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.status {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SetPreferenceResult {
                SetPreferenceResult::new()
            }

            fn clear(&mut self) {
                self.status = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SetPreferenceResult {
                static instance: SetPreferenceResult = SetPreferenceResult {
                    status: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SetPreferenceResult {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("PreferencesResponse.Result.SetPreferenceResult").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SetPreferenceResult {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SetPreferenceResult {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `SetPreferenceResult`
        pub mod set_preference_result {
            #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
            // @@protoc_insertion_point(enum:iterm2.PreferencesResponse.Result.SetPreferenceResult.Status)
            pub enum Status {
                // @@protoc_insertion_point(enum_value:iterm2.PreferencesResponse.Result.SetPreferenceResult.Status.OK)
                OK = 0,
                // @@protoc_insertion_point(enum_value:iterm2.PreferencesResponse.Result.SetPreferenceResult.Status.BAD_JSON)
                BAD_JSON = 1,
                // @@protoc_insertion_point(enum_value:iterm2.PreferencesResponse.Result.SetPreferenceResult.Status.INVALID_VALUE)
                INVALID_VALUE = 2,
            }

            impl ::protobuf::Enum for Status {
                const NAME: &'static str = "Status";

                fn value(&self) -> i32 {
                    *self as i32
                }

                fn from_i32(value: i32) -> ::std::option::Option<Status> {
                    match value {
                        0 => ::std::option::Option::Some(Status::OK),
                        1 => ::std::option::Option::Some(Status::BAD_JSON),
                        2 => ::std::option::Option::Some(Status::INVALID_VALUE),
                        _ => ::std::option::Option::None
                    }
                }

                fn from_str(str: &str) -> ::std::option::Option<Status> {
                    match str {
                        "OK" => ::std::option::Option::Some(Status::OK),
                        "BAD_JSON" => ::std::option::Option::Some(Status::BAD_JSON),
                        "INVALID_VALUE" => ::std::option::Option::Some(Status::INVALID_VALUE),
                        _ => ::std::option::Option::None
                    }
                }

                const VALUES: &'static [Status] = &[
                    Status::OK,
                    Status::BAD_JSON,
                    Status::INVALID_VALUE,
                ];
            }

            impl ::protobuf::EnumFull for Status {
                fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().enum_by_package_relative_name("PreferencesResponse.Result.SetPreferenceResult.Status").unwrap()).clone()
                }

                fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                    let index = *self as usize;
                    Self::enum_descriptor().value_by_index(index)
                }
            }

            impl ::std::default::Default for Status {
                fn default() -> Self {
                    Status::OK
                }
            }

            impl Status {
                pub(in super::super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                    ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("PreferencesResponse.Result.SetPreferenceResult.Status")
                }
            }
        }

        // @@protoc_insertion_point(message:iterm2.PreferencesResponse.Result.GetPreferenceResult)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct GetPreferenceResult {
            // message fields
            // @@protoc_insertion_point(field:iterm2.PreferencesResponse.Result.GetPreferenceResult.json_value)
            pub json_value: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:iterm2.PreferencesResponse.Result.GetPreferenceResult.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a GetPreferenceResult {
            fn default() -> &'a GetPreferenceResult {
                <GetPreferenceResult as ::protobuf::Message>::default_instance()
            }
        }

        impl GetPreferenceResult {
            pub fn new() -> GetPreferenceResult {
                ::std::default::Default::default()
            }

            // optional string json_value = 1;

            pub fn json_value(&self) -> &str {
                match self.json_value.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_json_value(&mut self) {
                self.json_value = ::std::option::Option::None;
            }

            pub fn has_json_value(&self) -> bool {
                self.json_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_json_value(&mut self, v: ::std::string::String) {
                self.json_value = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_json_value(&mut self) -> &mut ::std::string::String {
                if self.json_value.is_none() {
                    self.json_value = ::std::option::Option::Some(::std::string::String::new());
                }
                self.json_value.as_mut().unwrap()
            }

            // Take field
            pub fn take_json_value(&mut self) -> ::std::string::String {
                self.json_value.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "json_value",
                    |m: &GetPreferenceResult| { &m.json_value },
                    |m: &mut GetPreferenceResult| { &mut m.json_value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetPreferenceResult>(
                    "PreferencesResponse.Result.GetPreferenceResult",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for GetPreferenceResult {
            const NAME: &'static str = "GetPreferenceResult";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.json_value = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.json_value.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.json_value.as_ref() {
                    os.write_string(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> GetPreferenceResult {
                GetPreferenceResult::new()
            }

            fn clear(&mut self) {
                self.json_value = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static GetPreferenceResult {
                static instance: GetPreferenceResult = GetPreferenceResult {
                    json_value: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for GetPreferenceResult {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("PreferencesResponse.Result.GetPreferenceResult").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for GetPreferenceResult {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for GetPreferenceResult {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:iterm2.PreferencesResponse.Result.SetDefaultProfileResult)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SetDefaultProfileResult {
            // message fields
            // @@protoc_insertion_point(field:iterm2.PreferencesResponse.Result.SetDefaultProfileResult.status)
            pub status: ::std::option::Option<::protobuf::EnumOrUnknown<set_default_profile_result::Status>>,
            // special fields
            // @@protoc_insertion_point(special_field:iterm2.PreferencesResponse.Result.SetDefaultProfileResult.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SetDefaultProfileResult {
            fn default() -> &'a SetDefaultProfileResult {
                <SetDefaultProfileResult as ::protobuf::Message>::default_instance()
            }
        }

        impl SetDefaultProfileResult {
            pub fn new() -> SetDefaultProfileResult {
                ::std::default::Default::default()
            }

            // optional .iterm2.PreferencesResponse.Result.SetDefaultProfileResult.Status status = 1;

            pub fn status(&self) -> set_default_profile_result::Status {
                match self.status {
                    Some(e) => e.enum_value_or(set_default_profile_result::Status::OK),
                    None => set_default_profile_result::Status::OK,
                }
            }

            pub fn clear_status(&mut self) {
                self.status = ::std::option::Option::None;
            }

            pub fn has_status(&self) -> bool {
                self.status.is_some()
            }

            // Param is passed by value, moved
            pub fn set_status(&mut self, v: set_default_profile_result::Status) {
                self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "status",
                    |m: &SetDefaultProfileResult| { &m.status },
                    |m: &mut SetDefaultProfileResult| { &mut m.status },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetDefaultProfileResult>(
                    "PreferencesResponse.Result.SetDefaultProfileResult",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SetDefaultProfileResult {
            const NAME: &'static str = "SetDefaultProfileResult";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.status {
                    my_size += ::protobuf::rt::int32_size(1, v.value());
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.status {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SetDefaultProfileResult {
                SetDefaultProfileResult::new()
            }

            fn clear(&mut self) {
                self.status = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SetDefaultProfileResult {
                static instance: SetDefaultProfileResult = SetDefaultProfileResult {
                    status: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SetDefaultProfileResult {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("PreferencesResponse.Result.SetDefaultProfileResult").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SetDefaultProfileResult {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SetDefaultProfileResult {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `SetDefaultProfileResult`
        pub mod set_default_profile_result {
            #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
            // @@protoc_insertion_point(enum:iterm2.PreferencesResponse.Result.SetDefaultProfileResult.Status)
            pub enum Status {
                // @@protoc_insertion_point(enum_value:iterm2.PreferencesResponse.Result.SetDefaultProfileResult.Status.OK)
                OK = 0,
                // @@protoc_insertion_point(enum_value:iterm2.PreferencesResponse.Result.SetDefaultProfileResult.Status.BAD_GUID)
                BAD_GUID = 1,
            }

            impl ::protobuf::Enum for Status {
                const NAME: &'static str = "Status";

                fn value(&self) -> i32 {
                    *self as i32
                }

                fn from_i32(value: i32) -> ::std::option::Option<Status> {
                    match value {
                        0 => ::std::option::Option::Some(Status::OK),
                        1 => ::std::option::Option::Some(Status::BAD_GUID),
                        _ => ::std::option::Option::None
                    }
                }

                fn from_str(str: &str) -> ::std::option::Option<Status> {
                    match str {
                        "OK" => ::std::option::Option::Some(Status::OK),
                        "BAD_GUID" => ::std::option::Option::Some(Status::BAD_GUID),
                        _ => ::std::option::Option::None
                    }
                }

                const VALUES: &'static [Status] = &[
                    Status::OK,
                    Status::BAD_GUID,
                ];
            }

            impl ::protobuf::EnumFull for Status {
                fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().enum_by_package_relative_name("PreferencesResponse.Result.SetDefaultProfileResult.Status").unwrap()).clone()
                }

                fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                    let index = *self as usize;
                    Self::enum_descriptor().value_by_index(index)
                }
            }

            impl ::std::default::Default for Status {
                fn default() -> Self {
                    Status::OK
                }
            }

            impl Status {
                pub(in super::super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                    ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("PreferencesResponse.Result.SetDefaultProfileResult.Status")
                }
            }
        }

        // @@protoc_insertion_point(message:iterm2.PreferencesResponse.Result.UnrecognizedResult)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct UnrecognizedResult {
            // special fields
            // @@protoc_insertion_point(special_field:iterm2.PreferencesResponse.Result.UnrecognizedResult.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a UnrecognizedResult {
            fn default() -> &'a UnrecognizedResult {
                <UnrecognizedResult as ::protobuf::Message>::default_instance()
            }
        }

        impl UnrecognizedResult {
            pub fn new() -> UnrecognizedResult {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(0);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnrecognizedResult>(
                    "PreferencesResponse.Result.UnrecognizedResult",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for UnrecognizedResult {
            const NAME: &'static str = "UnrecognizedResult";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> UnrecognizedResult {
                UnrecognizedResult::new()
            }

            fn clear(&mut self) {
                self.special_fields.clear();
            }

            fn default_instance() -> &'static UnrecognizedResult {
                static instance: UnrecognizedResult = UnrecognizedResult {
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for UnrecognizedResult {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("PreferencesResponse.Result.UnrecognizedResult").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for UnrecognizedResult {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for UnrecognizedResult {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:iterm2.PreferencesResponse.Result.GetDefaultProfileResult)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct GetDefaultProfileResult {
            // message fields
            // @@protoc_insertion_point(field:iterm2.PreferencesResponse.Result.GetDefaultProfileResult.guid)
            pub guid: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:iterm2.PreferencesResponse.Result.GetDefaultProfileResult.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a GetDefaultProfileResult {
            fn default() -> &'a GetDefaultProfileResult {
                <GetDefaultProfileResult as ::protobuf::Message>::default_instance()
            }
        }

        impl GetDefaultProfileResult {
            pub fn new() -> GetDefaultProfileResult {
                ::std::default::Default::default()
            }

            // optional string guid = 1;

            pub fn guid(&self) -> &str {
                match self.guid.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_guid(&mut self) {
                self.guid = ::std::option::Option::None;
            }

            pub fn has_guid(&self) -> bool {
                self.guid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_guid(&mut self, v: ::std::string::String) {
                self.guid = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_guid(&mut self) -> &mut ::std::string::String {
                if self.guid.is_none() {
                    self.guid = ::std::option::Option::Some(::std::string::String::new());
                }
                self.guid.as_mut().unwrap()
            }

            // Take field
            pub fn take_guid(&mut self) -> ::std::string::String {
                self.guid.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "guid",
                    |m: &GetDefaultProfileResult| { &m.guid },
                    |m: &mut GetDefaultProfileResult| { &mut m.guid },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetDefaultProfileResult>(
                    "PreferencesResponse.Result.GetDefaultProfileResult",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for GetDefaultProfileResult {
            const NAME: &'static str = "GetDefaultProfileResult";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.guid = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.guid.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.guid.as_ref() {
                    os.write_string(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> GetDefaultProfileResult {
                GetDefaultProfileResult::new()
            }

            fn clear(&mut self) {
                self.guid = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static GetDefaultProfileResult {
                static instance: GetDefaultProfileResult = GetDefaultProfileResult {
                    guid: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for GetDefaultProfileResult {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("PreferencesResponse.Result.GetDefaultProfileResult").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for GetDefaultProfileResult {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for GetDefaultProfileResult {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:iterm2.ReorderTabsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReorderTabsRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ReorderTabsRequest.assignments)
    pub assignments: ::std::vec::Vec<reorder_tabs_request::Assignment>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ReorderTabsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReorderTabsRequest {
    fn default() -> &'a ReorderTabsRequest {
        <ReorderTabsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReorderTabsRequest {
    pub fn new() -> ReorderTabsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "assignments",
            |m: &ReorderTabsRequest| { &m.assignments },
            |m: &mut ReorderTabsRequest| { &mut m.assignments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReorderTabsRequest>(
            "ReorderTabsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReorderTabsRequest {
    const NAME: &'static str = "ReorderTabsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.assignments.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.assignments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.assignments {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReorderTabsRequest {
        ReorderTabsRequest::new()
    }

    fn clear(&mut self) {
        self.assignments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReorderTabsRequest {
        static instance: ReorderTabsRequest = ReorderTabsRequest {
            assignments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReorderTabsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReorderTabsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReorderTabsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReorderTabsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ReorderTabsRequest`
pub mod reorder_tabs_request {
    // @@protoc_insertion_point(message:iterm2.ReorderTabsRequest.Assignment)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Assignment {
        // message fields
        // @@protoc_insertion_point(field:iterm2.ReorderTabsRequest.Assignment.window_id)
        pub window_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.ReorderTabsRequest.Assignment.tab_ids)
        pub tab_ids: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.ReorderTabsRequest.Assignment.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Assignment {
        fn default() -> &'a Assignment {
            <Assignment as ::protobuf::Message>::default_instance()
        }
    }

    impl Assignment {
        pub fn new() -> Assignment {
            ::std::default::Default::default()
        }

        // optional string window_id = 1;

        pub fn window_id(&self) -> &str {
            match self.window_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_window_id(&mut self) {
            self.window_id = ::std::option::Option::None;
        }

        pub fn has_window_id(&self) -> bool {
            self.window_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_window_id(&mut self, v: ::std::string::String) {
            self.window_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_window_id(&mut self) -> &mut ::std::string::String {
            if self.window_id.is_none() {
                self.window_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.window_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_window_id(&mut self) -> ::std::string::String {
            self.window_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "window_id",
                |m: &Assignment| { &m.window_id },
                |m: &mut Assignment| { &mut m.window_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "tab_ids",
                |m: &Assignment| { &m.tab_ids },
                |m: &mut Assignment| { &mut m.tab_ids },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Assignment>(
                "ReorderTabsRequest.Assignment",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Assignment {
        const NAME: &'static str = "Assignment";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.window_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.tab_ids.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.window_id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            for value in &self.tab_ids {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.window_id.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.tab_ids {
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Assignment {
            Assignment::new()
        }

        fn clear(&mut self) {
            self.window_id = ::std::option::Option::None;
            self.tab_ids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Assignment {
            static instance: Assignment = Assignment {
                window_id: ::std::option::Option::None,
                tab_ids: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Assignment {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ReorderTabsRequest.Assignment").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Assignment {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Assignment {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:iterm2.ReorderTabsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReorderTabsResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ReorderTabsResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<reorder_tabs_response::Status>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ReorderTabsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReorderTabsResponse {
    fn default() -> &'a ReorderTabsResponse {
        <ReorderTabsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReorderTabsResponse {
    pub fn new() -> ReorderTabsResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.ReorderTabsResponse.Status status = 4;

    pub fn status(&self) -> reorder_tabs_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(reorder_tabs_response::Status::OK),
            None => reorder_tabs_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: reorder_tabs_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &ReorderTabsResponse| { &m.status },
            |m: &mut ReorderTabsResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReorderTabsResponse>(
            "ReorderTabsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReorderTabsResponse {
    const NAME: &'static str = "ReorderTabsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReorderTabsResponse {
        ReorderTabsResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReorderTabsResponse {
        static instance: ReorderTabsResponse = ReorderTabsResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReorderTabsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReorderTabsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReorderTabsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReorderTabsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ReorderTabsResponse`
pub mod reorder_tabs_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.ReorderTabsResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.ReorderTabsResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.ReorderTabsResponse.Status.INVALID_ASSIGNMENT)
        INVALID_ASSIGNMENT = 1,
        // @@protoc_insertion_point(enum_value:iterm2.ReorderTabsResponse.Status.INVALID_WINDOW_ID)
        INVALID_WINDOW_ID = 2,
        // @@protoc_insertion_point(enum_value:iterm2.ReorderTabsResponse.Status.INVALID_TAB_ID)
        INVALID_TAB_ID = 3,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::INVALID_ASSIGNMENT),
                2 => ::std::option::Option::Some(Status::INVALID_WINDOW_ID),
                3 => ::std::option::Option::Some(Status::INVALID_TAB_ID),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "INVALID_ASSIGNMENT" => ::std::option::Option::Some(Status::INVALID_ASSIGNMENT),
                "INVALID_WINDOW_ID" => ::std::option::Option::Some(Status::INVALID_WINDOW_ID),
                "INVALID_TAB_ID" => ::std::option::Option::Some(Status::INVALID_TAB_ID),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::INVALID_ASSIGNMENT,
            Status::INVALID_WINDOW_ID,
            Status::INVALID_TAB_ID,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ReorderTabsResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("ReorderTabsResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.TmuxRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TmuxRequest {
    // message oneof groups
    pub payload: ::std::option::Option<tmux_request::Payload>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.TmuxRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TmuxRequest {
    fn default() -> &'a TmuxRequest {
        <TmuxRequest as ::protobuf::Message>::default_instance()
    }
}

impl TmuxRequest {
    pub fn new() -> TmuxRequest {
        ::std::default::Default::default()
    }

    // optional .iterm2.TmuxRequest.ListConnections list_connections = 1;

    pub fn list_connections(&self) -> &tmux_request::ListConnections {
        match self.payload {
            ::std::option::Option::Some(tmux_request::Payload::ListConnections(ref v)) => v,
            _ => <tmux_request::ListConnections as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_list_connections(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_list_connections(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(tmux_request::Payload::ListConnections(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_connections(&mut self, v: tmux_request::ListConnections) {
        self.payload = ::std::option::Option::Some(tmux_request::Payload::ListConnections(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_connections(&mut self) -> &mut tmux_request::ListConnections {
        if let ::std::option::Option::Some(tmux_request::Payload::ListConnections(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(tmux_request::Payload::ListConnections(tmux_request::ListConnections::new()));
        }
        match self.payload {
            ::std::option::Option::Some(tmux_request::Payload::ListConnections(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_connections(&mut self) -> tmux_request::ListConnections {
        if self.has_list_connections() {
            match self.payload.take() {
                ::std::option::Option::Some(tmux_request::Payload::ListConnections(v)) => v,
                _ => panic!(),
            }
        } else {
            tmux_request::ListConnections::new()
        }
    }

    // optional .iterm2.TmuxRequest.SendCommand send_command = 2;

    pub fn send_command(&self) -> &tmux_request::SendCommand {
        match self.payload {
            ::std::option::Option::Some(tmux_request::Payload::SendCommand(ref v)) => v,
            _ => <tmux_request::SendCommand as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_send_command(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_send_command(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(tmux_request::Payload::SendCommand(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_send_command(&mut self, v: tmux_request::SendCommand) {
        self.payload = ::std::option::Option::Some(tmux_request::Payload::SendCommand(v))
    }

    // Mutable pointer to the field.
    pub fn mut_send_command(&mut self) -> &mut tmux_request::SendCommand {
        if let ::std::option::Option::Some(tmux_request::Payload::SendCommand(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(tmux_request::Payload::SendCommand(tmux_request::SendCommand::new()));
        }
        match self.payload {
            ::std::option::Option::Some(tmux_request::Payload::SendCommand(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_send_command(&mut self) -> tmux_request::SendCommand {
        if self.has_send_command() {
            match self.payload.take() {
                ::std::option::Option::Some(tmux_request::Payload::SendCommand(v)) => v,
                _ => panic!(),
            }
        } else {
            tmux_request::SendCommand::new()
        }
    }

    // optional .iterm2.TmuxRequest.SetWindowVisible set_window_visible = 3;

    pub fn set_window_visible(&self) -> &tmux_request::SetWindowVisible {
        match self.payload {
            ::std::option::Option::Some(tmux_request::Payload::SetWindowVisible(ref v)) => v,
            _ => <tmux_request::SetWindowVisible as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_window_visible(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_set_window_visible(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(tmux_request::Payload::SetWindowVisible(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_window_visible(&mut self, v: tmux_request::SetWindowVisible) {
        self.payload = ::std::option::Option::Some(tmux_request::Payload::SetWindowVisible(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_window_visible(&mut self) -> &mut tmux_request::SetWindowVisible {
        if let ::std::option::Option::Some(tmux_request::Payload::SetWindowVisible(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(tmux_request::Payload::SetWindowVisible(tmux_request::SetWindowVisible::new()));
        }
        match self.payload {
            ::std::option::Option::Some(tmux_request::Payload::SetWindowVisible(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_window_visible(&mut self) -> tmux_request::SetWindowVisible {
        if self.has_set_window_visible() {
            match self.payload.take() {
                ::std::option::Option::Some(tmux_request::Payload::SetWindowVisible(v)) => v,
                _ => panic!(),
            }
        } else {
            tmux_request::SetWindowVisible::new()
        }
    }

    // optional .iterm2.TmuxRequest.CreateWindow create_window = 4;

    pub fn create_window(&self) -> &tmux_request::CreateWindow {
        match self.payload {
            ::std::option::Option::Some(tmux_request::Payload::CreateWindow(ref v)) => v,
            _ => <tmux_request::CreateWindow as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_create_window(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_create_window(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(tmux_request::Payload::CreateWindow(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_window(&mut self, v: tmux_request::CreateWindow) {
        self.payload = ::std::option::Option::Some(tmux_request::Payload::CreateWindow(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_window(&mut self) -> &mut tmux_request::CreateWindow {
        if let ::std::option::Option::Some(tmux_request::Payload::CreateWindow(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(tmux_request::Payload::CreateWindow(tmux_request::CreateWindow::new()));
        }
        match self.payload {
            ::std::option::Option::Some(tmux_request::Payload::CreateWindow(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_window(&mut self) -> tmux_request::CreateWindow {
        if self.has_create_window() {
            match self.payload.take() {
                ::std::option::Option::Some(tmux_request::Payload::CreateWindow(v)) => v,
                _ => panic!(),
            }
        } else {
            tmux_request::CreateWindow::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, tmux_request::ListConnections>(
            "list_connections",
            TmuxRequest::has_list_connections,
            TmuxRequest::list_connections,
            TmuxRequest::mut_list_connections,
            TmuxRequest::set_list_connections,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, tmux_request::SendCommand>(
            "send_command",
            TmuxRequest::has_send_command,
            TmuxRequest::send_command,
            TmuxRequest::mut_send_command,
            TmuxRequest::set_send_command,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, tmux_request::SetWindowVisible>(
            "set_window_visible",
            TmuxRequest::has_set_window_visible,
            TmuxRequest::set_window_visible,
            TmuxRequest::mut_set_window_visible,
            TmuxRequest::set_set_window_visible,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, tmux_request::CreateWindow>(
            "create_window",
            TmuxRequest::has_create_window,
            TmuxRequest::create_window,
            TmuxRequest::mut_create_window,
            TmuxRequest::set_create_window,
        ));
        oneofs.push(tmux_request::Payload::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TmuxRequest>(
            "TmuxRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TmuxRequest {
    const NAME: &'static str = "TmuxRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.payload = ::std::option::Option::Some(tmux_request::Payload::ListConnections(is.read_message()?));
                },
                18 => {
                    self.payload = ::std::option::Option::Some(tmux_request::Payload::SendCommand(is.read_message()?));
                },
                26 => {
                    self.payload = ::std::option::Option::Some(tmux_request::Payload::SetWindowVisible(is.read_message()?));
                },
                34 => {
                    self.payload = ::std::option::Option::Some(tmux_request::Payload::CreateWindow(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &tmux_request::Payload::ListConnections(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &tmux_request::Payload::SendCommand(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &tmux_request::Payload::SetWindowVisible(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &tmux_request::Payload::CreateWindow(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &tmux_request::Payload::ListConnections(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &tmux_request::Payload::SendCommand(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &tmux_request::Payload::SetWindowVisible(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &tmux_request::Payload::CreateWindow(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TmuxRequest {
        TmuxRequest::new()
    }

    fn clear(&mut self) {
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TmuxRequest {
        static instance: TmuxRequest = TmuxRequest {
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TmuxRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TmuxRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TmuxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TmuxRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TmuxRequest`
pub mod tmux_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.TmuxRequest.payload)
    pub enum Payload {
        // @@protoc_insertion_point(oneof_field:iterm2.TmuxRequest.list_connections)
        ListConnections(ListConnections),
        // @@protoc_insertion_point(oneof_field:iterm2.TmuxRequest.send_command)
        SendCommand(SendCommand),
        // @@protoc_insertion_point(oneof_field:iterm2.TmuxRequest.set_window_visible)
        SetWindowVisible(SetWindowVisible),
        // @@protoc_insertion_point(oneof_field:iterm2.TmuxRequest.create_window)
        CreateWindow(CreateWindow),
    }

    impl ::protobuf::Oneof for Payload {
    }

    impl ::protobuf::OneofFull for Payload {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TmuxRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("payload").unwrap()).clone()
        }
    }

    impl Payload {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Payload>("payload")
        }
    }
    // @@protoc_insertion_point(message:iterm2.TmuxRequest.ListConnections)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ListConnections {
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.TmuxRequest.ListConnections.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ListConnections {
        fn default() -> &'a ListConnections {
            <ListConnections as ::protobuf::Message>::default_instance()
        }
    }

    impl ListConnections {
        pub fn new() -> ListConnections {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListConnections>(
                "TmuxRequest.ListConnections",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ListConnections {
        const NAME: &'static str = "ListConnections";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ListConnections {
            ListConnections::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ListConnections {
            static instance: ListConnections = ListConnections {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ListConnections {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TmuxRequest.ListConnections").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ListConnections {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ListConnections {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.TmuxRequest.SendCommand)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SendCommand {
        // message fields
        // @@protoc_insertion_point(field:iterm2.TmuxRequest.SendCommand.connection_id)
        pub connection_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.TmuxRequest.SendCommand.command)
        pub command: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.TmuxRequest.SendCommand.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SendCommand {
        fn default() -> &'a SendCommand {
            <SendCommand as ::protobuf::Message>::default_instance()
        }
    }

    impl SendCommand {
        pub fn new() -> SendCommand {
            ::std::default::Default::default()
        }

        // optional string connection_id = 1;

        pub fn connection_id(&self) -> &str {
            match self.connection_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_connection_id(&mut self) {
            self.connection_id = ::std::option::Option::None;
        }

        pub fn has_connection_id(&self) -> bool {
            self.connection_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connection_id(&mut self, v: ::std::string::String) {
            self.connection_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_connection_id(&mut self) -> &mut ::std::string::String {
            if self.connection_id.is_none() {
                self.connection_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.connection_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_connection_id(&mut self) -> ::std::string::String {
            self.connection_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string command = 2;

        pub fn command(&self) -> &str {
            match self.command.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_command(&mut self) {
            self.command = ::std::option::Option::None;
        }

        pub fn has_command(&self) -> bool {
            self.command.is_some()
        }

        // Param is passed by value, moved
        pub fn set_command(&mut self, v: ::std::string::String) {
            self.command = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_command(&mut self) -> &mut ::std::string::String {
            if self.command.is_none() {
                self.command = ::std::option::Option::Some(::std::string::String::new());
            }
            self.command.as_mut().unwrap()
        }

        // Take field
        pub fn take_command(&mut self) -> ::std::string::String {
            self.command.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "connection_id",
                |m: &SendCommand| { &m.connection_id },
                |m: &mut SendCommand| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "command",
                |m: &SendCommand| { &m.command },
                |m: &mut SendCommand| { &mut m.command },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SendCommand>(
                "TmuxRequest.SendCommand",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SendCommand {
        const NAME: &'static str = "SendCommand";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.connection_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.command = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.connection_id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.command.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.connection_id.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.command.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SendCommand {
            SendCommand::new()
        }

        fn clear(&mut self) {
            self.connection_id = ::std::option::Option::None;
            self.command = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SendCommand {
            static instance: SendCommand = SendCommand {
                connection_id: ::std::option::Option::None,
                command: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SendCommand {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TmuxRequest.SendCommand").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SendCommand {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SendCommand {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.TmuxRequest.SetWindowVisible)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetWindowVisible {
        // message fields
        // @@protoc_insertion_point(field:iterm2.TmuxRequest.SetWindowVisible.connection_id)
        pub connection_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.TmuxRequest.SetWindowVisible.window_id)
        pub window_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.TmuxRequest.SetWindowVisible.visible)
        pub visible: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.TmuxRequest.SetWindowVisible.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetWindowVisible {
        fn default() -> &'a SetWindowVisible {
            <SetWindowVisible as ::protobuf::Message>::default_instance()
        }
    }

    impl SetWindowVisible {
        pub fn new() -> SetWindowVisible {
            ::std::default::Default::default()
        }

        // optional string connection_id = 1;

        pub fn connection_id(&self) -> &str {
            match self.connection_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_connection_id(&mut self) {
            self.connection_id = ::std::option::Option::None;
        }

        pub fn has_connection_id(&self) -> bool {
            self.connection_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connection_id(&mut self, v: ::std::string::String) {
            self.connection_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_connection_id(&mut self) -> &mut ::std::string::String {
            if self.connection_id.is_none() {
                self.connection_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.connection_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_connection_id(&mut self) -> ::std::string::String {
            self.connection_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string window_id = 2;

        pub fn window_id(&self) -> &str {
            match self.window_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_window_id(&mut self) {
            self.window_id = ::std::option::Option::None;
        }

        pub fn has_window_id(&self) -> bool {
            self.window_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_window_id(&mut self, v: ::std::string::String) {
            self.window_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_window_id(&mut self) -> &mut ::std::string::String {
            if self.window_id.is_none() {
                self.window_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.window_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_window_id(&mut self) -> ::std::string::String {
            self.window_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool visible = 3;

        pub fn visible(&self) -> bool {
            self.visible.unwrap_or(false)
        }

        pub fn clear_visible(&mut self) {
            self.visible = ::std::option::Option::None;
        }

        pub fn has_visible(&self) -> bool {
            self.visible.is_some()
        }

        // Param is passed by value, moved
        pub fn set_visible(&mut self, v: bool) {
            self.visible = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "connection_id",
                |m: &SetWindowVisible| { &m.connection_id },
                |m: &mut SetWindowVisible| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "window_id",
                |m: &SetWindowVisible| { &m.window_id },
                |m: &mut SetWindowVisible| { &mut m.window_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "visible",
                |m: &SetWindowVisible| { &m.visible },
                |m: &mut SetWindowVisible| { &mut m.visible },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetWindowVisible>(
                "TmuxRequest.SetWindowVisible",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SetWindowVisible {
        const NAME: &'static str = "SetWindowVisible";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.connection_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.window_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.visible = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.connection_id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.window_id.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.visible {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.connection_id.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.window_id.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.visible {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetWindowVisible {
            SetWindowVisible::new()
        }

        fn clear(&mut self) {
            self.connection_id = ::std::option::Option::None;
            self.window_id = ::std::option::Option::None;
            self.visible = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetWindowVisible {
            static instance: SetWindowVisible = SetWindowVisible {
                connection_id: ::std::option::Option::None,
                window_id: ::std::option::Option::None,
                visible: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SetWindowVisible {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TmuxRequest.SetWindowVisible").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SetWindowVisible {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SetWindowVisible {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.TmuxRequest.CreateWindow)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CreateWindow {
        // message fields
        // @@protoc_insertion_point(field:iterm2.TmuxRequest.CreateWindow.connection_id)
        pub connection_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.TmuxRequest.CreateWindow.affinity)
        pub affinity: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.TmuxRequest.CreateWindow.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CreateWindow {
        fn default() -> &'a CreateWindow {
            <CreateWindow as ::protobuf::Message>::default_instance()
        }
    }

    impl CreateWindow {
        pub fn new() -> CreateWindow {
            ::std::default::Default::default()
        }

        // optional string connection_id = 1;

        pub fn connection_id(&self) -> &str {
            match self.connection_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_connection_id(&mut self) {
            self.connection_id = ::std::option::Option::None;
        }

        pub fn has_connection_id(&self) -> bool {
            self.connection_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connection_id(&mut self, v: ::std::string::String) {
            self.connection_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_connection_id(&mut self) -> &mut ::std::string::String {
            if self.connection_id.is_none() {
                self.connection_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.connection_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_connection_id(&mut self) -> ::std::string::String {
            self.connection_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string affinity = 2;

        pub fn affinity(&self) -> &str {
            match self.affinity.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_affinity(&mut self) {
            self.affinity = ::std::option::Option::None;
        }

        pub fn has_affinity(&self) -> bool {
            self.affinity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_affinity(&mut self, v: ::std::string::String) {
            self.affinity = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_affinity(&mut self) -> &mut ::std::string::String {
            if self.affinity.is_none() {
                self.affinity = ::std::option::Option::Some(::std::string::String::new());
            }
            self.affinity.as_mut().unwrap()
        }

        // Take field
        pub fn take_affinity(&mut self) -> ::std::string::String {
            self.affinity.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "connection_id",
                |m: &CreateWindow| { &m.connection_id },
                |m: &mut CreateWindow| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "affinity",
                |m: &CreateWindow| { &m.affinity },
                |m: &mut CreateWindow| { &mut m.affinity },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateWindow>(
                "TmuxRequest.CreateWindow",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CreateWindow {
        const NAME: &'static str = "CreateWindow";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.connection_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.affinity = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.connection_id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.affinity.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.connection_id.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.affinity.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CreateWindow {
            CreateWindow::new()
        }

        fn clear(&mut self) {
            self.connection_id = ::std::option::Option::None;
            self.affinity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CreateWindow {
            static instance: CreateWindow = CreateWindow {
                connection_id: ::std::option::Option::None,
                affinity: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CreateWindow {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TmuxRequest.CreateWindow").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CreateWindow {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CreateWindow {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:iterm2.TmuxResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TmuxResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.TmuxResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<tmux_response::Status>>,
    // message oneof groups
    pub payload: ::std::option::Option<tmux_response::Payload>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.TmuxResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TmuxResponse {
    fn default() -> &'a TmuxResponse {
        <TmuxResponse as ::protobuf::Message>::default_instance()
    }
}

impl TmuxResponse {
    pub fn new() -> TmuxResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.TmuxResponse.ListConnections list_connections = 1;

    pub fn list_connections(&self) -> &tmux_response::ListConnections {
        match self.payload {
            ::std::option::Option::Some(tmux_response::Payload::ListConnections(ref v)) => v,
            _ => <tmux_response::ListConnections as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_list_connections(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_list_connections(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(tmux_response::Payload::ListConnections(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_connections(&mut self, v: tmux_response::ListConnections) {
        self.payload = ::std::option::Option::Some(tmux_response::Payload::ListConnections(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_connections(&mut self) -> &mut tmux_response::ListConnections {
        if let ::std::option::Option::Some(tmux_response::Payload::ListConnections(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(tmux_response::Payload::ListConnections(tmux_response::ListConnections::new()));
        }
        match self.payload {
            ::std::option::Option::Some(tmux_response::Payload::ListConnections(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_connections(&mut self) -> tmux_response::ListConnections {
        if self.has_list_connections() {
            match self.payload.take() {
                ::std::option::Option::Some(tmux_response::Payload::ListConnections(v)) => v,
                _ => panic!(),
            }
        } else {
            tmux_response::ListConnections::new()
        }
    }

    // optional .iterm2.TmuxResponse.SendCommand send_command = 2;

    pub fn send_command(&self) -> &tmux_response::SendCommand {
        match self.payload {
            ::std::option::Option::Some(tmux_response::Payload::SendCommand(ref v)) => v,
            _ => <tmux_response::SendCommand as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_send_command(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_send_command(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(tmux_response::Payload::SendCommand(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_send_command(&mut self, v: tmux_response::SendCommand) {
        self.payload = ::std::option::Option::Some(tmux_response::Payload::SendCommand(v))
    }

    // Mutable pointer to the field.
    pub fn mut_send_command(&mut self) -> &mut tmux_response::SendCommand {
        if let ::std::option::Option::Some(tmux_response::Payload::SendCommand(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(tmux_response::Payload::SendCommand(tmux_response::SendCommand::new()));
        }
        match self.payload {
            ::std::option::Option::Some(tmux_response::Payload::SendCommand(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_send_command(&mut self) -> tmux_response::SendCommand {
        if self.has_send_command() {
            match self.payload.take() {
                ::std::option::Option::Some(tmux_response::Payload::SendCommand(v)) => v,
                _ => panic!(),
            }
        } else {
            tmux_response::SendCommand::new()
        }
    }

    // optional .iterm2.TmuxResponse.SetWindowVisible set_window_visible = 3;

    pub fn set_window_visible(&self) -> &tmux_response::SetWindowVisible {
        match self.payload {
            ::std::option::Option::Some(tmux_response::Payload::SetWindowVisible(ref v)) => v,
            _ => <tmux_response::SetWindowVisible as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_set_window_visible(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_set_window_visible(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(tmux_response::Payload::SetWindowVisible(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_window_visible(&mut self, v: tmux_response::SetWindowVisible) {
        self.payload = ::std::option::Option::Some(tmux_response::Payload::SetWindowVisible(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_window_visible(&mut self) -> &mut tmux_response::SetWindowVisible {
        if let ::std::option::Option::Some(tmux_response::Payload::SetWindowVisible(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(tmux_response::Payload::SetWindowVisible(tmux_response::SetWindowVisible::new()));
        }
        match self.payload {
            ::std::option::Option::Some(tmux_response::Payload::SetWindowVisible(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_window_visible(&mut self) -> tmux_response::SetWindowVisible {
        if self.has_set_window_visible() {
            match self.payload.take() {
                ::std::option::Option::Some(tmux_response::Payload::SetWindowVisible(v)) => v,
                _ => panic!(),
            }
        } else {
            tmux_response::SetWindowVisible::new()
        }
    }

    // optional .iterm2.TmuxResponse.CreateWindow create_window = 5;

    pub fn create_window(&self) -> &tmux_response::CreateWindow {
        match self.payload {
            ::std::option::Option::Some(tmux_response::Payload::CreateWindow(ref v)) => v,
            _ => <tmux_response::CreateWindow as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_create_window(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_create_window(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(tmux_response::Payload::CreateWindow(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_window(&mut self, v: tmux_response::CreateWindow) {
        self.payload = ::std::option::Option::Some(tmux_response::Payload::CreateWindow(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_window(&mut self) -> &mut tmux_response::CreateWindow {
        if let ::std::option::Option::Some(tmux_response::Payload::CreateWindow(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(tmux_response::Payload::CreateWindow(tmux_response::CreateWindow::new()));
        }
        match self.payload {
            ::std::option::Option::Some(tmux_response::Payload::CreateWindow(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_window(&mut self) -> tmux_response::CreateWindow {
        if self.has_create_window() {
            match self.payload.take() {
                ::std::option::Option::Some(tmux_response::Payload::CreateWindow(v)) => v,
                _ => panic!(),
            }
        } else {
            tmux_response::CreateWindow::new()
        }
    }

    // optional .iterm2.TmuxResponse.Status status = 4;

    pub fn status(&self) -> tmux_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(tmux_response::Status::OK),
            None => tmux_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: tmux_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, tmux_response::ListConnections>(
            "list_connections",
            TmuxResponse::has_list_connections,
            TmuxResponse::list_connections,
            TmuxResponse::mut_list_connections,
            TmuxResponse::set_list_connections,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, tmux_response::SendCommand>(
            "send_command",
            TmuxResponse::has_send_command,
            TmuxResponse::send_command,
            TmuxResponse::mut_send_command,
            TmuxResponse::set_send_command,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, tmux_response::SetWindowVisible>(
            "set_window_visible",
            TmuxResponse::has_set_window_visible,
            TmuxResponse::set_window_visible,
            TmuxResponse::mut_set_window_visible,
            TmuxResponse::set_set_window_visible,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, tmux_response::CreateWindow>(
            "create_window",
            TmuxResponse::has_create_window,
            TmuxResponse::create_window,
            TmuxResponse::mut_create_window,
            TmuxResponse::set_create_window,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &TmuxResponse| { &m.status },
            |m: &mut TmuxResponse| { &mut m.status },
        ));
        oneofs.push(tmux_response::Payload::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TmuxResponse>(
            "TmuxResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TmuxResponse {
    const NAME: &'static str = "TmuxResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.payload = ::std::option::Option::Some(tmux_response::Payload::ListConnections(is.read_message()?));
                },
                18 => {
                    self.payload = ::std::option::Option::Some(tmux_response::Payload::SendCommand(is.read_message()?));
                },
                26 => {
                    self.payload = ::std::option::Option::Some(tmux_response::Payload::SetWindowVisible(is.read_message()?));
                },
                42 => {
                    self.payload = ::std::option::Option::Some(tmux_response::Payload::CreateWindow(is.read_message()?));
                },
                32 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &tmux_response::Payload::ListConnections(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &tmux_response::Payload::SendCommand(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &tmux_response::Payload::SetWindowVisible(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &tmux_response::Payload::CreateWindow(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &tmux_response::Payload::ListConnections(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &tmux_response::Payload::SendCommand(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &tmux_response::Payload::SetWindowVisible(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &tmux_response::Payload::CreateWindow(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TmuxResponse {
        TmuxResponse::new()
    }

    fn clear(&mut self) {
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TmuxResponse {
        static instance: TmuxResponse = TmuxResponse {
            status: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TmuxResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TmuxResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TmuxResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TmuxResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TmuxResponse`
pub mod tmux_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.TmuxResponse.payload)
    pub enum Payload {
        // @@protoc_insertion_point(oneof_field:iterm2.TmuxResponse.list_connections)
        ListConnections(ListConnections),
        // @@protoc_insertion_point(oneof_field:iterm2.TmuxResponse.send_command)
        SendCommand(SendCommand),
        // @@protoc_insertion_point(oneof_field:iterm2.TmuxResponse.set_window_visible)
        SetWindowVisible(SetWindowVisible),
        // @@protoc_insertion_point(oneof_field:iterm2.TmuxResponse.create_window)
        CreateWindow(CreateWindow),
    }

    impl ::protobuf::Oneof for Payload {
    }

    impl ::protobuf::OneofFull for Payload {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TmuxResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("payload").unwrap()).clone()
        }
    }

    impl Payload {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Payload>("payload")
        }
    }
    // @@protoc_insertion_point(message:iterm2.TmuxResponse.ListConnections)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ListConnections {
        // message fields
        // @@protoc_insertion_point(field:iterm2.TmuxResponse.ListConnections.connections)
        pub connections: ::std::vec::Vec<list_connections::Connection>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.TmuxResponse.ListConnections.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ListConnections {
        fn default() -> &'a ListConnections {
            <ListConnections as ::protobuf::Message>::default_instance()
        }
    }

    impl ListConnections {
        pub fn new() -> ListConnections {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "connections",
                |m: &ListConnections| { &m.connections },
                |m: &mut ListConnections| { &mut m.connections },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListConnections>(
                "TmuxResponse.ListConnections",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ListConnections {
        const NAME: &'static str = "ListConnections";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.connections.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.connections {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.connections {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ListConnections {
            ListConnections::new()
        }

        fn clear(&mut self) {
            self.connections.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ListConnections {
            static instance: ListConnections = ListConnections {
                connections: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ListConnections {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TmuxResponse.ListConnections").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ListConnections {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ListConnections {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `ListConnections`
    pub mod list_connections {
        // @@protoc_insertion_point(message:iterm2.TmuxResponse.ListConnections.Connection)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Connection {
            // message fields
            // @@protoc_insertion_point(field:iterm2.TmuxResponse.ListConnections.Connection.connection_id)
            pub connection_id: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:iterm2.TmuxResponse.ListConnections.Connection.owning_session_id)
            pub owning_session_id: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:iterm2.TmuxResponse.ListConnections.Connection.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Connection {
            fn default() -> &'a Connection {
                <Connection as ::protobuf::Message>::default_instance()
            }
        }

        impl Connection {
            pub fn new() -> Connection {
                ::std::default::Default::default()
            }

            // optional string connection_id = 1;

            pub fn connection_id(&self) -> &str {
                match self.connection_id.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_connection_id(&mut self) {
                self.connection_id = ::std::option::Option::None;
            }

            pub fn has_connection_id(&self) -> bool {
                self.connection_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_connection_id(&mut self, v: ::std::string::String) {
                self.connection_id = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_connection_id(&mut self) -> &mut ::std::string::String {
                if self.connection_id.is_none() {
                    self.connection_id = ::std::option::Option::Some(::std::string::String::new());
                }
                self.connection_id.as_mut().unwrap()
            }

            // Take field
            pub fn take_connection_id(&mut self) -> ::std::string::String {
                self.connection_id.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string owning_session_id = 2;

            pub fn owning_session_id(&self) -> &str {
                match self.owning_session_id.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_owning_session_id(&mut self) {
                self.owning_session_id = ::std::option::Option::None;
            }

            pub fn has_owning_session_id(&self) -> bool {
                self.owning_session_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_owning_session_id(&mut self, v: ::std::string::String) {
                self.owning_session_id = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_owning_session_id(&mut self) -> &mut ::std::string::String {
                if self.owning_session_id.is_none() {
                    self.owning_session_id = ::std::option::Option::Some(::std::string::String::new());
                }
                self.owning_session_id.as_mut().unwrap()
            }

            // Take field
            pub fn take_owning_session_id(&mut self) -> ::std::string::String {
                self.owning_session_id.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "connection_id",
                    |m: &Connection| { &m.connection_id },
                    |m: &mut Connection| { &mut m.connection_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "owning_session_id",
                    |m: &Connection| { &m.owning_session_id },
                    |m: &mut Connection| { &mut m.owning_session_id },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Connection>(
                    "TmuxResponse.ListConnections.Connection",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Connection {
            const NAME: &'static str = "Connection";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.connection_id = ::std::option::Option::Some(is.read_string()?);
                        },
                        18 => {
                            self.owning_session_id = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.connection_id.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.owning_session_id.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.connection_id.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.owning_session_id.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Connection {
                Connection::new()
            }

            fn clear(&mut self) {
                self.connection_id = ::std::option::Option::None;
                self.owning_session_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Connection {
                static instance: Connection = Connection {
                    connection_id: ::std::option::Option::None,
                    owning_session_id: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Connection {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("TmuxResponse.ListConnections.Connection").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Connection {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Connection {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:iterm2.TmuxResponse.SendCommand)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SendCommand {
        // message fields
        // @@protoc_insertion_point(field:iterm2.TmuxResponse.SendCommand.output)
        pub output: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.TmuxResponse.SendCommand.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SendCommand {
        fn default() -> &'a SendCommand {
            <SendCommand as ::protobuf::Message>::default_instance()
        }
    }

    impl SendCommand {
        pub fn new() -> SendCommand {
            ::std::default::Default::default()
        }

        // optional string output = 1;

        pub fn output(&self) -> &str {
            match self.output.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_output(&mut self) {
            self.output = ::std::option::Option::None;
        }

        pub fn has_output(&self) -> bool {
            self.output.is_some()
        }

        // Param is passed by value, moved
        pub fn set_output(&mut self, v: ::std::string::String) {
            self.output = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_output(&mut self) -> &mut ::std::string::String {
            if self.output.is_none() {
                self.output = ::std::option::Option::Some(::std::string::String::new());
            }
            self.output.as_mut().unwrap()
        }

        // Take field
        pub fn take_output(&mut self) -> ::std::string::String {
            self.output.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "output",
                |m: &SendCommand| { &m.output },
                |m: &mut SendCommand| { &mut m.output },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SendCommand>(
                "TmuxResponse.SendCommand",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SendCommand {
        const NAME: &'static str = "SendCommand";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.output = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.output.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.output.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SendCommand {
            SendCommand::new()
        }

        fn clear(&mut self) {
            self.output = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SendCommand {
            static instance: SendCommand = SendCommand {
                output: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SendCommand {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TmuxResponse.SendCommand").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SendCommand {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SendCommand {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.TmuxResponse.SetWindowVisible)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetWindowVisible {
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.TmuxResponse.SetWindowVisible.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetWindowVisible {
        fn default() -> &'a SetWindowVisible {
            <SetWindowVisible as ::protobuf::Message>::default_instance()
        }
    }

    impl SetWindowVisible {
        pub fn new() -> SetWindowVisible {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetWindowVisible>(
                "TmuxResponse.SetWindowVisible",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SetWindowVisible {
        const NAME: &'static str = "SetWindowVisible";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetWindowVisible {
            SetWindowVisible::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetWindowVisible {
            static instance: SetWindowVisible = SetWindowVisible {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SetWindowVisible {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TmuxResponse.SetWindowVisible").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SetWindowVisible {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SetWindowVisible {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.TmuxResponse.CreateWindow)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CreateWindow {
        // message fields
        // @@protoc_insertion_point(field:iterm2.TmuxResponse.CreateWindow.tab_id)
        pub tab_id: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.TmuxResponse.CreateWindow.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CreateWindow {
        fn default() -> &'a CreateWindow {
            <CreateWindow as ::protobuf::Message>::default_instance()
        }
    }

    impl CreateWindow {
        pub fn new() -> CreateWindow {
            ::std::default::Default::default()
        }

        // optional string tab_id = 1;

        pub fn tab_id(&self) -> &str {
            match self.tab_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_tab_id(&mut self) {
            self.tab_id = ::std::option::Option::None;
        }

        pub fn has_tab_id(&self) -> bool {
            self.tab_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tab_id(&mut self, v: ::std::string::String) {
            self.tab_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tab_id(&mut self) -> &mut ::std::string::String {
            if self.tab_id.is_none() {
                self.tab_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.tab_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_tab_id(&mut self) -> ::std::string::String {
            self.tab_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tab_id",
                |m: &CreateWindow| { &m.tab_id },
                |m: &mut CreateWindow| { &mut m.tab_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateWindow>(
                "TmuxResponse.CreateWindow",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CreateWindow {
        const NAME: &'static str = "CreateWindow";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.tab_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tab_id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.tab_id.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CreateWindow {
            CreateWindow::new()
        }

        fn clear(&mut self) {
            self.tab_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CreateWindow {
            static instance: CreateWindow = CreateWindow {
                tab_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CreateWindow {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TmuxResponse.CreateWindow").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CreateWindow {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CreateWindow {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.TmuxResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.TmuxResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.TmuxResponse.Status.INVALID_REQUEST)
        INVALID_REQUEST = 1,
        // @@protoc_insertion_point(enum_value:iterm2.TmuxResponse.Status.INVALID_CONNECTION_ID)
        INVALID_CONNECTION_ID = 2,
        // @@protoc_insertion_point(enum_value:iterm2.TmuxResponse.Status.INVALID_WINDOW_ID)
        INVALID_WINDOW_ID = 3,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::INVALID_REQUEST),
                2 => ::std::option::Option::Some(Status::INVALID_CONNECTION_ID),
                3 => ::std::option::Option::Some(Status::INVALID_WINDOW_ID),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "INVALID_REQUEST" => ::std::option::Option::Some(Status::INVALID_REQUEST),
                "INVALID_CONNECTION_ID" => ::std::option::Option::Some(Status::INVALID_CONNECTION_ID),
                "INVALID_WINDOW_ID" => ::std::option::Option::Some(Status::INVALID_WINDOW_ID),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::INVALID_REQUEST,
            Status::INVALID_CONNECTION_ID,
            Status::INVALID_WINDOW_ID,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TmuxResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("TmuxResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.GetBroadcastDomainsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBroadcastDomainsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.GetBroadcastDomainsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBroadcastDomainsRequest {
    fn default() -> &'a GetBroadcastDomainsRequest {
        <GetBroadcastDomainsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBroadcastDomainsRequest {
    pub fn new() -> GetBroadcastDomainsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBroadcastDomainsRequest>(
            "GetBroadcastDomainsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBroadcastDomainsRequest {
    const NAME: &'static str = "GetBroadcastDomainsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBroadcastDomainsRequest {
        GetBroadcastDomainsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBroadcastDomainsRequest {
        static instance: GetBroadcastDomainsRequest = GetBroadcastDomainsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBroadcastDomainsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBroadcastDomainsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBroadcastDomainsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBroadcastDomainsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.BroadcastDomain)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BroadcastDomain {
    // message fields
    // @@protoc_insertion_point(field:iterm2.BroadcastDomain.session_ids)
    pub session_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.BroadcastDomain.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BroadcastDomain {
    fn default() -> &'a BroadcastDomain {
        <BroadcastDomain as ::protobuf::Message>::default_instance()
    }
}

impl BroadcastDomain {
    pub fn new() -> BroadcastDomain {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "session_ids",
            |m: &BroadcastDomain| { &m.session_ids },
            |m: &mut BroadcastDomain| { &mut m.session_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BroadcastDomain>(
            "BroadcastDomain",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BroadcastDomain {
    const NAME: &'static str = "BroadcastDomain";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.session_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.session_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BroadcastDomain {
        BroadcastDomain::new()
    }

    fn clear(&mut self) {
        self.session_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BroadcastDomain {
        static instance: BroadcastDomain = BroadcastDomain {
            session_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BroadcastDomain {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BroadcastDomain").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BroadcastDomain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BroadcastDomain {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.GetBroadcastDomainsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBroadcastDomainsResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.GetBroadcastDomainsResponse.broadcast_domains)
    pub broadcast_domains: ::std::vec::Vec<BroadcastDomain>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.GetBroadcastDomainsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBroadcastDomainsResponse {
    fn default() -> &'a GetBroadcastDomainsResponse {
        <GetBroadcastDomainsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBroadcastDomainsResponse {
    pub fn new() -> GetBroadcastDomainsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "broadcast_domains",
            |m: &GetBroadcastDomainsResponse| { &m.broadcast_domains },
            |m: &mut GetBroadcastDomainsResponse| { &mut m.broadcast_domains },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBroadcastDomainsResponse>(
            "GetBroadcastDomainsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBroadcastDomainsResponse {
    const NAME: &'static str = "GetBroadcastDomainsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.broadcast_domains.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.broadcast_domains {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.broadcast_domains {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBroadcastDomainsResponse {
        GetBroadcastDomainsResponse::new()
    }

    fn clear(&mut self) {
        self.broadcast_domains.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBroadcastDomainsResponse {
        static instance: GetBroadcastDomainsResponse = GetBroadcastDomainsResponse {
            broadcast_domains: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBroadcastDomainsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBroadcastDomainsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBroadcastDomainsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBroadcastDomainsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.SetTabLayoutRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetTabLayoutRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SetTabLayoutRequest.root)
    pub root: ::protobuf::MessageField<SplitTreeNode>,
    // @@protoc_insertion_point(field:iterm2.SetTabLayoutRequest.tab_id)
    pub tab_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SetTabLayoutRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetTabLayoutRequest {
    fn default() -> &'a SetTabLayoutRequest {
        <SetTabLayoutRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetTabLayoutRequest {
    pub fn new() -> SetTabLayoutRequest {
        ::std::default::Default::default()
    }

    // optional string tab_id = 2;

    pub fn tab_id(&self) -> &str {
        match self.tab_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tab_id(&mut self) {
        self.tab_id = ::std::option::Option::None;
    }

    pub fn has_tab_id(&self) -> bool {
        self.tab_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tab_id(&mut self, v: ::std::string::String) {
        self.tab_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tab_id(&mut self) -> &mut ::std::string::String {
        if self.tab_id.is_none() {
            self.tab_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tab_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_tab_id(&mut self) -> ::std::string::String {
        self.tab_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SplitTreeNode>(
            "root",
            |m: &SetTabLayoutRequest| { &m.root },
            |m: &mut SetTabLayoutRequest| { &mut m.root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tab_id",
            |m: &SetTabLayoutRequest| { &m.tab_id },
            |m: &mut SetTabLayoutRequest| { &mut m.tab_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetTabLayoutRequest>(
            "SetTabLayoutRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetTabLayoutRequest {
    const NAME: &'static str = "SetTabLayoutRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.root)?;
                },
                18 => {
                    self.tab_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.root.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tab_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.root.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.tab_id.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetTabLayoutRequest {
        SetTabLayoutRequest::new()
    }

    fn clear(&mut self) {
        self.root.clear();
        self.tab_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetTabLayoutRequest {
        static instance: SetTabLayoutRequest = SetTabLayoutRequest {
            root: ::protobuf::MessageField::none(),
            tab_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetTabLayoutRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetTabLayoutRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetTabLayoutRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetTabLayoutRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.SetTabLayoutResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetTabLayoutResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SetTabLayoutResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<set_tab_layout_response::Status>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SetTabLayoutResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetTabLayoutResponse {
    fn default() -> &'a SetTabLayoutResponse {
        <SetTabLayoutResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetTabLayoutResponse {
    pub fn new() -> SetTabLayoutResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.SetTabLayoutResponse.Status status = 1;

    pub fn status(&self) -> set_tab_layout_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(set_tab_layout_response::Status::OK),
            None => set_tab_layout_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: set_tab_layout_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &SetTabLayoutResponse| { &m.status },
            |m: &mut SetTabLayoutResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetTabLayoutResponse>(
            "SetTabLayoutResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetTabLayoutResponse {
    const NAME: &'static str = "SetTabLayoutResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetTabLayoutResponse {
        SetTabLayoutResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetTabLayoutResponse {
        static instance: SetTabLayoutResponse = SetTabLayoutResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetTabLayoutResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetTabLayoutResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetTabLayoutResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetTabLayoutResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SetTabLayoutResponse`
pub mod set_tab_layout_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.SetTabLayoutResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.SetTabLayoutResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.SetTabLayoutResponse.Status.BAD_TAB_ID)
        BAD_TAB_ID = 1,
        // @@protoc_insertion_point(enum_value:iterm2.SetTabLayoutResponse.Status.WRONG_TREE)
        WRONG_TREE = 2,
        // @@protoc_insertion_point(enum_value:iterm2.SetTabLayoutResponse.Status.INVALID_SIZE)
        INVALID_SIZE = 3,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::BAD_TAB_ID),
                2 => ::std::option::Option::Some(Status::WRONG_TREE),
                3 => ::std::option::Option::Some(Status::INVALID_SIZE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "BAD_TAB_ID" => ::std::option::Option::Some(Status::BAD_TAB_ID),
                "WRONG_TREE" => ::std::option::Option::Some(Status::WRONG_TREE),
                "INVALID_SIZE" => ::std::option::Option::Some(Status::INVALID_SIZE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::BAD_TAB_ID,
            Status::WRONG_TREE,
            Status::INVALID_SIZE,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SetTabLayoutResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("SetTabLayoutResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.MenuItemRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MenuItemRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.MenuItemRequest.identifier)
    pub identifier: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.MenuItemRequest.query_only)
    pub query_only: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.MenuItemRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MenuItemRequest {
    fn default() -> &'a MenuItemRequest {
        <MenuItemRequest as ::protobuf::Message>::default_instance()
    }
}

impl MenuItemRequest {
    pub fn new() -> MenuItemRequest {
        ::std::default::Default::default()
    }

    // optional string identifier = 1;

    pub fn identifier(&self) -> &str {
        match self.identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identifier(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::string::String) {
        self.identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
        if self.identifier.is_none() {
            self.identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::string::String {
        self.identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool query_only = 2;

    pub fn query_only(&self) -> bool {
        self.query_only.unwrap_or(false)
    }

    pub fn clear_query_only(&mut self) {
        self.query_only = ::std::option::Option::None;
    }

    pub fn has_query_only(&self) -> bool {
        self.query_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_only(&mut self, v: bool) {
        self.query_only = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identifier",
            |m: &MenuItemRequest| { &m.identifier },
            |m: &mut MenuItemRequest| { &mut m.identifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "query_only",
            |m: &MenuItemRequest| { &m.query_only },
            |m: &mut MenuItemRequest| { &mut m.query_only },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MenuItemRequest>(
            "MenuItemRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MenuItemRequest {
    const NAME: &'static str = "MenuItemRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.identifier = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.query_only = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.query_only {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.identifier.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.query_only {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MenuItemRequest {
        MenuItemRequest::new()
    }

    fn clear(&mut self) {
        self.identifier = ::std::option::Option::None;
        self.query_only = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MenuItemRequest {
        static instance: MenuItemRequest = MenuItemRequest {
            identifier: ::std::option::Option::None,
            query_only: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MenuItemRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MenuItemRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MenuItemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MenuItemRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.MenuItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MenuItemResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.MenuItemResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<menu_item_response::Status>>,
    // @@protoc_insertion_point(field:iterm2.MenuItemResponse.checked)
    pub checked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.MenuItemResponse.enabled)
    pub enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.MenuItemResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MenuItemResponse {
    fn default() -> &'a MenuItemResponse {
        <MenuItemResponse as ::protobuf::Message>::default_instance()
    }
}

impl MenuItemResponse {
    pub fn new() -> MenuItemResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.MenuItemResponse.Status status = 1;

    pub fn status(&self) -> menu_item_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(menu_item_response::Status::OK),
            None => menu_item_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: menu_item_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool checked = 2;

    pub fn checked(&self) -> bool {
        self.checked.unwrap_or(false)
    }

    pub fn clear_checked(&mut self) {
        self.checked = ::std::option::Option::None;
    }

    pub fn has_checked(&self) -> bool {
        self.checked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checked(&mut self, v: bool) {
        self.checked = ::std::option::Option::Some(v);
    }

    // optional bool enabled = 3;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &MenuItemResponse| { &m.status },
            |m: &mut MenuItemResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "checked",
            |m: &MenuItemResponse| { &m.checked },
            |m: &mut MenuItemResponse| { &mut m.checked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enabled",
            |m: &MenuItemResponse| { &m.enabled },
            |m: &mut MenuItemResponse| { &mut m.enabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MenuItemResponse>(
            "MenuItemResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MenuItemResponse {
    const NAME: &'static str = "MenuItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.checked = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.checked {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.checked {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.enabled {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MenuItemResponse {
        MenuItemResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.checked = ::std::option::Option::None;
        self.enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MenuItemResponse {
        static instance: MenuItemResponse = MenuItemResponse {
            status: ::std::option::Option::None,
            checked: ::std::option::Option::None,
            enabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MenuItemResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MenuItemResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MenuItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MenuItemResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MenuItemResponse`
pub mod menu_item_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.MenuItemResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.MenuItemResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.MenuItemResponse.Status.BAD_IDENTIFIER)
        BAD_IDENTIFIER = 1,
        // @@protoc_insertion_point(enum_value:iterm2.MenuItemResponse.Status.DISABLED)
        DISABLED = 2,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::BAD_IDENTIFIER),
                2 => ::std::option::Option::Some(Status::DISABLED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "BAD_IDENTIFIER" => ::std::option::Option::Some(Status::BAD_IDENTIFIER),
                "DISABLED" => ::std::option::Option::Some(Status::DISABLED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::BAD_IDENTIFIER,
            Status::DISABLED,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MenuItemResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("MenuItemResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.RestartSessionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RestartSessionRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.RestartSessionRequest.session_id)
    pub session_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.RestartSessionRequest.only_if_exited)
    pub only_if_exited: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.RestartSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RestartSessionRequest {
    fn default() -> &'a RestartSessionRequest {
        <RestartSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl RestartSessionRequest {
    pub fn new() -> RestartSessionRequest {
        ::std::default::Default::default()
    }

    // optional string session_id = 1;

    pub fn session_id(&self) -> &str {
        match self.session_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::string::String) {
        self.session_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
        if self.session_id.is_none() {
            self.session_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::string::String {
        self.session_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool only_if_exited = 2;

    pub fn only_if_exited(&self) -> bool {
        self.only_if_exited.unwrap_or(false)
    }

    pub fn clear_only_if_exited(&mut self) {
        self.only_if_exited = ::std::option::Option::None;
    }

    pub fn has_only_if_exited(&self) -> bool {
        self.only_if_exited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_if_exited(&mut self, v: bool) {
        self.only_if_exited = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_id",
            |m: &RestartSessionRequest| { &m.session_id },
            |m: &mut RestartSessionRequest| { &mut m.session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "only_if_exited",
            |m: &RestartSessionRequest| { &m.only_if_exited },
            |m: &mut RestartSessionRequest| { &mut m.only_if_exited },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RestartSessionRequest>(
            "RestartSessionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RestartSessionRequest {
    const NAME: &'static str = "RestartSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session_id = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.only_if_exited = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.only_if_exited {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.only_if_exited {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RestartSessionRequest {
        RestartSessionRequest::new()
    }

    fn clear(&mut self) {
        self.session_id = ::std::option::Option::None;
        self.only_if_exited = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RestartSessionRequest {
        static instance: RestartSessionRequest = RestartSessionRequest {
            session_id: ::std::option::Option::None,
            only_if_exited: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RestartSessionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RestartSessionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RestartSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestartSessionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.RestartSessionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RestartSessionResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.RestartSessionResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<restart_session_response::Status>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.RestartSessionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RestartSessionResponse {
    fn default() -> &'a RestartSessionResponse {
        <RestartSessionResponse as ::protobuf::Message>::default_instance()
    }
}

impl RestartSessionResponse {
    pub fn new() -> RestartSessionResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.RestartSessionResponse.Status status = 1;

    pub fn status(&self) -> restart_session_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(restart_session_response::Status::OK),
            None => restart_session_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: restart_session_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &RestartSessionResponse| { &m.status },
            |m: &mut RestartSessionResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RestartSessionResponse>(
            "RestartSessionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RestartSessionResponse {
    const NAME: &'static str = "RestartSessionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RestartSessionResponse {
        RestartSessionResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RestartSessionResponse {
        static instance: RestartSessionResponse = RestartSessionResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RestartSessionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RestartSessionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RestartSessionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestartSessionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RestartSessionResponse`
pub mod restart_session_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.RestartSessionResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.RestartSessionResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.RestartSessionResponse.Status.SESSION_NOT_FOUND)
        SESSION_NOT_FOUND = 1,
        // @@protoc_insertion_point(enum_value:iterm2.RestartSessionResponse.Status.SESSION_NOT_RESTARTABLE)
        SESSION_NOT_RESTARTABLE = 2,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                2 => ::std::option::Option::Some(Status::SESSION_NOT_RESTARTABLE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "SESSION_NOT_FOUND" => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                "SESSION_NOT_RESTARTABLE" => ::std::option::Option::Some(Status::SESSION_NOT_RESTARTABLE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::SESSION_NOT_FOUND,
            Status::SESSION_NOT_RESTARTABLE,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("RestartSessionResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("RestartSessionResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.ServerOriginatedRPCResultRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerOriginatedRPCResultRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ServerOriginatedRPCResultRequest.request_id)
    pub request_id: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub result: ::std::option::Option<server_originated_rpcresult_request::Result>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ServerOriginatedRPCResultRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerOriginatedRPCResultRequest {
    fn default() -> &'a ServerOriginatedRPCResultRequest {
        <ServerOriginatedRPCResultRequest as ::protobuf::Message>::default_instance()
    }
}

impl ServerOriginatedRPCResultRequest {
    pub fn new() -> ServerOriginatedRPCResultRequest {
        ::std::default::Default::default()
    }

    // optional string request_id = 1;

    pub fn request_id(&self) -> &str {
        match self.request_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: ::std::string::String) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request_id(&mut self) -> &mut ::std::string::String {
        if self.request_id.is_none() {
            self.request_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.request_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_request_id(&mut self) -> ::std::string::String {
        self.request_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string json_exception = 2;

    pub fn json_exception(&self) -> &str {
        match self.result {
            ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonException(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_json_exception(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_json_exception(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonException(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_json_exception(&mut self, v: ::std::string::String) {
        self.result = ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonException(v))
    }

    // Mutable pointer to the field.
    pub fn mut_json_exception(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonException(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonException(::std::string::String::new()));
        }
        match self.result {
            ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonException(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_json_exception(&mut self) -> ::std::string::String {
        if self.has_json_exception() {
            match self.result.take() {
                ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonException(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional string json_value = 3;

    pub fn json_value(&self) -> &str {
        match self.result {
            ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonValue(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_json_value(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_json_value(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_json_value(&mut self, v: ::std::string::String) {
        self.result = ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonValue(v))
    }

    // Mutable pointer to the field.
    pub fn mut_json_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonValue(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonValue(::std::string::String::new()));
        }
        match self.result {
            ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonValue(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_json_value(&mut self) -> ::std::string::String {
        if self.has_json_value() {
            match self.result.take() {
                ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonValue(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &ServerOriginatedRPCResultRequest| { &m.request_id },
            |m: &mut ServerOriginatedRPCResultRequest| { &mut m.request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "json_exception",
            ServerOriginatedRPCResultRequest::has_json_exception,
            ServerOriginatedRPCResultRequest::json_exception,
            ServerOriginatedRPCResultRequest::set_json_exception,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "json_value",
            ServerOriginatedRPCResultRequest::has_json_value,
            ServerOriginatedRPCResultRequest::json_value,
            ServerOriginatedRPCResultRequest::set_json_value,
        ));
        oneofs.push(server_originated_rpcresult_request::Result::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerOriginatedRPCResultRequest>(
            "ServerOriginatedRPCResultRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerOriginatedRPCResultRequest {
    const NAME: &'static str = "ServerOriginatedRPCResultRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.request_id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.result = ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonException(is.read_string()?));
                },
                26 => {
                    self.result = ::std::option::Option::Some(server_originated_rpcresult_request::Result::JsonValue(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &server_originated_rpcresult_request::Result::JsonException(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &server_originated_rpcresult_request::Result::JsonValue(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &server_originated_rpcresult_request::Result::JsonException(ref v) => {
                    os.write_string(2, v)?;
                },
                &server_originated_rpcresult_request::Result::JsonValue(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerOriginatedRPCResultRequest {
        ServerOriginatedRPCResultRequest::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerOriginatedRPCResultRequest {
        static instance: ServerOriginatedRPCResultRequest = ServerOriginatedRPCResultRequest {
            request_id: ::std::option::Option::None,
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerOriginatedRPCResultRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerOriginatedRPCResultRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerOriginatedRPCResultRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerOriginatedRPCResultRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ServerOriginatedRPCResultRequest`
pub mod server_originated_rpcresult_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.ServerOriginatedRPCResultRequest.result)
    pub enum Result {
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedRPCResultRequest.json_exception)
        JsonException(::std::string::String),
        // @@protoc_insertion_point(oneof_field:iterm2.ServerOriginatedRPCResultRequest.json_value)
        JsonValue(::std::string::String),
    }

    impl ::protobuf::Oneof for Result {
    }

    impl ::protobuf::OneofFull for Result {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ServerOriginatedRPCResultRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("result").unwrap()).clone()
        }
    }

    impl Result {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Result>("result")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.ServerOriginatedRPCResultResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerOriginatedRPCResultResponse {
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ServerOriginatedRPCResultResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerOriginatedRPCResultResponse {
    fn default() -> &'a ServerOriginatedRPCResultResponse {
        <ServerOriginatedRPCResultResponse as ::protobuf::Message>::default_instance()
    }
}

impl ServerOriginatedRPCResultResponse {
    pub fn new() -> ServerOriginatedRPCResultResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerOriginatedRPCResultResponse>(
            "ServerOriginatedRPCResultResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerOriginatedRPCResultResponse {
    const NAME: &'static str = "ServerOriginatedRPCResultResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerOriginatedRPCResultResponse {
        ServerOriginatedRPCResultResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerOriginatedRPCResultResponse {
        static instance: ServerOriginatedRPCResultResponse = ServerOriginatedRPCResultResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerOriginatedRPCResultResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerOriginatedRPCResultResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerOriginatedRPCResultResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerOriginatedRPCResultResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.ListProfilesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListProfilesRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ListProfilesRequest.properties)
    pub properties: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.ListProfilesRequest.guids)
    pub guids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ListProfilesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListProfilesRequest {
    fn default() -> &'a ListProfilesRequest {
        <ListProfilesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListProfilesRequest {
    pub fn new() -> ListProfilesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "properties",
            |m: &ListProfilesRequest| { &m.properties },
            |m: &mut ListProfilesRequest| { &mut m.properties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "guids",
            |m: &ListProfilesRequest| { &m.guids },
            |m: &mut ListProfilesRequest| { &mut m.guids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListProfilesRequest>(
            "ListProfilesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListProfilesRequest {
    const NAME: &'static str = "ListProfilesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.properties.push(is.read_string()?);
                },
                18 => {
                    self.guids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.properties {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.guids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.properties {
            os.write_string(1, &v)?;
        };
        for v in &self.guids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListProfilesRequest {
        ListProfilesRequest::new()
    }

    fn clear(&mut self) {
        self.properties.clear();
        self.guids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListProfilesRequest {
        static instance: ListProfilesRequest = ListProfilesRequest {
            properties: ::std::vec::Vec::new(),
            guids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListProfilesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListProfilesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListProfilesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListProfilesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.ListProfilesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListProfilesResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ListProfilesResponse.profiles)
    pub profiles: ::std::vec::Vec<list_profiles_response::Profile>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ListProfilesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListProfilesResponse {
    fn default() -> &'a ListProfilesResponse {
        <ListProfilesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListProfilesResponse {
    pub fn new() -> ListProfilesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "profiles",
            |m: &ListProfilesResponse| { &m.profiles },
            |m: &mut ListProfilesResponse| { &mut m.profiles },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListProfilesResponse>(
            "ListProfilesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListProfilesResponse {
    const NAME: &'static str = "ListProfilesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.profiles.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.profiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.profiles {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListProfilesResponse {
        ListProfilesResponse::new()
    }

    fn clear(&mut self) {
        self.profiles.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListProfilesResponse {
        static instance: ListProfilesResponse = ListProfilesResponse {
            profiles: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListProfilesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListProfilesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListProfilesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListProfilesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListProfilesResponse`
pub mod list_profiles_response {
    // @@protoc_insertion_point(message:iterm2.ListProfilesResponse.Profile)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Profile {
        // message fields
        // @@protoc_insertion_point(field:iterm2.ListProfilesResponse.Profile.properties)
        pub properties: ::std::vec::Vec<super::ProfileProperty>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.ListProfilesResponse.Profile.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Profile {
        fn default() -> &'a Profile {
            <Profile as ::protobuf::Message>::default_instance()
        }
    }

    impl Profile {
        pub fn new() -> Profile {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "properties",
                |m: &Profile| { &m.properties },
                |m: &mut Profile| { &mut m.properties },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Profile>(
                "ListProfilesResponse.Profile",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Profile {
        const NAME: &'static str = "Profile";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.properties.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.properties {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.properties {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Profile {
            Profile::new()
        }

        fn clear(&mut self) {
            self.properties.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Profile {
            static instance: Profile = Profile {
                properties: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Profile {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListProfilesResponse.Profile").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Profile {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Profile {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:iterm2.FocusRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FocusRequest {
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.FocusRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FocusRequest {
    fn default() -> &'a FocusRequest {
        <FocusRequest as ::protobuf::Message>::default_instance()
    }
}

impl FocusRequest {
    pub fn new() -> FocusRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FocusRequest>(
            "FocusRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FocusRequest {
    const NAME: &'static str = "FocusRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FocusRequest {
        FocusRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FocusRequest {
        static instance: FocusRequest = FocusRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FocusRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FocusRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FocusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FocusRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.FocusResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FocusResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.FocusResponse.notifications)
    pub notifications: ::std::vec::Vec<FocusChangedNotification>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.FocusResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FocusResponse {
    fn default() -> &'a FocusResponse {
        <FocusResponse as ::protobuf::Message>::default_instance()
    }
}

impl FocusResponse {
    pub fn new() -> FocusResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "notifications",
            |m: &FocusResponse| { &m.notifications },
            |m: &mut FocusResponse| { &mut m.notifications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FocusResponse>(
            "FocusResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FocusResponse {
    const NAME: &'static str = "FocusResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.notifications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.notifications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.notifications {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FocusResponse {
        FocusResponse::new()
    }

    fn clear(&mut self) {
        self.notifications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FocusResponse {
        static instance: FocusResponse = FocusResponse {
            notifications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FocusResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FocusResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FocusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FocusResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.SavedArrangementRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SavedArrangementRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SavedArrangementRequest.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.SavedArrangementRequest.action)
    pub action: ::std::option::Option<::protobuf::EnumOrUnknown<saved_arrangement_request::Action>>,
    // @@protoc_insertion_point(field:iterm2.SavedArrangementRequest.window_id)
    pub window_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SavedArrangementRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SavedArrangementRequest {
    fn default() -> &'a SavedArrangementRequest {
        <SavedArrangementRequest as ::protobuf::Message>::default_instance()
    }
}

impl SavedArrangementRequest {
    pub fn new() -> SavedArrangementRequest {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .iterm2.SavedArrangementRequest.Action action = 2;

    pub fn action(&self) -> saved_arrangement_request::Action {
        match self.action {
            Some(e) => e.enum_value_or(saved_arrangement_request::Action::RESTORE),
            None => saved_arrangement_request::Action::RESTORE,
        }
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: saved_arrangement_request::Action) {
        self.action = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string window_id = 3;

    pub fn window_id(&self) -> &str {
        match self.window_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_window_id(&mut self) {
        self.window_id = ::std::option::Option::None;
    }

    pub fn has_window_id(&self) -> bool {
        self.window_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window_id(&mut self, v: ::std::string::String) {
        self.window_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_window_id(&mut self) -> &mut ::std::string::String {
        if self.window_id.is_none() {
            self.window_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.window_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_window_id(&mut self) -> ::std::string::String {
        self.window_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &SavedArrangementRequest| { &m.name },
            |m: &mut SavedArrangementRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &SavedArrangementRequest| { &m.action },
            |m: &mut SavedArrangementRequest| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "window_id",
            |m: &SavedArrangementRequest| { &m.window_id },
            |m: &mut SavedArrangementRequest| { &mut m.window_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SavedArrangementRequest>(
            "SavedArrangementRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SavedArrangementRequest {
    const NAME: &'static str = "SavedArrangementRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.window_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.window_id.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.action {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.window_id.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SavedArrangementRequest {
        SavedArrangementRequest::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.window_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SavedArrangementRequest {
        static instance: SavedArrangementRequest = SavedArrangementRequest {
            name: ::std::option::Option::None,
            action: ::std::option::Option::None,
            window_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SavedArrangementRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SavedArrangementRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SavedArrangementRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedArrangementRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SavedArrangementRequest`
pub mod saved_arrangement_request {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.SavedArrangementRequest.Action)
    pub enum Action {
        // @@protoc_insertion_point(enum_value:iterm2.SavedArrangementRequest.Action.RESTORE)
        RESTORE = 0,
        // @@protoc_insertion_point(enum_value:iterm2.SavedArrangementRequest.Action.SAVE)
        SAVE = 1,
        // @@protoc_insertion_point(enum_value:iterm2.SavedArrangementRequest.Action.LIST)
        LIST = 2,
    }

    impl ::protobuf::Enum for Action {
        const NAME: &'static str = "Action";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Action> {
            match value {
                0 => ::std::option::Option::Some(Action::RESTORE),
                1 => ::std::option::Option::Some(Action::SAVE),
                2 => ::std::option::Option::Some(Action::LIST),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Action> {
            match str {
                "RESTORE" => ::std::option::Option::Some(Action::RESTORE),
                "SAVE" => ::std::option::Option::Some(Action::SAVE),
                "LIST" => ::std::option::Option::Some(Action::LIST),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Action] = &[
            Action::RESTORE,
            Action::SAVE,
            Action::LIST,
        ];
    }

    impl ::protobuf::EnumFull for Action {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SavedArrangementRequest.Action").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Action {
        fn default() -> Self {
            Action::RESTORE
        }
    }

    impl Action {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Action>("SavedArrangementRequest.Action")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.SavedArrangementResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SavedArrangementResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SavedArrangementResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<saved_arrangement_response::Status>>,
    // @@protoc_insertion_point(field:iterm2.SavedArrangementResponse.names)
    pub names: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SavedArrangementResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SavedArrangementResponse {
    fn default() -> &'a SavedArrangementResponse {
        <SavedArrangementResponse as ::protobuf::Message>::default_instance()
    }
}

impl SavedArrangementResponse {
    pub fn new() -> SavedArrangementResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.SavedArrangementResponse.Status status = 1;

    pub fn status(&self) -> saved_arrangement_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(saved_arrangement_response::Status::OK),
            None => saved_arrangement_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: saved_arrangement_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &SavedArrangementResponse| { &m.status },
            |m: &mut SavedArrangementResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "names",
            |m: &SavedArrangementResponse| { &m.names },
            |m: &mut SavedArrangementResponse| { &mut m.names },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SavedArrangementResponse>(
            "SavedArrangementResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SavedArrangementResponse {
    const NAME: &'static str = "SavedArrangementResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.names.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.names {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SavedArrangementResponse {
        SavedArrangementResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.names.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SavedArrangementResponse {
        static instance: SavedArrangementResponse = SavedArrangementResponse {
            status: ::std::option::Option::None,
            names: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SavedArrangementResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SavedArrangementResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SavedArrangementResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedArrangementResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SavedArrangementResponse`
pub mod saved_arrangement_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.SavedArrangementResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.SavedArrangementResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.SavedArrangementResponse.Status.ARRANGEMENT_NOT_FOUND)
        ARRANGEMENT_NOT_FOUND = 1,
        // @@protoc_insertion_point(enum_value:iterm2.SavedArrangementResponse.Status.WINDOW_NOT_FOUND)
        WINDOW_NOT_FOUND = 2,
        // @@protoc_insertion_point(enum_value:iterm2.SavedArrangementResponse.Status.REQUEST_MALFORMED)
        REQUEST_MALFORMED = 3,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::ARRANGEMENT_NOT_FOUND),
                2 => ::std::option::Option::Some(Status::WINDOW_NOT_FOUND),
                3 => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "ARRANGEMENT_NOT_FOUND" => ::std::option::Option::Some(Status::ARRANGEMENT_NOT_FOUND),
                "WINDOW_NOT_FOUND" => ::std::option::Option::Some(Status::WINDOW_NOT_FOUND),
                "REQUEST_MALFORMED" => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::ARRANGEMENT_NOT_FOUND,
            Status::WINDOW_NOT_FOUND,
            Status::REQUEST_MALFORMED,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SavedArrangementResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("SavedArrangementResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.VariableRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VariableRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.VariableRequest.set)
    pub set: ::std::vec::Vec<variable_request::Set>,
    // @@protoc_insertion_point(field:iterm2.VariableRequest.get)
    pub get: ::std::vec::Vec<::std::string::String>,
    // message oneof groups
    pub scope: ::std::option::Option<variable_request::Scope>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.VariableRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VariableRequest {
    fn default() -> &'a VariableRequest {
        <VariableRequest as ::protobuf::Message>::default_instance()
    }
}

impl VariableRequest {
    pub fn new() -> VariableRequest {
        ::std::default::Default::default()
    }

    // optional string session_id = 1;

    pub fn session_id(&self) -> &str {
        match self.scope {
            ::std::option::Option::Some(variable_request::Scope::SessionId(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_session_id(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        match self.scope {
            ::std::option::Option::Some(variable_request::Scope::SessionId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::string::String) {
        self.scope = ::std::option::Option::Some(variable_request::Scope::SessionId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(variable_request::Scope::SessionId(_)) = self.scope {
        } else {
            self.scope = ::std::option::Option::Some(variable_request::Scope::SessionId(::std::string::String::new()));
        }
        match self.scope {
            ::std::option::Option::Some(variable_request::Scope::SessionId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::string::String {
        if self.has_session_id() {
            match self.scope.take() {
                ::std::option::Option::Some(variable_request::Scope::SessionId(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional string tab_id = 4;

    pub fn tab_id(&self) -> &str {
        match self.scope {
            ::std::option::Option::Some(variable_request::Scope::TabId(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_tab_id(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_tab_id(&self) -> bool {
        match self.scope {
            ::std::option::Option::Some(variable_request::Scope::TabId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tab_id(&mut self, v: ::std::string::String) {
        self.scope = ::std::option::Option::Some(variable_request::Scope::TabId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tab_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(variable_request::Scope::TabId(_)) = self.scope {
        } else {
            self.scope = ::std::option::Option::Some(variable_request::Scope::TabId(::std::string::String::new()));
        }
        match self.scope {
            ::std::option::Option::Some(variable_request::Scope::TabId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tab_id(&mut self) -> ::std::string::String {
        if self.has_tab_id() {
            match self.scope.take() {
                ::std::option::Option::Some(variable_request::Scope::TabId(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional bool app = 5;

    pub fn app(&self) -> bool {
        match self.scope {
            ::std::option::Option::Some(variable_request::Scope::App(v)) => v,
            _ => false,
        }
    }

    pub fn clear_app(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_app(&self) -> bool {
        match self.scope {
            ::std::option::Option::Some(variable_request::Scope::App(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_app(&mut self, v: bool) {
        self.scope = ::std::option::Option::Some(variable_request::Scope::App(v))
    }

    // optional string window_id = 6;

    pub fn window_id(&self) -> &str {
        match self.scope {
            ::std::option::Option::Some(variable_request::Scope::WindowId(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_window_id(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_window_id(&self) -> bool {
        match self.scope {
            ::std::option::Option::Some(variable_request::Scope::WindowId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_window_id(&mut self, v: ::std::string::String) {
        self.scope = ::std::option::Option::Some(variable_request::Scope::WindowId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_window_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(variable_request::Scope::WindowId(_)) = self.scope {
        } else {
            self.scope = ::std::option::Option::Some(variable_request::Scope::WindowId(::std::string::String::new()));
        }
        match self.scope {
            ::std::option::Option::Some(variable_request::Scope::WindowId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_window_id(&mut self) -> ::std::string::String {
        if self.has_window_id() {
            match self.scope.take() {
                ::std::option::Option::Some(variable_request::Scope::WindowId(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "session_id",
            VariableRequest::has_session_id,
            VariableRequest::session_id,
            VariableRequest::set_session_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "tab_id",
            VariableRequest::has_tab_id,
            VariableRequest::tab_id,
            VariableRequest::set_tab_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "app",
            VariableRequest::has_app,
            VariableRequest::app,
            VariableRequest::set_app,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "window_id",
            VariableRequest::has_window_id,
            VariableRequest::window_id,
            VariableRequest::set_window_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "set",
            |m: &VariableRequest| { &m.set },
            |m: &mut VariableRequest| { &mut m.set },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "get",
            |m: &VariableRequest| { &m.get },
            |m: &mut VariableRequest| { &mut m.get },
        ));
        oneofs.push(variable_request::Scope::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VariableRequest>(
            "VariableRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VariableRequest {
    const NAME: &'static str = "VariableRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.scope = ::std::option::Option::Some(variable_request::Scope::SessionId(is.read_string()?));
                },
                34 => {
                    self.scope = ::std::option::Option::Some(variable_request::Scope::TabId(is.read_string()?));
                },
                40 => {
                    self.scope = ::std::option::Option::Some(variable_request::Scope::App(is.read_bool()?));
                },
                50 => {
                    self.scope = ::std::option::Option::Some(variable_request::Scope::WindowId(is.read_string()?));
                },
                18 => {
                    self.set.push(is.read_message()?);
                },
                26 => {
                    self.get.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.set {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.get {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.scope {
            match v {
                &variable_request::Scope::SessionId(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &variable_request::Scope::TabId(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
                &variable_request::Scope::App(v) => {
                    my_size += 1 + 1;
                },
                &variable_request::Scope::WindowId(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.set {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.get {
            os.write_string(3, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.scope {
            match v {
                &variable_request::Scope::SessionId(ref v) => {
                    os.write_string(1, v)?;
                },
                &variable_request::Scope::TabId(ref v) => {
                    os.write_string(4, v)?;
                },
                &variable_request::Scope::App(v) => {
                    os.write_bool(5, v)?;
                },
                &variable_request::Scope::WindowId(ref v) => {
                    os.write_string(6, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VariableRequest {
        VariableRequest::new()
    }

    fn clear(&mut self) {
        self.scope = ::std::option::Option::None;
        self.scope = ::std::option::Option::None;
        self.scope = ::std::option::Option::None;
        self.scope = ::std::option::Option::None;
        self.set.clear();
        self.get.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VariableRequest {
        static instance: VariableRequest = VariableRequest {
            set: ::std::vec::Vec::new(),
            get: ::std::vec::Vec::new(),
            scope: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VariableRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VariableRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VariableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VariableRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VariableRequest`
pub mod variable_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.VariableRequest.scope)
    pub enum Scope {
        // @@protoc_insertion_point(oneof_field:iterm2.VariableRequest.session_id)
        SessionId(::std::string::String),
        // @@protoc_insertion_point(oneof_field:iterm2.VariableRequest.tab_id)
        TabId(::std::string::String),
        // @@protoc_insertion_point(oneof_field:iterm2.VariableRequest.app)
        App(bool),
        // @@protoc_insertion_point(oneof_field:iterm2.VariableRequest.window_id)
        WindowId(::std::string::String),
    }

    impl ::protobuf::Oneof for Scope {
    }

    impl ::protobuf::OneofFull for Scope {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::VariableRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("scope").unwrap()).clone()
        }
    }

    impl Scope {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Scope>("scope")
        }
    }
    // @@protoc_insertion_point(message:iterm2.VariableRequest.Set)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Set {
        // message fields
        // @@protoc_insertion_point(field:iterm2.VariableRequest.Set.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.VariableRequest.Set.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.VariableRequest.Set.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Set {
        fn default() -> &'a Set {
            <Set as ::protobuf::Message>::default_instance()
        }
    }

    impl Set {
        pub fn new() -> Set {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Set| { &m.name },
                |m: &mut Set| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &Set| { &m.value },
                |m: &mut Set| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Set>(
                "VariableRequest.Set",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Set {
        const NAME: &'static str = "Set";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Set {
            Set::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Set {
            static instance: Set = Set {
                name: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Set {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("VariableRequest.Set").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Set {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Set {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:iterm2.VariableResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VariableResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.VariableResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<variable_response::Status>>,
    // @@protoc_insertion_point(field:iterm2.VariableResponse.values)
    pub values: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.VariableResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VariableResponse {
    fn default() -> &'a VariableResponse {
        <VariableResponse as ::protobuf::Message>::default_instance()
    }
}

impl VariableResponse {
    pub fn new() -> VariableResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.VariableResponse.Status status = 1;

    pub fn status(&self) -> variable_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(variable_response::Status::OK),
            None => variable_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: variable_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &VariableResponse| { &m.status },
            |m: &mut VariableResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &VariableResponse| { &m.values },
            |m: &mut VariableResponse| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VariableResponse>(
            "VariableResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VariableResponse {
    const NAME: &'static str = "VariableResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.values.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.values {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.values {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VariableResponse {
        VariableResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VariableResponse {
        static instance: VariableResponse = VariableResponse {
            status: ::std::option::Option::None,
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VariableResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VariableResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VariableResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VariableResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VariableResponse`
pub mod variable_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.VariableResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.VariableResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.VariableResponse.Status.SESSION_NOT_FOUND)
        SESSION_NOT_FOUND = 1,
        // @@protoc_insertion_point(enum_value:iterm2.VariableResponse.Status.INVALID_NAME)
        INVALID_NAME = 2,
        // @@protoc_insertion_point(enum_value:iterm2.VariableResponse.Status.MISSING_SCOPE)
        MISSING_SCOPE = 3,
        // @@protoc_insertion_point(enum_value:iterm2.VariableResponse.Status.TAB_NOT_FOUND)
        TAB_NOT_FOUND = 4,
        // @@protoc_insertion_point(enum_value:iterm2.VariableResponse.Status.MULTI_GET_DISALLOWED)
        MULTI_GET_DISALLOWED = 5,
        // @@protoc_insertion_point(enum_value:iterm2.VariableResponse.Status.WINDOW_NOT_FOUND)
        WINDOW_NOT_FOUND = 6,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                2 => ::std::option::Option::Some(Status::INVALID_NAME),
                3 => ::std::option::Option::Some(Status::MISSING_SCOPE),
                4 => ::std::option::Option::Some(Status::TAB_NOT_FOUND),
                5 => ::std::option::Option::Some(Status::MULTI_GET_DISALLOWED),
                6 => ::std::option::Option::Some(Status::WINDOW_NOT_FOUND),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "SESSION_NOT_FOUND" => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                "INVALID_NAME" => ::std::option::Option::Some(Status::INVALID_NAME),
                "MISSING_SCOPE" => ::std::option::Option::Some(Status::MISSING_SCOPE),
                "TAB_NOT_FOUND" => ::std::option::Option::Some(Status::TAB_NOT_FOUND),
                "MULTI_GET_DISALLOWED" => ::std::option::Option::Some(Status::MULTI_GET_DISALLOWED),
                "WINDOW_NOT_FOUND" => ::std::option::Option::Some(Status::WINDOW_NOT_FOUND),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::SESSION_NOT_FOUND,
            Status::INVALID_NAME,
            Status::MISSING_SCOPE,
            Status::TAB_NOT_FOUND,
            Status::MULTI_GET_DISALLOWED,
            Status::WINDOW_NOT_FOUND,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("VariableResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("VariableResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.ActivateRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActivateRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ActivateRequest.order_window_front)
    pub order_window_front: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.ActivateRequest.select_tab)
    pub select_tab: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.ActivateRequest.select_session)
    pub select_session: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.ActivateRequest.activate_app)
    pub activate_app: ::protobuf::MessageField<activate_request::App>,
    // message oneof groups
    pub identifier: ::std::option::Option<activate_request::Identifier>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ActivateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActivateRequest {
    fn default() -> &'a ActivateRequest {
        <ActivateRequest as ::protobuf::Message>::default_instance()
    }
}

impl ActivateRequest {
    pub fn new() -> ActivateRequest {
        ::std::default::Default::default()
    }

    // optional string window_id = 1;

    pub fn window_id(&self) -> &str {
        match self.identifier {
            ::std::option::Option::Some(activate_request::Identifier::WindowId(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_window_id(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_window_id(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(activate_request::Identifier::WindowId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_window_id(&mut self, v: ::std::string::String) {
        self.identifier = ::std::option::Option::Some(activate_request::Identifier::WindowId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_window_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(activate_request::Identifier::WindowId(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(activate_request::Identifier::WindowId(::std::string::String::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(activate_request::Identifier::WindowId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_window_id(&mut self) -> ::std::string::String {
        if self.has_window_id() {
            match self.identifier.take() {
                ::std::option::Option::Some(activate_request::Identifier::WindowId(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional string tab_id = 2;

    pub fn tab_id(&self) -> &str {
        match self.identifier {
            ::std::option::Option::Some(activate_request::Identifier::TabId(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_tab_id(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_tab_id(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(activate_request::Identifier::TabId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tab_id(&mut self, v: ::std::string::String) {
        self.identifier = ::std::option::Option::Some(activate_request::Identifier::TabId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tab_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(activate_request::Identifier::TabId(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(activate_request::Identifier::TabId(::std::string::String::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(activate_request::Identifier::TabId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tab_id(&mut self) -> ::std::string::String {
        if self.has_tab_id() {
            match self.identifier.take() {
                ::std::option::Option::Some(activate_request::Identifier::TabId(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional string session_id = 3;

    pub fn session_id(&self) -> &str {
        match self.identifier {
            ::std::option::Option::Some(activate_request::Identifier::SessionId(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_session_id(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(activate_request::Identifier::SessionId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::string::String) {
        self.identifier = ::std::option::Option::Some(activate_request::Identifier::SessionId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(activate_request::Identifier::SessionId(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(activate_request::Identifier::SessionId(::std::string::String::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(activate_request::Identifier::SessionId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::string::String {
        if self.has_session_id() {
            match self.identifier.take() {
                ::std::option::Option::Some(activate_request::Identifier::SessionId(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional bool order_window_front = 4;

    pub fn order_window_front(&self) -> bool {
        self.order_window_front.unwrap_or(false)
    }

    pub fn clear_order_window_front(&mut self) {
        self.order_window_front = ::std::option::Option::None;
    }

    pub fn has_order_window_front(&self) -> bool {
        self.order_window_front.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_window_front(&mut self, v: bool) {
        self.order_window_front = ::std::option::Option::Some(v);
    }

    // optional bool select_tab = 5;

    pub fn select_tab(&self) -> bool {
        self.select_tab.unwrap_or(false)
    }

    pub fn clear_select_tab(&mut self) {
        self.select_tab = ::std::option::Option::None;
    }

    pub fn has_select_tab(&self) -> bool {
        self.select_tab.is_some()
    }

    // Param is passed by value, moved
    pub fn set_select_tab(&mut self, v: bool) {
        self.select_tab = ::std::option::Option::Some(v);
    }

    // optional bool select_session = 6;

    pub fn select_session(&self) -> bool {
        self.select_session.unwrap_or(false)
    }

    pub fn clear_select_session(&mut self) {
        self.select_session = ::std::option::Option::None;
    }

    pub fn has_select_session(&self) -> bool {
        self.select_session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_select_session(&mut self, v: bool) {
        self.select_session = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "window_id",
            ActivateRequest::has_window_id,
            ActivateRequest::window_id,
            ActivateRequest::set_window_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "tab_id",
            ActivateRequest::has_tab_id,
            ActivateRequest::tab_id,
            ActivateRequest::set_tab_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "session_id",
            ActivateRequest::has_session_id,
            ActivateRequest::session_id,
            ActivateRequest::set_session_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "order_window_front",
            |m: &ActivateRequest| { &m.order_window_front },
            |m: &mut ActivateRequest| { &mut m.order_window_front },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "select_tab",
            |m: &ActivateRequest| { &m.select_tab },
            |m: &mut ActivateRequest| { &mut m.select_tab },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "select_session",
            |m: &ActivateRequest| { &m.select_session },
            |m: &mut ActivateRequest| { &mut m.select_session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, activate_request::App>(
            "activate_app",
            |m: &ActivateRequest| { &m.activate_app },
            |m: &mut ActivateRequest| { &mut m.activate_app },
        ));
        oneofs.push(activate_request::Identifier::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActivateRequest>(
            "ActivateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActivateRequest {
    const NAME: &'static str = "ActivateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.identifier = ::std::option::Option::Some(activate_request::Identifier::WindowId(is.read_string()?));
                },
                18 => {
                    self.identifier = ::std::option::Option::Some(activate_request::Identifier::TabId(is.read_string()?));
                },
                26 => {
                    self.identifier = ::std::option::Option::Some(activate_request::Identifier::SessionId(is.read_string()?));
                },
                32 => {
                    self.order_window_front = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.select_tab = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.select_session = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.activate_app)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.order_window_front {
            my_size += 1 + 1;
        }
        if let Some(v) = self.select_tab {
            my_size += 1 + 1;
        }
        if let Some(v) = self.select_session {
            my_size += 1 + 1;
        }
        if let Some(v) = self.activate_app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.identifier {
            match v {
                &activate_request::Identifier::WindowId(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &activate_request::Identifier::TabId(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &activate_request::Identifier::SessionId(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.order_window_front {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.select_tab {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.select_session {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.activate_app.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.identifier {
            match v {
                &activate_request::Identifier::WindowId(ref v) => {
                    os.write_string(1, v)?;
                },
                &activate_request::Identifier::TabId(ref v) => {
                    os.write_string(2, v)?;
                },
                &activate_request::Identifier::SessionId(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActivateRequest {
        ActivateRequest::new()
    }

    fn clear(&mut self) {
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.order_window_front = ::std::option::Option::None;
        self.select_tab = ::std::option::Option::None;
        self.select_session = ::std::option::Option::None;
        self.activate_app.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActivateRequest {
        static instance: ActivateRequest = ActivateRequest {
            order_window_front: ::std::option::Option::None,
            select_tab: ::std::option::Option::None,
            select_session: ::std::option::Option::None,
            activate_app: ::protobuf::MessageField::none(),
            identifier: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActivateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActivateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActivateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ActivateRequest`
pub mod activate_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.ActivateRequest.identifier)
    pub enum Identifier {
        // @@protoc_insertion_point(oneof_field:iterm2.ActivateRequest.window_id)
        WindowId(::std::string::String),
        // @@protoc_insertion_point(oneof_field:iterm2.ActivateRequest.tab_id)
        TabId(::std::string::String),
        // @@protoc_insertion_point(oneof_field:iterm2.ActivateRequest.session_id)
        SessionId(::std::string::String),
    }

    impl ::protobuf::Oneof for Identifier {
    }

    impl ::protobuf::OneofFull for Identifier {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ActivateRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("identifier").unwrap()).clone()
        }
    }

    impl Identifier {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Identifier>("identifier")
        }
    }
    // @@protoc_insertion_point(message:iterm2.ActivateRequest.App)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct App {
        // message fields
        // @@protoc_insertion_point(field:iterm2.ActivateRequest.App.raise_all_windows)
        pub raise_all_windows: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:iterm2.ActivateRequest.App.ignoring_other_apps)
        pub ignoring_other_apps: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.ActivateRequest.App.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a App {
        fn default() -> &'a App {
            <App as ::protobuf::Message>::default_instance()
        }
    }

    impl App {
        pub fn new() -> App {
            ::std::default::Default::default()
        }

        // optional bool raise_all_windows = 1;

        pub fn raise_all_windows(&self) -> bool {
            self.raise_all_windows.unwrap_or(false)
        }

        pub fn clear_raise_all_windows(&mut self) {
            self.raise_all_windows = ::std::option::Option::None;
        }

        pub fn has_raise_all_windows(&self) -> bool {
            self.raise_all_windows.is_some()
        }

        // Param is passed by value, moved
        pub fn set_raise_all_windows(&mut self, v: bool) {
            self.raise_all_windows = ::std::option::Option::Some(v);
        }

        // optional bool ignoring_other_apps = 2;

        pub fn ignoring_other_apps(&self) -> bool {
            self.ignoring_other_apps.unwrap_or(false)
        }

        pub fn clear_ignoring_other_apps(&mut self) {
            self.ignoring_other_apps = ::std::option::Option::None;
        }

        pub fn has_ignoring_other_apps(&self) -> bool {
            self.ignoring_other_apps.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ignoring_other_apps(&mut self, v: bool) {
            self.ignoring_other_apps = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "raise_all_windows",
                |m: &App| { &m.raise_all_windows },
                |m: &mut App| { &mut m.raise_all_windows },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ignoring_other_apps",
                |m: &App| { &m.ignoring_other_apps },
                |m: &mut App| { &mut m.ignoring_other_apps },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<App>(
                "ActivateRequest.App",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for App {
        const NAME: &'static str = "App";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.raise_all_windows = ::std::option::Option::Some(is.read_bool()?);
                    },
                    16 => {
                        self.ignoring_other_apps = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.raise_all_windows {
                my_size += 1 + 1;
            }
            if let Some(v) = self.ignoring_other_apps {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.raise_all_windows {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.ignoring_other_apps {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> App {
            App::new()
        }

        fn clear(&mut self) {
            self.raise_all_windows = ::std::option::Option::None;
            self.ignoring_other_apps = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static App {
            static instance: App = App {
                raise_all_windows: ::std::option::Option::None,
                ignoring_other_apps: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for App {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ActivateRequest.App").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for App {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for App {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:iterm2.ActivateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActivateResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ActivateResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<activate_response::Status>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ActivateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActivateResponse {
    fn default() -> &'a ActivateResponse {
        <ActivateResponse as ::protobuf::Message>::default_instance()
    }
}

impl ActivateResponse {
    pub fn new() -> ActivateResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.ActivateResponse.Status status = 1;

    pub fn status(&self) -> activate_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(activate_response::Status::OK),
            None => activate_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: activate_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &ActivateResponse| { &m.status },
            |m: &mut ActivateResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActivateResponse>(
            "ActivateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActivateResponse {
    const NAME: &'static str = "ActivateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActivateResponse {
        ActivateResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActivateResponse {
        static instance: ActivateResponse = ActivateResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActivateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActivateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActivateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ActivateResponse`
pub mod activate_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.ActivateResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.ActivateResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.ActivateResponse.Status.BAD_IDENTIFIER)
        BAD_IDENTIFIER = 1,
        // @@protoc_insertion_point(enum_value:iterm2.ActivateResponse.Status.INVALID_OPTION)
        INVALID_OPTION = 2,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::BAD_IDENTIFIER),
                2 => ::std::option::Option::Some(Status::INVALID_OPTION),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "BAD_IDENTIFIER" => ::std::option::Option::Some(Status::BAD_IDENTIFIER),
                "INVALID_OPTION" => ::std::option::Option::Some(Status::INVALID_OPTION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::BAD_IDENTIFIER,
            Status::INVALID_OPTION,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ActivateResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("ActivateResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.InjectRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InjectRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.InjectRequest.session_id)
    pub session_id: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.InjectRequest.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.InjectRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InjectRequest {
    fn default() -> &'a InjectRequest {
        <InjectRequest as ::protobuf::Message>::default_instance()
    }
}

impl InjectRequest {
    pub fn new() -> InjectRequest {
        ::std::default::Default::default()
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "session_id",
            |m: &InjectRequest| { &m.session_id },
            |m: &mut InjectRequest| { &mut m.session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &InjectRequest| { &m.data },
            |m: &mut InjectRequest| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InjectRequest>(
            "InjectRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InjectRequest {
    const NAME: &'static str = "InjectRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session_id.push(is.read_string()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.session_id {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.session_id {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InjectRequest {
        InjectRequest::new()
    }

    fn clear(&mut self) {
        self.session_id.clear();
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InjectRequest {
        static instance: InjectRequest = InjectRequest {
            session_id: ::std::vec::Vec::new(),
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InjectRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InjectRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InjectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InjectRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.InjectResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InjectResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.InjectResponse.status)
    pub status: ::std::vec::Vec<::protobuf::EnumOrUnknown<inject_response::Status>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.InjectResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InjectResponse {
    fn default() -> &'a InjectResponse {
        <InjectResponse as ::protobuf::Message>::default_instance()
    }
}

impl InjectResponse {
    pub fn new() -> InjectResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "status",
            |m: &InjectResponse| { &m.status },
            |m: &mut InjectResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InjectResponse>(
            "InjectResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InjectResponse {
    const NAME: &'static str = "InjectResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.status)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.status {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InjectResponse {
        InjectResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InjectResponse {
        static instance: InjectResponse = InjectResponse {
            status: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InjectResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InjectResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InjectResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InjectResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InjectResponse`
pub mod inject_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.InjectResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.InjectResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.InjectResponse.Status.SESSION_NOT_FOUND)
        SESSION_NOT_FOUND = 1,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "SESSION_NOT_FOUND" => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::SESSION_NOT_FOUND,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("InjectResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("InjectResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.GetPropertyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetPropertyRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.GetPropertyRequest.name)
    pub name: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub identifier: ::std::option::Option<get_property_request::Identifier>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.GetPropertyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetPropertyRequest {
    fn default() -> &'a GetPropertyRequest {
        <GetPropertyRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPropertyRequest {
    pub fn new() -> GetPropertyRequest {
        ::std::default::Default::default()
    }

    // optional string window_id = 1;

    pub fn window_id(&self) -> &str {
        match self.identifier {
            ::std::option::Option::Some(get_property_request::Identifier::WindowId(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_window_id(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_window_id(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(get_property_request::Identifier::WindowId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_window_id(&mut self, v: ::std::string::String) {
        self.identifier = ::std::option::Option::Some(get_property_request::Identifier::WindowId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_window_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(get_property_request::Identifier::WindowId(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(get_property_request::Identifier::WindowId(::std::string::String::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(get_property_request::Identifier::WindowId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_window_id(&mut self) -> ::std::string::String {
        if self.has_window_id() {
            match self.identifier.take() {
                ::std::option::Option::Some(get_property_request::Identifier::WindowId(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional string session_id = 3;

    pub fn session_id(&self) -> &str {
        match self.identifier {
            ::std::option::Option::Some(get_property_request::Identifier::SessionId(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_session_id(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(get_property_request::Identifier::SessionId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::string::String) {
        self.identifier = ::std::option::Option::Some(get_property_request::Identifier::SessionId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(get_property_request::Identifier::SessionId(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(get_property_request::Identifier::SessionId(::std::string::String::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(get_property_request::Identifier::SessionId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::string::String {
        if self.has_session_id() {
            match self.identifier.take() {
                ::std::option::Option::Some(get_property_request::Identifier::SessionId(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "window_id",
            GetPropertyRequest::has_window_id,
            GetPropertyRequest::window_id,
            GetPropertyRequest::set_window_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "session_id",
            GetPropertyRequest::has_session_id,
            GetPropertyRequest::session_id,
            GetPropertyRequest::set_session_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &GetPropertyRequest| { &m.name },
            |m: &mut GetPropertyRequest| { &mut m.name },
        ));
        oneofs.push(get_property_request::Identifier::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetPropertyRequest>(
            "GetPropertyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetPropertyRequest {
    const NAME: &'static str = "GetPropertyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.identifier = ::std::option::Option::Some(get_property_request::Identifier::WindowId(is.read_string()?));
                },
                26 => {
                    self.identifier = ::std::option::Option::Some(get_property_request::Identifier::SessionId(is.read_string()?));
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.identifier {
            match v {
                &get_property_request::Identifier::WindowId(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &get_property_request::Identifier::SessionId(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.identifier {
            match v {
                &get_property_request::Identifier::WindowId(ref v) => {
                    os.write_string(1, v)?;
                },
                &get_property_request::Identifier::SessionId(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetPropertyRequest {
        GetPropertyRequest::new()
    }

    fn clear(&mut self) {
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetPropertyRequest {
        static instance: GetPropertyRequest = GetPropertyRequest {
            name: ::std::option::Option::None,
            identifier: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetPropertyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetPropertyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetPropertyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPropertyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GetPropertyRequest`
pub mod get_property_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.GetPropertyRequest.identifier)
    pub enum Identifier {
        // @@protoc_insertion_point(oneof_field:iterm2.GetPropertyRequest.window_id)
        WindowId(::std::string::String),
        // @@protoc_insertion_point(oneof_field:iterm2.GetPropertyRequest.session_id)
        SessionId(::std::string::String),
    }

    impl ::protobuf::Oneof for Identifier {
    }

    impl ::protobuf::OneofFull for Identifier {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::GetPropertyRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("identifier").unwrap()).clone()
        }
    }

    impl Identifier {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Identifier>("identifier")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.GetPropertyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetPropertyResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.GetPropertyResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<get_property_response::Status>>,
    // @@protoc_insertion_point(field:iterm2.GetPropertyResponse.json_value)
    pub json_value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.GetPropertyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetPropertyResponse {
    fn default() -> &'a GetPropertyResponse {
        <GetPropertyResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPropertyResponse {
    pub fn new() -> GetPropertyResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.GetPropertyResponse.Status status = 1;

    pub fn status(&self) -> get_property_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(get_property_response::Status::OK),
            None => get_property_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: get_property_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string json_value = 2;

    pub fn json_value(&self) -> &str {
        match self.json_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_json_value(&mut self) {
        self.json_value = ::std::option::Option::None;
    }

    pub fn has_json_value(&self) -> bool {
        self.json_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json_value(&mut self, v: ::std::string::String) {
        self.json_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json_value(&mut self) -> &mut ::std::string::String {
        if self.json_value.is_none() {
            self.json_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.json_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_json_value(&mut self) -> ::std::string::String {
        self.json_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &GetPropertyResponse| { &m.status },
            |m: &mut GetPropertyResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "json_value",
            |m: &GetPropertyResponse| { &m.json_value },
            |m: &mut GetPropertyResponse| { &mut m.json_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetPropertyResponse>(
            "GetPropertyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetPropertyResponse {
    const NAME: &'static str = "GetPropertyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.json_value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.json_value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.json_value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetPropertyResponse {
        GetPropertyResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.json_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetPropertyResponse {
        static instance: GetPropertyResponse = GetPropertyResponse {
            status: ::std::option::Option::None,
            json_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetPropertyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetPropertyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetPropertyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPropertyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GetPropertyResponse`
pub mod get_property_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.GetPropertyResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.GetPropertyResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.GetPropertyResponse.Status.UNRECOGNIZED_NAME)
        UNRECOGNIZED_NAME = 1,
        // @@protoc_insertion_point(enum_value:iterm2.GetPropertyResponse.Status.INVALID_TARGET)
        INVALID_TARGET = 2,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::UNRECOGNIZED_NAME),
                2 => ::std::option::Option::Some(Status::INVALID_TARGET),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "UNRECOGNIZED_NAME" => ::std::option::Option::Some(Status::UNRECOGNIZED_NAME),
                "INVALID_TARGET" => ::std::option::Option::Some(Status::INVALID_TARGET),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::UNRECOGNIZED_NAME,
            Status::INVALID_TARGET,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("GetPropertyResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("GetPropertyResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.SetPropertyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetPropertyRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SetPropertyRequest.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.SetPropertyRequest.json_value)
    pub json_value: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub identifier: ::std::option::Option<set_property_request::Identifier>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SetPropertyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetPropertyRequest {
    fn default() -> &'a SetPropertyRequest {
        <SetPropertyRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetPropertyRequest {
    pub fn new() -> SetPropertyRequest {
        ::std::default::Default::default()
    }

    // optional string window_id = 1;

    pub fn window_id(&self) -> &str {
        match self.identifier {
            ::std::option::Option::Some(set_property_request::Identifier::WindowId(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_window_id(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_window_id(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(set_property_request::Identifier::WindowId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_window_id(&mut self, v: ::std::string::String) {
        self.identifier = ::std::option::Option::Some(set_property_request::Identifier::WindowId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_window_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(set_property_request::Identifier::WindowId(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(set_property_request::Identifier::WindowId(::std::string::String::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(set_property_request::Identifier::WindowId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_window_id(&mut self) -> ::std::string::String {
        if self.has_window_id() {
            match self.identifier.take() {
                ::std::option::Option::Some(set_property_request::Identifier::WindowId(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional string session_id = 5;

    pub fn session_id(&self) -> &str {
        match self.identifier {
            ::std::option::Option::Some(set_property_request::Identifier::SessionId(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_session_id(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(set_property_request::Identifier::SessionId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::string::String) {
        self.identifier = ::std::option::Option::Some(set_property_request::Identifier::SessionId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(set_property_request::Identifier::SessionId(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(set_property_request::Identifier::SessionId(::std::string::String::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(set_property_request::Identifier::SessionId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::string::String {
        if self.has_session_id() {
            match self.identifier.take() {
                ::std::option::Option::Some(set_property_request::Identifier::SessionId(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string json_value = 4;

    pub fn json_value(&self) -> &str {
        match self.json_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_json_value(&mut self) {
        self.json_value = ::std::option::Option::None;
    }

    pub fn has_json_value(&self) -> bool {
        self.json_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json_value(&mut self, v: ::std::string::String) {
        self.json_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json_value(&mut self) -> &mut ::std::string::String {
        if self.json_value.is_none() {
            self.json_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.json_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_json_value(&mut self) -> ::std::string::String {
        self.json_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "window_id",
            SetPropertyRequest::has_window_id,
            SetPropertyRequest::window_id,
            SetPropertyRequest::set_window_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "session_id",
            SetPropertyRequest::has_session_id,
            SetPropertyRequest::session_id,
            SetPropertyRequest::set_session_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &SetPropertyRequest| { &m.name },
            |m: &mut SetPropertyRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "json_value",
            |m: &SetPropertyRequest| { &m.json_value },
            |m: &mut SetPropertyRequest| { &mut m.json_value },
        ));
        oneofs.push(set_property_request::Identifier::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetPropertyRequest>(
            "SetPropertyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetPropertyRequest {
    const NAME: &'static str = "SetPropertyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.identifier = ::std::option::Option::Some(set_property_request::Identifier::WindowId(is.read_string()?));
                },
                42 => {
                    self.identifier = ::std::option::Option::Some(set_property_request::Identifier::SessionId(is.read_string()?));
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.json_value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.json_value.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.identifier {
            match v {
                &set_property_request::Identifier::WindowId(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &set_property_request::Identifier::SessionId(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.json_value.as_ref() {
            os.write_string(4, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.identifier {
            match v {
                &set_property_request::Identifier::WindowId(ref v) => {
                    os.write_string(1, v)?;
                },
                &set_property_request::Identifier::SessionId(ref v) => {
                    os.write_string(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetPropertyRequest {
        SetPropertyRequest::new()
    }

    fn clear(&mut self) {
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.json_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetPropertyRequest {
        static instance: SetPropertyRequest = SetPropertyRequest {
            name: ::std::option::Option::None,
            json_value: ::std::option::Option::None,
            identifier: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetPropertyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetPropertyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetPropertyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPropertyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SetPropertyRequest`
pub mod set_property_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.SetPropertyRequest.identifier)
    pub enum Identifier {
        // @@protoc_insertion_point(oneof_field:iterm2.SetPropertyRequest.window_id)
        WindowId(::std::string::String),
        // @@protoc_insertion_point(oneof_field:iterm2.SetPropertyRequest.session_id)
        SessionId(::std::string::String),
    }

    impl ::protobuf::Oneof for Identifier {
    }

    impl ::protobuf::OneofFull for Identifier {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::SetPropertyRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("identifier").unwrap()).clone()
        }
    }

    impl Identifier {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Identifier>("identifier")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.SetPropertyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetPropertyResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SetPropertyResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<set_property_response::Status>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SetPropertyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetPropertyResponse {
    fn default() -> &'a SetPropertyResponse {
        <SetPropertyResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetPropertyResponse {
    pub fn new() -> SetPropertyResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.SetPropertyResponse.Status status = 1;

    pub fn status(&self) -> set_property_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(set_property_response::Status::OK),
            None => set_property_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: set_property_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &SetPropertyResponse| { &m.status },
            |m: &mut SetPropertyResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetPropertyResponse>(
            "SetPropertyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetPropertyResponse {
    const NAME: &'static str = "SetPropertyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetPropertyResponse {
        SetPropertyResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetPropertyResponse {
        static instance: SetPropertyResponse = SetPropertyResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetPropertyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetPropertyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetPropertyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPropertyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SetPropertyResponse`
pub mod set_property_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.SetPropertyResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.SetPropertyResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.SetPropertyResponse.Status.UNRECOGNIZED_NAME)
        UNRECOGNIZED_NAME = 1,
        // @@protoc_insertion_point(enum_value:iterm2.SetPropertyResponse.Status.INVALID_VALUE)
        INVALID_VALUE = 2,
        // @@protoc_insertion_point(enum_value:iterm2.SetPropertyResponse.Status.INVALID_TARGET)
        INVALID_TARGET = 3,
        // @@protoc_insertion_point(enum_value:iterm2.SetPropertyResponse.Status.DEFERRED)
        DEFERRED = 4,
        // @@protoc_insertion_point(enum_value:iterm2.SetPropertyResponse.Status.IMPOSSIBLE)
        IMPOSSIBLE = 5,
        // @@protoc_insertion_point(enum_value:iterm2.SetPropertyResponse.Status.FAILED)
        FAILED = 6,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::UNRECOGNIZED_NAME),
                2 => ::std::option::Option::Some(Status::INVALID_VALUE),
                3 => ::std::option::Option::Some(Status::INVALID_TARGET),
                4 => ::std::option::Option::Some(Status::DEFERRED),
                5 => ::std::option::Option::Some(Status::IMPOSSIBLE),
                6 => ::std::option::Option::Some(Status::FAILED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "UNRECOGNIZED_NAME" => ::std::option::Option::Some(Status::UNRECOGNIZED_NAME),
                "INVALID_VALUE" => ::std::option::Option::Some(Status::INVALID_VALUE),
                "INVALID_TARGET" => ::std::option::Option::Some(Status::INVALID_TARGET),
                "DEFERRED" => ::std::option::Option::Some(Status::DEFERRED),
                "IMPOSSIBLE" => ::std::option::Option::Some(Status::IMPOSSIBLE),
                "FAILED" => ::std::option::Option::Some(Status::FAILED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::UNRECOGNIZED_NAME,
            Status::INVALID_VALUE,
            Status::INVALID_TARGET,
            Status::DEFERRED,
            Status::IMPOSSIBLE,
            Status::FAILED,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SetPropertyResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("SetPropertyResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.RegisterToolRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RegisterToolRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.RegisterToolRequest.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.RegisterToolRequest.identifier)
    pub identifier: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.RegisterToolRequest.reveal_if_already_registered)
    pub reveal_if_already_registered: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.RegisterToolRequest.tool_type)
    pub tool_type: ::std::option::Option<::protobuf::EnumOrUnknown<register_tool_request::ToolType>>,
    // @@protoc_insertion_point(field:iterm2.RegisterToolRequest.URL)
    pub URL: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.RegisterToolRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegisterToolRequest {
    fn default() -> &'a RegisterToolRequest {
        <RegisterToolRequest as ::protobuf::Message>::default_instance()
    }
}

impl RegisterToolRequest {
    pub fn new() -> RegisterToolRequest {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string identifier = 2;

    pub fn identifier(&self) -> &str {
        match self.identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identifier(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::string::String) {
        self.identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
        if self.identifier.is_none() {
            self.identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::string::String {
        self.identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool reveal_if_already_registered = 5;

    pub fn reveal_if_already_registered(&self) -> bool {
        self.reveal_if_already_registered.unwrap_or(false)
    }

    pub fn clear_reveal_if_already_registered(&mut self) {
        self.reveal_if_already_registered = ::std::option::Option::None;
    }

    pub fn has_reveal_if_already_registered(&self) -> bool {
        self.reveal_if_already_registered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reveal_if_already_registered(&mut self, v: bool) {
        self.reveal_if_already_registered = ::std::option::Option::Some(v);
    }

    // optional .iterm2.RegisterToolRequest.ToolType tool_type = 3;

    pub fn tool_type(&self) -> register_tool_request::ToolType {
        match self.tool_type {
            Some(e) => e.enum_value_or(register_tool_request::ToolType::WEB_VIEW_TOOL),
            None => register_tool_request::ToolType::WEB_VIEW_TOOL,
        }
    }

    pub fn clear_tool_type(&mut self) {
        self.tool_type = ::std::option::Option::None;
    }

    pub fn has_tool_type(&self) -> bool {
        self.tool_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_type(&mut self, v: register_tool_request::ToolType) {
        self.tool_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string URL = 4;

    pub fn URL(&self) -> &str {
        match self.URL.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_URL(&mut self) {
        self.URL = ::std::option::Option::None;
    }

    pub fn has_URL(&self) -> bool {
        self.URL.is_some()
    }

    // Param is passed by value, moved
    pub fn set_URL(&mut self, v: ::std::string::String) {
        self.URL = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_URL(&mut self) -> &mut ::std::string::String {
        if self.URL.is_none() {
            self.URL = ::std::option::Option::Some(::std::string::String::new());
        }
        self.URL.as_mut().unwrap()
    }

    // Take field
    pub fn take_URL(&mut self) -> ::std::string::String {
        self.URL.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &RegisterToolRequest| { &m.name },
            |m: &mut RegisterToolRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identifier",
            |m: &RegisterToolRequest| { &m.identifier },
            |m: &mut RegisterToolRequest| { &mut m.identifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reveal_if_already_registered",
            |m: &RegisterToolRequest| { &m.reveal_if_already_registered },
            |m: &mut RegisterToolRequest| { &mut m.reveal_if_already_registered },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tool_type",
            |m: &RegisterToolRequest| { &m.tool_type },
            |m: &mut RegisterToolRequest| { &mut m.tool_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "URL",
            |m: &RegisterToolRequest| { &m.URL },
            |m: &mut RegisterToolRequest| { &mut m.URL },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegisterToolRequest>(
            "RegisterToolRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegisterToolRequest {
    const NAME: &'static str = "RegisterToolRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.identifier = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.reveal_if_already_registered = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.tool_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.URL = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.reveal_if_already_registered {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tool_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.URL.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.identifier.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.reveal_if_already_registered {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.tool_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.URL.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegisterToolRequest {
        RegisterToolRequest::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.reveal_if_already_registered = ::std::option::Option::None;
        self.tool_type = ::std::option::Option::None;
        self.URL = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegisterToolRequest {
        static instance: RegisterToolRequest = RegisterToolRequest {
            name: ::std::option::Option::None,
            identifier: ::std::option::Option::None,
            reveal_if_already_registered: ::std::option::Option::None,
            tool_type: ::std::option::Option::None,
            URL: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegisterToolRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegisterToolRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegisterToolRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterToolRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RegisterToolRequest`
pub mod register_tool_request {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.RegisterToolRequest.ToolType)
    pub enum ToolType {
        // @@protoc_insertion_point(enum_value:iterm2.RegisterToolRequest.ToolType.WEB_VIEW_TOOL)
        WEB_VIEW_TOOL = 1,
    }

    impl ::protobuf::Enum for ToolType {
        const NAME: &'static str = "ToolType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ToolType> {
            match value {
                1 => ::std::option::Option::Some(ToolType::WEB_VIEW_TOOL),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ToolType> {
            match str {
                "WEB_VIEW_TOOL" => ::std::option::Option::Some(ToolType::WEB_VIEW_TOOL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ToolType] = &[
            ToolType::WEB_VIEW_TOOL,
        ];
    }

    impl ::protobuf::EnumFull for ToolType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("RegisterToolRequest.ToolType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                ToolType::WEB_VIEW_TOOL => 0,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for ToolType {
        fn default() -> Self {
            ToolType::WEB_VIEW_TOOL
        }
    }

    impl ToolType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ToolType>("RegisterToolRequest.ToolType")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.RPCRegistrationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RPCRegistrationRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.arguments)
    pub arguments: ::std::vec::Vec<rpcregistration_request::RPCArgumentSignature>,
    // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.defaults)
    pub defaults: ::std::vec::Vec<rpcregistration_request::RPCArgument>,
    // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.timeout)
    pub timeout: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.role)
    pub role: ::std::option::Option<::protobuf::EnumOrUnknown<rpcregistration_request::Role>>,
    // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.display_name)
    pub display_name: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub RoleSpecificAttributes: ::std::option::Option<rpcregistration_request::RoleSpecificAttributes>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.RPCRegistrationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RPCRegistrationRequest {
    fn default() -> &'a RPCRegistrationRequest {
        <RPCRegistrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl RPCRegistrationRequest {
    pub fn new() -> RPCRegistrationRequest {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float timeout = 3;

    pub fn timeout(&self) -> f32 {
        self.timeout.unwrap_or(0.)
    }

    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: f32) {
        self.timeout = ::std::option::Option::Some(v);
    }

    // optional .iterm2.RPCRegistrationRequest.Role role = 5;

    pub fn role(&self) -> rpcregistration_request::Role {
        match self.role {
            Some(e) => e.enum_value_or(rpcregistration_request::Role::GENERIC),
            None => rpcregistration_request::Role::GENERIC,
        }
    }

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: rpcregistration_request::Role) {
        self.role = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .iterm2.RPCRegistrationRequest.SessionTitleAttributes session_title_attributes = 7;

    pub fn session_title_attributes(&self) -> &rpcregistration_request::SessionTitleAttributes {
        match self.RoleSpecificAttributes {
            ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::SessionTitleAttributes(ref v)) => v,
            _ => <rpcregistration_request::SessionTitleAttributes as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_session_title_attributes(&mut self) {
        self.RoleSpecificAttributes = ::std::option::Option::None;
    }

    pub fn has_session_title_attributes(&self) -> bool {
        match self.RoleSpecificAttributes {
            ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::SessionTitleAttributes(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_session_title_attributes(&mut self, v: rpcregistration_request::SessionTitleAttributes) {
        self.RoleSpecificAttributes = ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::SessionTitleAttributes(v))
    }

    // Mutable pointer to the field.
    pub fn mut_session_title_attributes(&mut self) -> &mut rpcregistration_request::SessionTitleAttributes {
        if let ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::SessionTitleAttributes(_)) = self.RoleSpecificAttributes {
        } else {
            self.RoleSpecificAttributes = ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::SessionTitleAttributes(rpcregistration_request::SessionTitleAttributes::new()));
        }
        match self.RoleSpecificAttributes {
            ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::SessionTitleAttributes(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_session_title_attributes(&mut self) -> rpcregistration_request::SessionTitleAttributes {
        if self.has_session_title_attributes() {
            match self.RoleSpecificAttributes.take() {
                ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::SessionTitleAttributes(v)) => v,
                _ => panic!(),
            }
        } else {
            rpcregistration_request::SessionTitleAttributes::new()
        }
    }

    // optional .iterm2.RPCRegistrationRequest.StatusBarComponentAttributes status_bar_component_attributes = 8;

    pub fn status_bar_component_attributes(&self) -> &rpcregistration_request::StatusBarComponentAttributes {
        match self.RoleSpecificAttributes {
            ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::StatusBarComponentAttributes(ref v)) => v,
            _ => <rpcregistration_request::StatusBarComponentAttributes as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_status_bar_component_attributes(&mut self) {
        self.RoleSpecificAttributes = ::std::option::Option::None;
    }

    pub fn has_status_bar_component_attributes(&self) -> bool {
        match self.RoleSpecificAttributes {
            ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::StatusBarComponentAttributes(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_status_bar_component_attributes(&mut self, v: rpcregistration_request::StatusBarComponentAttributes) {
        self.RoleSpecificAttributes = ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::StatusBarComponentAttributes(v))
    }

    // Mutable pointer to the field.
    pub fn mut_status_bar_component_attributes(&mut self) -> &mut rpcregistration_request::StatusBarComponentAttributes {
        if let ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::StatusBarComponentAttributes(_)) = self.RoleSpecificAttributes {
        } else {
            self.RoleSpecificAttributes = ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::StatusBarComponentAttributes(rpcregistration_request::StatusBarComponentAttributes::new()));
        }
        match self.RoleSpecificAttributes {
            ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::StatusBarComponentAttributes(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_status_bar_component_attributes(&mut self) -> rpcregistration_request::StatusBarComponentAttributes {
        if self.has_status_bar_component_attributes() {
            match self.RoleSpecificAttributes.take() {
                ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::StatusBarComponentAttributes(v)) => v,
                _ => panic!(),
            }
        } else {
            rpcregistration_request::StatusBarComponentAttributes::new()
        }
    }

    // optional .iterm2.RPCRegistrationRequest.ContextMenuAttributes context_menu_attributes = 9;

    pub fn context_menu_attributes(&self) -> &rpcregistration_request::ContextMenuAttributes {
        match self.RoleSpecificAttributes {
            ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::ContextMenuAttributes(ref v)) => v,
            _ => <rpcregistration_request::ContextMenuAttributes as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_context_menu_attributes(&mut self) {
        self.RoleSpecificAttributes = ::std::option::Option::None;
    }

    pub fn has_context_menu_attributes(&self) -> bool {
        match self.RoleSpecificAttributes {
            ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::ContextMenuAttributes(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_context_menu_attributes(&mut self, v: rpcregistration_request::ContextMenuAttributes) {
        self.RoleSpecificAttributes = ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::ContextMenuAttributes(v))
    }

    // Mutable pointer to the field.
    pub fn mut_context_menu_attributes(&mut self) -> &mut rpcregistration_request::ContextMenuAttributes {
        if let ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::ContextMenuAttributes(_)) = self.RoleSpecificAttributes {
        } else {
            self.RoleSpecificAttributes = ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::ContextMenuAttributes(rpcregistration_request::ContextMenuAttributes::new()));
        }
        match self.RoleSpecificAttributes {
            ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::ContextMenuAttributes(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_context_menu_attributes(&mut self) -> rpcregistration_request::ContextMenuAttributes {
        if self.has_context_menu_attributes() {
            match self.RoleSpecificAttributes.take() {
                ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::ContextMenuAttributes(v)) => v,
                _ => panic!(),
            }
        } else {
            rpcregistration_request::ContextMenuAttributes::new()
        }
    }

    // optional string display_name = 6;

    pub fn display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_display_name(&mut self) {
        self.display_name = ::std::option::Option::None;
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &RPCRegistrationRequest| { &m.name },
            |m: &mut RPCRegistrationRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "arguments",
            |m: &RPCRegistrationRequest| { &m.arguments },
            |m: &mut RPCRegistrationRequest| { &mut m.arguments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "defaults",
            |m: &RPCRegistrationRequest| { &m.defaults },
            |m: &mut RPCRegistrationRequest| { &mut m.defaults },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeout",
            |m: &RPCRegistrationRequest| { &m.timeout },
            |m: &mut RPCRegistrationRequest| { &mut m.timeout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role",
            |m: &RPCRegistrationRequest| { &m.role },
            |m: &mut RPCRegistrationRequest| { &mut m.role },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, rpcregistration_request::SessionTitleAttributes>(
            "session_title_attributes",
            RPCRegistrationRequest::has_session_title_attributes,
            RPCRegistrationRequest::session_title_attributes,
            RPCRegistrationRequest::mut_session_title_attributes,
            RPCRegistrationRequest::set_session_title_attributes,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, rpcregistration_request::StatusBarComponentAttributes>(
            "status_bar_component_attributes",
            RPCRegistrationRequest::has_status_bar_component_attributes,
            RPCRegistrationRequest::status_bar_component_attributes,
            RPCRegistrationRequest::mut_status_bar_component_attributes,
            RPCRegistrationRequest::set_status_bar_component_attributes,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, rpcregistration_request::ContextMenuAttributes>(
            "context_menu_attributes",
            RPCRegistrationRequest::has_context_menu_attributes,
            RPCRegistrationRequest::context_menu_attributes,
            RPCRegistrationRequest::mut_context_menu_attributes,
            RPCRegistrationRequest::set_context_menu_attributes,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_name",
            |m: &RPCRegistrationRequest| { &m.display_name },
            |m: &mut RPCRegistrationRequest| { &mut m.display_name },
        ));
        oneofs.push(rpcregistration_request::RoleSpecificAttributes::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RPCRegistrationRequest>(
            "RPCRegistrationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RPCRegistrationRequest {
    const NAME: &'static str = "RPCRegistrationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.arguments.push(is.read_message()?);
                },
                34 => {
                    self.defaults.push(is.read_message()?);
                },
                29 => {
                    self.timeout = ::std::option::Option::Some(is.read_float()?);
                },
                40 => {
                    self.role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    self.RoleSpecificAttributes = ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::SessionTitleAttributes(is.read_message()?));
                },
                66 => {
                    self.RoleSpecificAttributes = ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::StatusBarComponentAttributes(is.read_message()?));
                },
                74 => {
                    self.RoleSpecificAttributes = ::std::option::Option::Some(rpcregistration_request::RoleSpecificAttributes::ContextMenuAttributes(is.read_message()?));
                },
                50 => {
                    self.display_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.defaults {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.timeout {
            my_size += 1 + 4;
        }
        if let Some(v) = self.role {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.display_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.RoleSpecificAttributes {
            match v {
                &rpcregistration_request::RoleSpecificAttributes::SessionTitleAttributes(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &rpcregistration_request::RoleSpecificAttributes::StatusBarComponentAttributes(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &rpcregistration_request::RoleSpecificAttributes::ContextMenuAttributes(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.arguments {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.defaults {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.timeout {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.role {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.display_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.RoleSpecificAttributes {
            match v {
                &rpcregistration_request::RoleSpecificAttributes::SessionTitleAttributes(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &rpcregistration_request::RoleSpecificAttributes::StatusBarComponentAttributes(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &rpcregistration_request::RoleSpecificAttributes::ContextMenuAttributes(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RPCRegistrationRequest {
        RPCRegistrationRequest::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.arguments.clear();
        self.defaults.clear();
        self.timeout = ::std::option::Option::None;
        self.role = ::std::option::Option::None;
        self.RoleSpecificAttributes = ::std::option::Option::None;
        self.RoleSpecificAttributes = ::std::option::Option::None;
        self.RoleSpecificAttributes = ::std::option::Option::None;
        self.display_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RPCRegistrationRequest {
        static instance: RPCRegistrationRequest = RPCRegistrationRequest {
            name: ::std::option::Option::None,
            arguments: ::std::vec::Vec::new(),
            defaults: ::std::vec::Vec::new(),
            timeout: ::std::option::Option::None,
            role: ::std::option::Option::None,
            display_name: ::std::option::Option::None,
            RoleSpecificAttributes: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RPCRegistrationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RPCRegistrationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RPCRegistrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RPCRegistrationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RPCRegistrationRequest`
pub mod rpcregistration_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.RPCRegistrationRequest.RoleSpecificAttributes)
    pub enum RoleSpecificAttributes {
        // @@protoc_insertion_point(oneof_field:iterm2.RPCRegistrationRequest.session_title_attributes)
        SessionTitleAttributes(SessionTitleAttributes),
        // @@protoc_insertion_point(oneof_field:iterm2.RPCRegistrationRequest.status_bar_component_attributes)
        StatusBarComponentAttributes(StatusBarComponentAttributes),
        // @@protoc_insertion_point(oneof_field:iterm2.RPCRegistrationRequest.context_menu_attributes)
        ContextMenuAttributes(ContextMenuAttributes),
    }

    impl ::protobuf::Oneof for RoleSpecificAttributes {
    }

    impl ::protobuf::OneofFull for RoleSpecificAttributes {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::RPCRegistrationRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("RoleSpecificAttributes").unwrap()).clone()
        }
    }

    impl RoleSpecificAttributes {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<RoleSpecificAttributes>("RoleSpecificAttributes")
        }
    }
    // @@protoc_insertion_point(message:iterm2.RPCRegistrationRequest.RPCArgumentSignature)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RPCArgumentSignature {
        // message fields
        // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.RPCArgumentSignature.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.RPCRegistrationRequest.RPCArgumentSignature.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RPCArgumentSignature {
        fn default() -> &'a RPCArgumentSignature {
            <RPCArgumentSignature as ::protobuf::Message>::default_instance()
        }
    }

    impl RPCArgumentSignature {
        pub fn new() -> RPCArgumentSignature {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &RPCArgumentSignature| { &m.name },
                |m: &mut RPCArgumentSignature| { &mut m.name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RPCArgumentSignature>(
                "RPCRegistrationRequest.RPCArgumentSignature",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RPCArgumentSignature {
        const NAME: &'static str = "RPCArgumentSignature";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RPCArgumentSignature {
            RPCArgumentSignature::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RPCArgumentSignature {
            static instance: RPCArgumentSignature = RPCArgumentSignature {
                name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RPCArgumentSignature {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("RPCRegistrationRequest.RPCArgumentSignature").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RPCArgumentSignature {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RPCArgumentSignature {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.RPCRegistrationRequest.RPCArgument)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RPCArgument {
        // message fields
        // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.RPCArgument.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.RPCArgument.path)
        pub path: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.RPCRegistrationRequest.RPCArgument.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RPCArgument {
        fn default() -> &'a RPCArgument {
            <RPCArgument as ::protobuf::Message>::default_instance()
        }
    }

    impl RPCArgument {
        pub fn new() -> RPCArgument {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string path = 2;

        pub fn path(&self) -> &str {
            match self.path.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_path(&mut self) {
            self.path = ::std::option::Option::None;
        }

        pub fn has_path(&self) -> bool {
            self.path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_path(&mut self, v: ::std::string::String) {
            self.path = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_path(&mut self) -> &mut ::std::string::String {
            if self.path.is_none() {
                self.path = ::std::option::Option::Some(::std::string::String::new());
            }
            self.path.as_mut().unwrap()
        }

        // Take field
        pub fn take_path(&mut self) -> ::std::string::String {
            self.path.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &RPCArgument| { &m.name },
                |m: &mut RPCArgument| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "path",
                |m: &RPCArgument| { &m.path },
                |m: &mut RPCArgument| { &mut m.path },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RPCArgument>(
                "RPCRegistrationRequest.RPCArgument",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RPCArgument {
        const NAME: &'static str = "RPCArgument";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.path = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.path.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.path.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RPCArgument {
            RPCArgument::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.path = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RPCArgument {
            static instance: RPCArgument = RPCArgument {
                name: ::std::option::Option::None,
                path: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RPCArgument {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("RPCRegistrationRequest.RPCArgument").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RPCArgument {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RPCArgument {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.RPCRegistrationRequest.SessionTitleAttributes)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SessionTitleAttributes {
        // message fields
        // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.SessionTitleAttributes.display_name)
        pub display_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.SessionTitleAttributes.unique_identifier)
        pub unique_identifier: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.RPCRegistrationRequest.SessionTitleAttributes.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SessionTitleAttributes {
        fn default() -> &'a SessionTitleAttributes {
            <SessionTitleAttributes as ::protobuf::Message>::default_instance()
        }
    }

    impl SessionTitleAttributes {
        pub fn new() -> SessionTitleAttributes {
            ::std::default::Default::default()
        }

        // optional string display_name = 1;

        pub fn display_name(&self) -> &str {
            match self.display_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_display_name(&mut self) {
            self.display_name = ::std::option::Option::None;
        }

        pub fn has_display_name(&self) -> bool {
            self.display_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_display_name(&mut self, v: ::std::string::String) {
            self.display_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
            if self.display_name.is_none() {
                self.display_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.display_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_display_name(&mut self) -> ::std::string::String {
            self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string unique_identifier = 6;

        pub fn unique_identifier(&self) -> &str {
            match self.unique_identifier.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_unique_identifier(&mut self) {
            self.unique_identifier = ::std::option::Option::None;
        }

        pub fn has_unique_identifier(&self) -> bool {
            self.unique_identifier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unique_identifier(&mut self, v: ::std::string::String) {
            self.unique_identifier = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_unique_identifier(&mut self) -> &mut ::std::string::String {
            if self.unique_identifier.is_none() {
                self.unique_identifier = ::std::option::Option::Some(::std::string::String::new());
            }
            self.unique_identifier.as_mut().unwrap()
        }

        // Take field
        pub fn take_unique_identifier(&mut self) -> ::std::string::String {
            self.unique_identifier.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "display_name",
                |m: &SessionTitleAttributes| { &m.display_name },
                |m: &mut SessionTitleAttributes| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "unique_identifier",
                |m: &SessionTitleAttributes| { &m.unique_identifier },
                |m: &mut SessionTitleAttributes| { &mut m.unique_identifier },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SessionTitleAttributes>(
                "RPCRegistrationRequest.SessionTitleAttributes",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SessionTitleAttributes {
        const NAME: &'static str = "SessionTitleAttributes";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.display_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.unique_identifier = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.display_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.unique_identifier.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.display_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.unique_identifier.as_ref() {
                os.write_string(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SessionTitleAttributes {
            SessionTitleAttributes::new()
        }

        fn clear(&mut self) {
            self.display_name = ::std::option::Option::None;
            self.unique_identifier = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SessionTitleAttributes {
            static instance: SessionTitleAttributes = SessionTitleAttributes {
                display_name: ::std::option::Option::None,
                unique_identifier: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SessionTitleAttributes {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("RPCRegistrationRequest.SessionTitleAttributes").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SessionTitleAttributes {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SessionTitleAttributes {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StatusBarComponentAttributes {
        // message fields
        // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.short_description)
        pub short_description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.detailed_description)
        pub detailed_description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.knobs)
        pub knobs: ::std::vec::Vec<status_bar_component_attributes::Knob>,
        // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.exemplar)
        pub exemplar: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.update_cadence)
        pub update_cadence: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.unique_identifier)
        pub unique_identifier: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.icons)
        pub icons: ::std::vec::Vec<status_bar_component_attributes::Icon>,
        // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.format)
        pub format: ::std::option::Option<::protobuf::EnumOrUnknown<status_bar_component_attributes::Format>>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StatusBarComponentAttributes {
        fn default() -> &'a StatusBarComponentAttributes {
            <StatusBarComponentAttributes as ::protobuf::Message>::default_instance()
        }
    }

    impl StatusBarComponentAttributes {
        pub fn new() -> StatusBarComponentAttributes {
            ::std::default::Default::default()
        }

        // optional string short_description = 1;

        pub fn short_description(&self) -> &str {
            match self.short_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_short_description(&mut self) {
            self.short_description = ::std::option::Option::None;
        }

        pub fn has_short_description(&self) -> bool {
            self.short_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_short_description(&mut self, v: ::std::string::String) {
            self.short_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_short_description(&mut self) -> &mut ::std::string::String {
            if self.short_description.is_none() {
                self.short_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.short_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_short_description(&mut self) -> ::std::string::String {
            self.short_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string detailed_description = 2;

        pub fn detailed_description(&self) -> &str {
            match self.detailed_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_detailed_description(&mut self) {
            self.detailed_description = ::std::option::Option::None;
        }

        pub fn has_detailed_description(&self) -> bool {
            self.detailed_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_detailed_description(&mut self, v: ::std::string::String) {
            self.detailed_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_detailed_description(&mut self) -> &mut ::std::string::String {
            if self.detailed_description.is_none() {
                self.detailed_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.detailed_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_detailed_description(&mut self) -> ::std::string::String {
            self.detailed_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string exemplar = 4;

        pub fn exemplar(&self) -> &str {
            match self.exemplar.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_exemplar(&mut self) {
            self.exemplar = ::std::option::Option::None;
        }

        pub fn has_exemplar(&self) -> bool {
            self.exemplar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_exemplar(&mut self, v: ::std::string::String) {
            self.exemplar = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_exemplar(&mut self) -> &mut ::std::string::String {
            if self.exemplar.is_none() {
                self.exemplar = ::std::option::Option::Some(::std::string::String::new());
            }
            self.exemplar.as_mut().unwrap()
        }

        // Take field
        pub fn take_exemplar(&mut self) -> ::std::string::String {
            self.exemplar.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional float update_cadence = 5;

        pub fn update_cadence(&self) -> f32 {
            self.update_cadence.unwrap_or(0.)
        }

        pub fn clear_update_cadence(&mut self) {
            self.update_cadence = ::std::option::Option::None;
        }

        pub fn has_update_cadence(&self) -> bool {
            self.update_cadence.is_some()
        }

        // Param is passed by value, moved
        pub fn set_update_cadence(&mut self, v: f32) {
            self.update_cadence = ::std::option::Option::Some(v);
        }

        // optional string unique_identifier = 6;

        pub fn unique_identifier(&self) -> &str {
            match self.unique_identifier.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_unique_identifier(&mut self) {
            self.unique_identifier = ::std::option::Option::None;
        }

        pub fn has_unique_identifier(&self) -> bool {
            self.unique_identifier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unique_identifier(&mut self, v: ::std::string::String) {
            self.unique_identifier = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_unique_identifier(&mut self) -> &mut ::std::string::String {
            if self.unique_identifier.is_none() {
                self.unique_identifier = ::std::option::Option::Some(::std::string::String::new());
            }
            self.unique_identifier.as_mut().unwrap()
        }

        // Take field
        pub fn take_unique_identifier(&mut self) -> ::std::string::String {
            self.unique_identifier.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Format format = 8;

        pub fn format(&self) -> status_bar_component_attributes::Format {
            match self.format {
                Some(e) => e.enum_value_or(status_bar_component_attributes::Format::PLAIN_TEXT),
                None => status_bar_component_attributes::Format::PLAIN_TEXT,
            }
        }

        pub fn clear_format(&mut self) {
            self.format = ::std::option::Option::None;
        }

        pub fn has_format(&self) -> bool {
            self.format.is_some()
        }

        // Param is passed by value, moved
        pub fn set_format(&mut self, v: status_bar_component_attributes::Format) {
            self.format = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "short_description",
                |m: &StatusBarComponentAttributes| { &m.short_description },
                |m: &mut StatusBarComponentAttributes| { &mut m.short_description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "detailed_description",
                |m: &StatusBarComponentAttributes| { &m.detailed_description },
                |m: &mut StatusBarComponentAttributes| { &mut m.detailed_description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "knobs",
                |m: &StatusBarComponentAttributes| { &m.knobs },
                |m: &mut StatusBarComponentAttributes| { &mut m.knobs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "exemplar",
                |m: &StatusBarComponentAttributes| { &m.exemplar },
                |m: &mut StatusBarComponentAttributes| { &mut m.exemplar },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "update_cadence",
                |m: &StatusBarComponentAttributes| { &m.update_cadence },
                |m: &mut StatusBarComponentAttributes| { &mut m.update_cadence },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "unique_identifier",
                |m: &StatusBarComponentAttributes| { &m.unique_identifier },
                |m: &mut StatusBarComponentAttributes| { &mut m.unique_identifier },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "icons",
                |m: &StatusBarComponentAttributes| { &m.icons },
                |m: &mut StatusBarComponentAttributes| { &mut m.icons },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "format",
                |m: &StatusBarComponentAttributes| { &m.format },
                |m: &mut StatusBarComponentAttributes| { &mut m.format },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatusBarComponentAttributes>(
                "RPCRegistrationRequest.StatusBarComponentAttributes",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StatusBarComponentAttributes {
        const NAME: &'static str = "StatusBarComponentAttributes";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.short_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.detailed_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.knobs.push(is.read_message()?);
                    },
                    34 => {
                        self.exemplar = ::std::option::Option::Some(is.read_string()?);
                    },
                    45 => {
                        self.update_cadence = ::std::option::Option::Some(is.read_float()?);
                    },
                    50 => {
                        self.unique_identifier = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        self.icons.push(is.read_message()?);
                    },
                    64 => {
                        self.format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.short_description.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.detailed_description.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            for value in &self.knobs {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.exemplar.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.update_cadence {
                my_size += 1 + 4;
            }
            if let Some(v) = self.unique_identifier.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            for value in &self.icons {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.format {
                my_size += ::protobuf::rt::int32_size(8, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.short_description.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.detailed_description.as_ref() {
                os.write_string(2, v)?;
            }
            for v in &self.knobs {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            if let Some(v) = self.exemplar.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.update_cadence {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.unique_identifier.as_ref() {
                os.write_string(6, v)?;
            }
            for v in &self.icons {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            };
            if let Some(v) = self.format {
                os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StatusBarComponentAttributes {
            StatusBarComponentAttributes::new()
        }

        fn clear(&mut self) {
            self.short_description = ::std::option::Option::None;
            self.detailed_description = ::std::option::Option::None;
            self.knobs.clear();
            self.exemplar = ::std::option::Option::None;
            self.update_cadence = ::std::option::Option::None;
            self.unique_identifier = ::std::option::Option::None;
            self.icons.clear();
            self.format = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StatusBarComponentAttributes {
            static instance: StatusBarComponentAttributes = StatusBarComponentAttributes {
                short_description: ::std::option::Option::None,
                detailed_description: ::std::option::Option::None,
                knobs: ::std::vec::Vec::new(),
                exemplar: ::std::option::Option::None,
                update_cadence: ::std::option::Option::None,
                unique_identifier: ::std::option::Option::None,
                icons: ::std::vec::Vec::new(),
                format: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StatusBarComponentAttributes {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("RPCRegistrationRequest.StatusBarComponentAttributes").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StatusBarComponentAttributes {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StatusBarComponentAttributes {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `StatusBarComponentAttributes`
    pub mod status_bar_component_attributes {
        // @@protoc_insertion_point(message:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Knob)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Knob {
            // message fields
            // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Knob.name)
            pub name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Knob.type)
            pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<knob::Type>>,
            // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Knob.placeholder)
            pub placeholder: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Knob.json_default_value)
            pub json_default_value: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Knob.key)
            pub key: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Knob.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Knob {
            fn default() -> &'a Knob {
                <Knob as ::protobuf::Message>::default_instance()
            }
        }

        impl Knob {
            pub fn new() -> Knob {
                ::std::default::Default::default()
            }

            // optional string name = 1;

            pub fn name(&self) -> &str {
                match self.name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_name(&mut self) {
                self.name = ::std::option::Option::None;
            }

            pub fn has_name(&self) -> bool {
                self.name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                if self.name.is_none() {
                    self.name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.name.as_mut().unwrap()
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                self.name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional .iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Knob.Type type = 2;

            pub fn type_(&self) -> knob::Type {
                match self.type_ {
                    Some(e) => e.enum_value_or(knob::Type::Checkbox),
                    None => knob::Type::Checkbox,
                }
            }

            pub fn clear_type_(&mut self) {
                self.type_ = ::std::option::Option::None;
            }

            pub fn has_type(&self) -> bool {
                self.type_.is_some()
            }

            // Param is passed by value, moved
            pub fn set_type(&mut self, v: knob::Type) {
                self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
            }

            // optional string placeholder = 3;

            pub fn placeholder(&self) -> &str {
                match self.placeholder.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_placeholder(&mut self) {
                self.placeholder = ::std::option::Option::None;
            }

            pub fn has_placeholder(&self) -> bool {
                self.placeholder.is_some()
            }

            // Param is passed by value, moved
            pub fn set_placeholder(&mut self, v: ::std::string::String) {
                self.placeholder = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_placeholder(&mut self) -> &mut ::std::string::String {
                if self.placeholder.is_none() {
                    self.placeholder = ::std::option::Option::Some(::std::string::String::new());
                }
                self.placeholder.as_mut().unwrap()
            }

            // Take field
            pub fn take_placeholder(&mut self) -> ::std::string::String {
                self.placeholder.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string json_default_value = 4;

            pub fn json_default_value(&self) -> &str {
                match self.json_default_value.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_json_default_value(&mut self) {
                self.json_default_value = ::std::option::Option::None;
            }

            pub fn has_json_default_value(&self) -> bool {
                self.json_default_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_json_default_value(&mut self, v: ::std::string::String) {
                self.json_default_value = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_json_default_value(&mut self) -> &mut ::std::string::String {
                if self.json_default_value.is_none() {
                    self.json_default_value = ::std::option::Option::Some(::std::string::String::new());
                }
                self.json_default_value.as_mut().unwrap()
            }

            // Take field
            pub fn take_json_default_value(&mut self) -> ::std::string::String {
                self.json_default_value.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string key = 5;

            pub fn key(&self) -> &str {
                match self.key.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_key(&mut self) {
                self.key = ::std::option::Option::None;
            }

            pub fn has_key(&self) -> bool {
                self.key.is_some()
            }

            // Param is passed by value, moved
            pub fn set_key(&mut self, v: ::std::string::String) {
                self.key = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_key(&mut self) -> &mut ::std::string::String {
                if self.key.is_none() {
                    self.key = ::std::option::Option::Some(::std::string::String::new());
                }
                self.key.as_mut().unwrap()
            }

            // Take field
            pub fn take_key(&mut self) -> ::std::string::String {
                self.key.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "name",
                    |m: &Knob| { &m.name },
                    |m: &mut Knob| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "type",
                    |m: &Knob| { &m.type_ },
                    |m: &mut Knob| { &mut m.type_ },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "placeholder",
                    |m: &Knob| { &m.placeholder },
                    |m: &mut Knob| { &mut m.placeholder },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "json_default_value",
                    |m: &Knob| { &m.json_default_value },
                    |m: &mut Knob| { &mut m.json_default_value },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "key",
                    |m: &Knob| { &m.key },
                    |m: &mut Knob| { &mut m.key },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Knob>(
                    "RPCRegistrationRequest.StatusBarComponentAttributes.Knob",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Knob {
            const NAME: &'static str = "Knob";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = ::std::option::Option::Some(is.read_string()?);
                        },
                        16 => {
                            self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        26 => {
                            self.placeholder = ::std::option::Option::Some(is.read_string()?);
                        },
                        34 => {
                            self.json_default_value = ::std::option::Option::Some(is.read_string()?);
                        },
                        42 => {
                            self.key = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.name.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.type_ {
                    my_size += ::protobuf::rt::int32_size(2, v.value());
                }
                if let Some(v) = self.placeholder.as_ref() {
                    my_size += ::protobuf::rt::string_size(3, &v);
                }
                if let Some(v) = self.json_default_value.as_ref() {
                    my_size += ::protobuf::rt::string_size(4, &v);
                }
                if let Some(v) = self.key.as_ref() {
                    my_size += ::protobuf::rt::string_size(5, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.name.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.type_ {
                    os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.placeholder.as_ref() {
                    os.write_string(3, v)?;
                }
                if let Some(v) = self.json_default_value.as_ref() {
                    os.write_string(4, v)?;
                }
                if let Some(v) = self.key.as_ref() {
                    os.write_string(5, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Knob {
                Knob::new()
            }

            fn clear(&mut self) {
                self.name = ::std::option::Option::None;
                self.type_ = ::std::option::Option::None;
                self.placeholder = ::std::option::Option::None;
                self.json_default_value = ::std::option::Option::None;
                self.key = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Knob {
                static instance: Knob = Knob {
                    name: ::std::option::Option::None,
                    type_: ::std::option::Option::None,
                    placeholder: ::std::option::Option::None,
                    json_default_value: ::std::option::Option::None,
                    key: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Knob {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("RPCRegistrationRequest.StatusBarComponentAttributes.Knob").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Knob {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Knob {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `Knob`
        pub mod knob {
            #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
            // @@protoc_insertion_point(enum:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Knob.Type)
            pub enum Type {
                // @@protoc_insertion_point(enum_value:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Knob.Type.Checkbox)
                Checkbox = 1,
                // @@protoc_insertion_point(enum_value:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Knob.Type.String)
                String = 2,
                // @@protoc_insertion_point(enum_value:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Knob.Type.PositiveFloatingPoint)
                PositiveFloatingPoint = 3,
                // @@protoc_insertion_point(enum_value:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Knob.Type.Color)
                Color = 4,
            }

            impl ::protobuf::Enum for Type {
                const NAME: &'static str = "Type";

                fn value(&self) -> i32 {
                    *self as i32
                }

                fn from_i32(value: i32) -> ::std::option::Option<Type> {
                    match value {
                        1 => ::std::option::Option::Some(Type::Checkbox),
                        2 => ::std::option::Option::Some(Type::String),
                        3 => ::std::option::Option::Some(Type::PositiveFloatingPoint),
                        4 => ::std::option::Option::Some(Type::Color),
                        _ => ::std::option::Option::None
                    }
                }

                fn from_str(str: &str) -> ::std::option::Option<Type> {
                    match str {
                        "Checkbox" => ::std::option::Option::Some(Type::Checkbox),
                        "String" => ::std::option::Option::Some(Type::String),
                        "PositiveFloatingPoint" => ::std::option::Option::Some(Type::PositiveFloatingPoint),
                        "Color" => ::std::option::Option::Some(Type::Color),
                        _ => ::std::option::Option::None
                    }
                }

                const VALUES: &'static [Type] = &[
                    Type::Checkbox,
                    Type::String,
                    Type::PositiveFloatingPoint,
                    Type::Color,
                ];
            }

            impl ::protobuf::EnumFull for Type {
                fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().enum_by_package_relative_name("RPCRegistrationRequest.StatusBarComponentAttributes.Knob.Type").unwrap()).clone()
                }

                fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                    let index = match self {
                        Type::Checkbox => 0,
                        Type::String => 1,
                        Type::PositiveFloatingPoint => 2,
                        Type::Color => 3,
                    };
                    Self::enum_descriptor().value_by_index(index)
                }
            }

            // Note, `Default` is implemented although default value is not 0
            impl ::std::default::Default for Type {
                fn default() -> Self {
                    Type::Checkbox
                }
            }

            impl Type {
                pub(in super::super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                    ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("RPCRegistrationRequest.StatusBarComponentAttributes.Knob.Type")
                }
            }
        }

        // @@protoc_insertion_point(message:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Icon)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Icon {
            // message fields
            // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Icon.data)
            pub data: ::std::option::Option<::std::vec::Vec<u8>>,
            // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Icon.scale)
            pub scale: ::std::option::Option<f32>,
            // special fields
            // @@protoc_insertion_point(special_field:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Icon.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Icon {
            fn default() -> &'a Icon {
                <Icon as ::protobuf::Message>::default_instance()
            }
        }

        impl Icon {
            pub fn new() -> Icon {
                ::std::default::Default::default()
            }

            // optional bytes data = 1;

            pub fn data(&self) -> &[u8] {
                match self.data.as_ref() {
                    Some(v) => v,
                    None => &[],
                }
            }

            pub fn clear_data(&mut self) {
                self.data = ::std::option::Option::None;
            }

            pub fn has_data(&self) -> bool {
                self.data.is_some()
            }

            // Param is passed by value, moved
            pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
                self.data = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
                if self.data.is_none() {
                    self.data = ::std::option::Option::Some(::std::vec::Vec::new());
                }
                self.data.as_mut().unwrap()
            }

            // Take field
            pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
                self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
            }

            // optional float scale = 2;

            pub fn scale(&self) -> f32 {
                self.scale.unwrap_or(0.)
            }

            pub fn clear_scale(&mut self) {
                self.scale = ::std::option::Option::None;
            }

            pub fn has_scale(&self) -> bool {
                self.scale.is_some()
            }

            // Param is passed by value, moved
            pub fn set_scale(&mut self, v: f32) {
                self.scale = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "data",
                    |m: &Icon| { &m.data },
                    |m: &mut Icon| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "scale",
                    |m: &Icon| { &m.scale },
                    |m: &mut Icon| { &mut m.scale },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Icon>(
                    "RPCRegistrationRequest.StatusBarComponentAttributes.Icon",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Icon {
            const NAME: &'static str = "Icon";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.data = ::std::option::Option::Some(is.read_bytes()?);
                        },
                        21 => {
                            self.scale = ::std::option::Option::Some(is.read_float()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.data.as_ref() {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                }
                if let Some(v) = self.scale {
                    my_size += 1 + 4;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.data.as_ref() {
                    os.write_bytes(1, v)?;
                }
                if let Some(v) = self.scale {
                    os.write_float(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Icon {
                Icon::new()
            }

            fn clear(&mut self) {
                self.data = ::std::option::Option::None;
                self.scale = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Icon {
                static instance: Icon = Icon {
                    data: ::std::option::Option::None,
                    scale: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Icon {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("RPCRegistrationRequest.StatusBarComponentAttributes.Icon").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Icon {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Icon {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Format)
        pub enum Format {
            // @@protoc_insertion_point(enum_value:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Format.PLAIN_TEXT)
            PLAIN_TEXT = 0,
            // @@protoc_insertion_point(enum_value:iterm2.RPCRegistrationRequest.StatusBarComponentAttributes.Format.HTML)
            HTML = 1,
        }

        impl ::protobuf::Enum for Format {
            const NAME: &'static str = "Format";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Format> {
                match value {
                    0 => ::std::option::Option::Some(Format::PLAIN_TEXT),
                    1 => ::std::option::Option::Some(Format::HTML),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Format> {
                match str {
                    "PLAIN_TEXT" => ::std::option::Option::Some(Format::PLAIN_TEXT),
                    "HTML" => ::std::option::Option::Some(Format::HTML),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Format] = &[
                Format::PLAIN_TEXT,
                Format::HTML,
            ];
        }

        impl ::protobuf::EnumFull for Format {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("RPCRegistrationRequest.StatusBarComponentAttributes.Format").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Format {
            fn default() -> Self {
                Format::PLAIN_TEXT
            }
        }

        impl Format {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Format>("RPCRegistrationRequest.StatusBarComponentAttributes.Format")
            }
        }
    }

    // @@protoc_insertion_point(message:iterm2.RPCRegistrationRequest.ContextMenuAttributes)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ContextMenuAttributes {
        // message fields
        // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.ContextMenuAttributes.display_name)
        pub display_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.RPCRegistrationRequest.ContextMenuAttributes.unique_identifier)
        pub unique_identifier: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.RPCRegistrationRequest.ContextMenuAttributes.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ContextMenuAttributes {
        fn default() -> &'a ContextMenuAttributes {
            <ContextMenuAttributes as ::protobuf::Message>::default_instance()
        }
    }

    impl ContextMenuAttributes {
        pub fn new() -> ContextMenuAttributes {
            ::std::default::Default::default()
        }

        // optional string display_name = 1;

        pub fn display_name(&self) -> &str {
            match self.display_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_display_name(&mut self) {
            self.display_name = ::std::option::Option::None;
        }

        pub fn has_display_name(&self) -> bool {
            self.display_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_display_name(&mut self, v: ::std::string::String) {
            self.display_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
            if self.display_name.is_none() {
                self.display_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.display_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_display_name(&mut self) -> ::std::string::String {
            self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string unique_identifier = 2;

        pub fn unique_identifier(&self) -> &str {
            match self.unique_identifier.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_unique_identifier(&mut self) {
            self.unique_identifier = ::std::option::Option::None;
        }

        pub fn has_unique_identifier(&self) -> bool {
            self.unique_identifier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unique_identifier(&mut self, v: ::std::string::String) {
            self.unique_identifier = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_unique_identifier(&mut self) -> &mut ::std::string::String {
            if self.unique_identifier.is_none() {
                self.unique_identifier = ::std::option::Option::Some(::std::string::String::new());
            }
            self.unique_identifier.as_mut().unwrap()
        }

        // Take field
        pub fn take_unique_identifier(&mut self) -> ::std::string::String {
            self.unique_identifier.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "display_name",
                |m: &ContextMenuAttributes| { &m.display_name },
                |m: &mut ContextMenuAttributes| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "unique_identifier",
                |m: &ContextMenuAttributes| { &m.unique_identifier },
                |m: &mut ContextMenuAttributes| { &mut m.unique_identifier },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContextMenuAttributes>(
                "RPCRegistrationRequest.ContextMenuAttributes",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ContextMenuAttributes {
        const NAME: &'static str = "ContextMenuAttributes";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.display_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.unique_identifier = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.display_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.unique_identifier.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.display_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.unique_identifier.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ContextMenuAttributes {
            ContextMenuAttributes::new()
        }

        fn clear(&mut self) {
            self.display_name = ::std::option::Option::None;
            self.unique_identifier = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ContextMenuAttributes {
            static instance: ContextMenuAttributes = ContextMenuAttributes {
                display_name: ::std::option::Option::None,
                unique_identifier: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ContextMenuAttributes {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("RPCRegistrationRequest.ContextMenuAttributes").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ContextMenuAttributes {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ContextMenuAttributes {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.RPCRegistrationRequest.Role)
    pub enum Role {
        // @@protoc_insertion_point(enum_value:iterm2.RPCRegistrationRequest.Role.GENERIC)
        GENERIC = 1,
        // @@protoc_insertion_point(enum_value:iterm2.RPCRegistrationRequest.Role.SESSION_TITLE)
        SESSION_TITLE = 2,
        // @@protoc_insertion_point(enum_value:iterm2.RPCRegistrationRequest.Role.STATUS_BAR_COMPONENT)
        STATUS_BAR_COMPONENT = 3,
        // @@protoc_insertion_point(enum_value:iterm2.RPCRegistrationRequest.Role.CONTEXT_MENU)
        CONTEXT_MENU = 4,
    }

    impl ::protobuf::Enum for Role {
        const NAME: &'static str = "Role";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Role> {
            match value {
                1 => ::std::option::Option::Some(Role::GENERIC),
                2 => ::std::option::Option::Some(Role::SESSION_TITLE),
                3 => ::std::option::Option::Some(Role::STATUS_BAR_COMPONENT),
                4 => ::std::option::Option::Some(Role::CONTEXT_MENU),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Role> {
            match str {
                "GENERIC" => ::std::option::Option::Some(Role::GENERIC),
                "SESSION_TITLE" => ::std::option::Option::Some(Role::SESSION_TITLE),
                "STATUS_BAR_COMPONENT" => ::std::option::Option::Some(Role::STATUS_BAR_COMPONENT),
                "CONTEXT_MENU" => ::std::option::Option::Some(Role::CONTEXT_MENU),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Role] = &[
            Role::GENERIC,
            Role::SESSION_TITLE,
            Role::STATUS_BAR_COMPONENT,
            Role::CONTEXT_MENU,
        ];
    }

    impl ::protobuf::EnumFull for Role {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("RPCRegistrationRequest.Role").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Role::GENERIC => 0,
                Role::SESSION_TITLE => 1,
                Role::STATUS_BAR_COMPONENT => 2,
                Role::CONTEXT_MENU => 3,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Role {
        fn default() -> Self {
            Role::GENERIC
        }
    }

    impl Role {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Role>("RPCRegistrationRequest.Role")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.RegisterToolResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RegisterToolResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.RegisterToolResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<register_tool_response::Status>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.RegisterToolResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegisterToolResponse {
    fn default() -> &'a RegisterToolResponse {
        <RegisterToolResponse as ::protobuf::Message>::default_instance()
    }
}

impl RegisterToolResponse {
    pub fn new() -> RegisterToolResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.RegisterToolResponse.Status status = 1;

    pub fn status(&self) -> register_tool_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(register_tool_response::Status::OK),
            None => register_tool_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: register_tool_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &RegisterToolResponse| { &m.status },
            |m: &mut RegisterToolResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegisterToolResponse>(
            "RegisterToolResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegisterToolResponse {
    const NAME: &'static str = "RegisterToolResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegisterToolResponse {
        RegisterToolResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegisterToolResponse {
        static instance: RegisterToolResponse = RegisterToolResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegisterToolResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegisterToolResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegisterToolResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterToolResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RegisterToolResponse`
pub mod register_tool_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.RegisterToolResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.RegisterToolResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.RegisterToolResponse.Status.REQUEST_MALFORMED)
        REQUEST_MALFORMED = 1,
        // @@protoc_insertion_point(enum_value:iterm2.RegisterToolResponse.Status.PERMISSION_DENIED)
        PERMISSION_DENIED = 2,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                2 => ::std::option::Option::Some(Status::PERMISSION_DENIED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "REQUEST_MALFORMED" => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                "PERMISSION_DENIED" => ::std::option::Option::Some(Status::PERMISSION_DENIED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::REQUEST_MALFORMED,
            Status::PERMISSION_DENIED,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("RegisterToolResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("RegisterToolResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.KeystrokePattern)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeystrokePattern {
    // message fields
    // @@protoc_insertion_point(field:iterm2.KeystrokePattern.required_modifiers)
    pub required_modifiers: ::std::vec::Vec<::protobuf::EnumOrUnknown<Modifiers>>,
    // @@protoc_insertion_point(field:iterm2.KeystrokePattern.forbidden_modifiers)
    pub forbidden_modifiers: ::std::vec::Vec<::protobuf::EnumOrUnknown<Modifiers>>,
    // @@protoc_insertion_point(field:iterm2.KeystrokePattern.keycodes)
    pub keycodes: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:iterm2.KeystrokePattern.characters)
    pub characters: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.KeystrokePattern.characters_ignoring_modifiers)
    pub characters_ignoring_modifiers: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.KeystrokePattern.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeystrokePattern {
    fn default() -> &'a KeystrokePattern {
        <KeystrokePattern as ::protobuf::Message>::default_instance()
    }
}

impl KeystrokePattern {
    pub fn new() -> KeystrokePattern {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "required_modifiers",
            |m: &KeystrokePattern| { &m.required_modifiers },
            |m: &mut KeystrokePattern| { &mut m.required_modifiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "forbidden_modifiers",
            |m: &KeystrokePattern| { &m.forbidden_modifiers },
            |m: &mut KeystrokePattern| { &mut m.forbidden_modifiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keycodes",
            |m: &KeystrokePattern| { &m.keycodes },
            |m: &mut KeystrokePattern| { &mut m.keycodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "characters",
            |m: &KeystrokePattern| { &m.characters },
            |m: &mut KeystrokePattern| { &mut m.characters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "characters_ignoring_modifiers",
            |m: &KeystrokePattern| { &m.characters_ignoring_modifiers },
            |m: &mut KeystrokePattern| { &mut m.characters_ignoring_modifiers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeystrokePattern>(
            "KeystrokePattern",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeystrokePattern {
    const NAME: &'static str = "KeystrokePattern";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.required_modifiers.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.required_modifiers)?
                },
                16 => {
                    self.forbidden_modifiers.push(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.forbidden_modifiers)?
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.keycodes)?;
                },
                24 => {
                    self.keycodes.push(is.read_int32()?);
                },
                34 => {
                    self.characters.push(is.read_string()?);
                },
                42 => {
                    self.characters_ignoring_modifiers.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.required_modifiers {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        for value in &self.forbidden_modifiers {
            my_size += ::protobuf::rt::int32_size(2, value.value());
        };
        for value in &self.keycodes {
            my_size += ::protobuf::rt::int32_size(3, *value);
        };
        for value in &self.characters {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.characters_ignoring_modifiers {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.required_modifiers {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.forbidden_modifiers {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.keycodes {
            os.write_int32(3, *v)?;
        };
        for v in &self.characters {
            os.write_string(4, &v)?;
        };
        for v in &self.characters_ignoring_modifiers {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeystrokePattern {
        KeystrokePattern::new()
    }

    fn clear(&mut self) {
        self.required_modifiers.clear();
        self.forbidden_modifiers.clear();
        self.keycodes.clear();
        self.characters.clear();
        self.characters_ignoring_modifiers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeystrokePattern {
        static instance: KeystrokePattern = KeystrokePattern {
            required_modifiers: ::std::vec::Vec::new(),
            forbidden_modifiers: ::std::vec::Vec::new(),
            keycodes: ::std::vec::Vec::new(),
            characters: ::std::vec::Vec::new(),
            characters_ignoring_modifiers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeystrokePattern {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeystrokePattern").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeystrokePattern {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeystrokePattern {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.KeystrokeMonitorRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeystrokeMonitorRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.KeystrokeMonitorRequest.patterns_to_ignore)
    pub patterns_to_ignore: ::std::vec::Vec<KeystrokePattern>,
    // @@protoc_insertion_point(field:iterm2.KeystrokeMonitorRequest.advanced)
    pub advanced: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.KeystrokeMonitorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeystrokeMonitorRequest {
    fn default() -> &'a KeystrokeMonitorRequest {
        <KeystrokeMonitorRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeystrokeMonitorRequest {
    pub fn new() -> KeystrokeMonitorRequest {
        ::std::default::Default::default()
    }

    // optional bool advanced = 2;

    pub fn advanced(&self) -> bool {
        self.advanced.unwrap_or(false)
    }

    pub fn clear_advanced(&mut self) {
        self.advanced = ::std::option::Option::None;
    }

    pub fn has_advanced(&self) -> bool {
        self.advanced.is_some()
    }

    // Param is passed by value, moved
    pub fn set_advanced(&mut self, v: bool) {
        self.advanced = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "patterns_to_ignore",
            |m: &KeystrokeMonitorRequest| { &m.patterns_to_ignore },
            |m: &mut KeystrokeMonitorRequest| { &mut m.patterns_to_ignore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "advanced",
            |m: &KeystrokeMonitorRequest| { &m.advanced },
            |m: &mut KeystrokeMonitorRequest| { &mut m.advanced },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeystrokeMonitorRequest>(
            "KeystrokeMonitorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeystrokeMonitorRequest {
    const NAME: &'static str = "KeystrokeMonitorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.patterns_to_ignore.push(is.read_message()?);
                },
                16 => {
                    self.advanced = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.patterns_to_ignore {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.advanced {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.patterns_to_ignore {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.advanced {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeystrokeMonitorRequest {
        KeystrokeMonitorRequest::new()
    }

    fn clear(&mut self) {
        self.patterns_to_ignore.clear();
        self.advanced = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeystrokeMonitorRequest {
        static instance: KeystrokeMonitorRequest = KeystrokeMonitorRequest {
            patterns_to_ignore: ::std::vec::Vec::new(),
            advanced: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeystrokeMonitorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeystrokeMonitorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeystrokeMonitorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeystrokeMonitorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.KeystrokeFilterRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeystrokeFilterRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.KeystrokeFilterRequest.patterns_to_ignore)
    pub patterns_to_ignore: ::std::vec::Vec<KeystrokePattern>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.KeystrokeFilterRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeystrokeFilterRequest {
    fn default() -> &'a KeystrokeFilterRequest {
        <KeystrokeFilterRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeystrokeFilterRequest {
    pub fn new() -> KeystrokeFilterRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "patterns_to_ignore",
            |m: &KeystrokeFilterRequest| { &m.patterns_to_ignore },
            |m: &mut KeystrokeFilterRequest| { &mut m.patterns_to_ignore },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeystrokeFilterRequest>(
            "KeystrokeFilterRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeystrokeFilterRequest {
    const NAME: &'static str = "KeystrokeFilterRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.patterns_to_ignore.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.patterns_to_ignore {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.patterns_to_ignore {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeystrokeFilterRequest {
        KeystrokeFilterRequest::new()
    }

    fn clear(&mut self) {
        self.patterns_to_ignore.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeystrokeFilterRequest {
        static instance: KeystrokeFilterRequest = KeystrokeFilterRequest {
            patterns_to_ignore: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeystrokeFilterRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeystrokeFilterRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeystrokeFilterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeystrokeFilterRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.VariableMonitorRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VariableMonitorRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.VariableMonitorRequest.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.VariableMonitorRequest.scope)
    pub scope: ::std::option::Option<::protobuf::EnumOrUnknown<VariableScope>>,
    // @@protoc_insertion_point(field:iterm2.VariableMonitorRequest.identifier)
    pub identifier: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.VariableMonitorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VariableMonitorRequest {
    fn default() -> &'a VariableMonitorRequest {
        <VariableMonitorRequest as ::protobuf::Message>::default_instance()
    }
}

impl VariableMonitorRequest {
    pub fn new() -> VariableMonitorRequest {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .iterm2.VariableScope scope = 2;

    pub fn scope(&self) -> VariableScope {
        match self.scope {
            Some(e) => e.enum_value_or(VariableScope::SESSION),
            None => VariableScope::SESSION,
        }
    }

    pub fn clear_scope(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_scope(&self) -> bool {
        self.scope.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: VariableScope) {
        self.scope = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string identifier = 3;

    pub fn identifier(&self) -> &str {
        match self.identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identifier(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::string::String) {
        self.identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
        if self.identifier.is_none() {
            self.identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::string::String {
        self.identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &VariableMonitorRequest| { &m.name },
            |m: &mut VariableMonitorRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scope",
            |m: &VariableMonitorRequest| { &m.scope },
            |m: &mut VariableMonitorRequest| { &mut m.scope },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identifier",
            |m: &VariableMonitorRequest| { &m.identifier },
            |m: &mut VariableMonitorRequest| { &mut m.identifier },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VariableMonitorRequest>(
            "VariableMonitorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VariableMonitorRequest {
    const NAME: &'static str = "VariableMonitorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.scope = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.identifier = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.scope {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.scope {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.identifier.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VariableMonitorRequest {
        VariableMonitorRequest::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.scope = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VariableMonitorRequest {
        static instance: VariableMonitorRequest = VariableMonitorRequest {
            name: ::std::option::Option::None,
            scope: ::std::option::Option::None,
            identifier: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VariableMonitorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VariableMonitorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VariableMonitorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VariableMonitorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.ProfileChangeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProfileChangeRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ProfileChangeRequest.guid)
    pub guid: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ProfileChangeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProfileChangeRequest {
    fn default() -> &'a ProfileChangeRequest {
        <ProfileChangeRequest as ::protobuf::Message>::default_instance()
    }
}

impl ProfileChangeRequest {
    pub fn new() -> ProfileChangeRequest {
        ::std::default::Default::default()
    }

    // optional string guid = 1;

    pub fn guid(&self) -> &str {
        match self.guid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_guid(&mut self) {
        self.guid = ::std::option::Option::None;
    }

    pub fn has_guid(&self) -> bool {
        self.guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid(&mut self, v: ::std::string::String) {
        self.guid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid(&mut self) -> &mut ::std::string::String {
        if self.guid.is_none() {
            self.guid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.guid.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid(&mut self) -> ::std::string::String {
        self.guid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guid",
            |m: &ProfileChangeRequest| { &m.guid },
            |m: &mut ProfileChangeRequest| { &mut m.guid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProfileChangeRequest>(
            "ProfileChangeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProfileChangeRequest {
    const NAME: &'static str = "ProfileChangeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.guid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guid.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProfileChangeRequest {
        ProfileChangeRequest::new()
    }

    fn clear(&mut self) {
        self.guid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProfileChangeRequest {
        static instance: ProfileChangeRequest = ProfileChangeRequest {
            guid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProfileChangeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProfileChangeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProfileChangeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProfileChangeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.PromptMonitorRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PromptMonitorRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.PromptMonitorRequest.modes)
    pub modes: ::std::vec::Vec<::protobuf::EnumOrUnknown<PromptMonitorMode>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.PromptMonitorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PromptMonitorRequest {
    fn default() -> &'a PromptMonitorRequest {
        <PromptMonitorRequest as ::protobuf::Message>::default_instance()
    }
}

impl PromptMonitorRequest {
    pub fn new() -> PromptMonitorRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modes",
            |m: &PromptMonitorRequest| { &m.modes },
            |m: &mut PromptMonitorRequest| { &mut m.modes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PromptMonitorRequest>(
            "PromptMonitorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PromptMonitorRequest {
    const NAME: &'static str = "PromptMonitorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.modes.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.modes)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.modes {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.modes {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PromptMonitorRequest {
        PromptMonitorRequest::new()
    }

    fn clear(&mut self) {
        self.modes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PromptMonitorRequest {
        static instance: PromptMonitorRequest = PromptMonitorRequest {
            modes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PromptMonitorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PromptMonitorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PromptMonitorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PromptMonitorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.NotificationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NotificationRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.NotificationRequest.session)
    pub session: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.NotificationRequest.subscribe)
    pub subscribe: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.NotificationRequest.notification_type)
    pub notification_type: ::std::option::Option<::protobuf::EnumOrUnknown<NotificationType>>,
    // message oneof groups
    pub arguments: ::std::option::Option<notification_request::Arguments>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.NotificationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NotificationRequest {
    fn default() -> &'a NotificationRequest {
        <NotificationRequest as ::protobuf::Message>::default_instance()
    }
}

impl NotificationRequest {
    pub fn new() -> NotificationRequest {
        ::std::default::Default::default()
    }

    // optional string session = 1;

    pub fn session(&self) -> &str {
        match self.session.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::string::String) {
        self.session = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session(&mut self) -> &mut ::std::string::String {
        if self.session.is_none() {
            self.session = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session.as_mut().unwrap()
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::string::String {
        self.session.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool subscribe = 2;

    pub fn subscribe(&self) -> bool {
        self.subscribe.unwrap_or(false)
    }

    pub fn clear_subscribe(&mut self) {
        self.subscribe = ::std::option::Option::None;
    }

    pub fn has_subscribe(&self) -> bool {
        self.subscribe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribe(&mut self, v: bool) {
        self.subscribe = ::std::option::Option::Some(v);
    }

    // optional .iterm2.NotificationType notification_type = 3;

    pub fn notification_type(&self) -> NotificationType {
        match self.notification_type {
            Some(e) => e.enum_value_or(NotificationType::NOTIFY_ON_KEYSTROKE),
            None => NotificationType::NOTIFY_ON_KEYSTROKE,
        }
    }

    pub fn clear_notification_type(&mut self) {
        self.notification_type = ::std::option::Option::None;
    }

    pub fn has_notification_type(&self) -> bool {
        self.notification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_type(&mut self, v: NotificationType) {
        self.notification_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .iterm2.RPCRegistrationRequest rpc_registration_request = 4;

    pub fn rpc_registration_request(&self) -> &RPCRegistrationRequest {
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::RpcRegistrationRequest(ref v)) => v,
            _ => <RPCRegistrationRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_rpc_registration_request(&mut self) {
        self.arguments = ::std::option::Option::None;
    }

    pub fn has_rpc_registration_request(&self) -> bool {
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::RpcRegistrationRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rpc_registration_request(&mut self, v: RPCRegistrationRequest) {
        self.arguments = ::std::option::Option::Some(notification_request::Arguments::RpcRegistrationRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rpc_registration_request(&mut self) -> &mut RPCRegistrationRequest {
        if let ::std::option::Option::Some(notification_request::Arguments::RpcRegistrationRequest(_)) = self.arguments {
        } else {
            self.arguments = ::std::option::Option::Some(notification_request::Arguments::RpcRegistrationRequest(RPCRegistrationRequest::new()));
        }
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::RpcRegistrationRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rpc_registration_request(&mut self) -> RPCRegistrationRequest {
        if self.has_rpc_registration_request() {
            match self.arguments.take() {
                ::std::option::Option::Some(notification_request::Arguments::RpcRegistrationRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            RPCRegistrationRequest::new()
        }
    }

    // optional .iterm2.KeystrokeMonitorRequest keystroke_monitor_request = 5;

    pub fn keystroke_monitor_request(&self) -> &KeystrokeMonitorRequest {
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::KeystrokeMonitorRequest(ref v)) => v,
            _ => <KeystrokeMonitorRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_keystroke_monitor_request(&mut self) {
        self.arguments = ::std::option::Option::None;
    }

    pub fn has_keystroke_monitor_request(&self) -> bool {
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::KeystrokeMonitorRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_keystroke_monitor_request(&mut self, v: KeystrokeMonitorRequest) {
        self.arguments = ::std::option::Option::Some(notification_request::Arguments::KeystrokeMonitorRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_keystroke_monitor_request(&mut self) -> &mut KeystrokeMonitorRequest {
        if let ::std::option::Option::Some(notification_request::Arguments::KeystrokeMonitorRequest(_)) = self.arguments {
        } else {
            self.arguments = ::std::option::Option::Some(notification_request::Arguments::KeystrokeMonitorRequest(KeystrokeMonitorRequest::new()));
        }
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::KeystrokeMonitorRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_keystroke_monitor_request(&mut self) -> KeystrokeMonitorRequest {
        if self.has_keystroke_monitor_request() {
            match self.arguments.take() {
                ::std::option::Option::Some(notification_request::Arguments::KeystrokeMonitorRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            KeystrokeMonitorRequest::new()
        }
    }

    // optional .iterm2.VariableMonitorRequest variable_monitor_request = 6;

    pub fn variable_monitor_request(&self) -> &VariableMonitorRequest {
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::VariableMonitorRequest(ref v)) => v,
            _ => <VariableMonitorRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_variable_monitor_request(&mut self) {
        self.arguments = ::std::option::Option::None;
    }

    pub fn has_variable_monitor_request(&self) -> bool {
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::VariableMonitorRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_variable_monitor_request(&mut self, v: VariableMonitorRequest) {
        self.arguments = ::std::option::Option::Some(notification_request::Arguments::VariableMonitorRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_variable_monitor_request(&mut self) -> &mut VariableMonitorRequest {
        if let ::std::option::Option::Some(notification_request::Arguments::VariableMonitorRequest(_)) = self.arguments {
        } else {
            self.arguments = ::std::option::Option::Some(notification_request::Arguments::VariableMonitorRequest(VariableMonitorRequest::new()));
        }
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::VariableMonitorRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_variable_monitor_request(&mut self) -> VariableMonitorRequest {
        if self.has_variable_monitor_request() {
            match self.arguments.take() {
                ::std::option::Option::Some(notification_request::Arguments::VariableMonitorRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            VariableMonitorRequest::new()
        }
    }

    // optional .iterm2.ProfileChangeRequest profile_change_request = 7;

    pub fn profile_change_request(&self) -> &ProfileChangeRequest {
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::ProfileChangeRequest(ref v)) => v,
            _ => <ProfileChangeRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_profile_change_request(&mut self) {
        self.arguments = ::std::option::Option::None;
    }

    pub fn has_profile_change_request(&self) -> bool {
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::ProfileChangeRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_profile_change_request(&mut self, v: ProfileChangeRequest) {
        self.arguments = ::std::option::Option::Some(notification_request::Arguments::ProfileChangeRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_profile_change_request(&mut self) -> &mut ProfileChangeRequest {
        if let ::std::option::Option::Some(notification_request::Arguments::ProfileChangeRequest(_)) = self.arguments {
        } else {
            self.arguments = ::std::option::Option::Some(notification_request::Arguments::ProfileChangeRequest(ProfileChangeRequest::new()));
        }
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::ProfileChangeRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_profile_change_request(&mut self) -> ProfileChangeRequest {
        if self.has_profile_change_request() {
            match self.arguments.take() {
                ::std::option::Option::Some(notification_request::Arguments::ProfileChangeRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            ProfileChangeRequest::new()
        }
    }

    // optional .iterm2.KeystrokeFilterRequest keystroke_filter_request = 8;

    pub fn keystroke_filter_request(&self) -> &KeystrokeFilterRequest {
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::KeystrokeFilterRequest(ref v)) => v,
            _ => <KeystrokeFilterRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_keystroke_filter_request(&mut self) {
        self.arguments = ::std::option::Option::None;
    }

    pub fn has_keystroke_filter_request(&self) -> bool {
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::KeystrokeFilterRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_keystroke_filter_request(&mut self, v: KeystrokeFilterRequest) {
        self.arguments = ::std::option::Option::Some(notification_request::Arguments::KeystrokeFilterRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_keystroke_filter_request(&mut self) -> &mut KeystrokeFilterRequest {
        if let ::std::option::Option::Some(notification_request::Arguments::KeystrokeFilterRequest(_)) = self.arguments {
        } else {
            self.arguments = ::std::option::Option::Some(notification_request::Arguments::KeystrokeFilterRequest(KeystrokeFilterRequest::new()));
        }
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::KeystrokeFilterRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_keystroke_filter_request(&mut self) -> KeystrokeFilterRequest {
        if self.has_keystroke_filter_request() {
            match self.arguments.take() {
                ::std::option::Option::Some(notification_request::Arguments::KeystrokeFilterRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            KeystrokeFilterRequest::new()
        }
    }

    // optional .iterm2.PromptMonitorRequest prompt_monitor_request = 9;

    pub fn prompt_monitor_request(&self) -> &PromptMonitorRequest {
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::PromptMonitorRequest(ref v)) => v,
            _ => <PromptMonitorRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_prompt_monitor_request(&mut self) {
        self.arguments = ::std::option::Option::None;
    }

    pub fn has_prompt_monitor_request(&self) -> bool {
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::PromptMonitorRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prompt_monitor_request(&mut self, v: PromptMonitorRequest) {
        self.arguments = ::std::option::Option::Some(notification_request::Arguments::PromptMonitorRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_prompt_monitor_request(&mut self) -> &mut PromptMonitorRequest {
        if let ::std::option::Option::Some(notification_request::Arguments::PromptMonitorRequest(_)) = self.arguments {
        } else {
            self.arguments = ::std::option::Option::Some(notification_request::Arguments::PromptMonitorRequest(PromptMonitorRequest::new()));
        }
        match self.arguments {
            ::std::option::Option::Some(notification_request::Arguments::PromptMonitorRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_prompt_monitor_request(&mut self) -> PromptMonitorRequest {
        if self.has_prompt_monitor_request() {
            match self.arguments.take() {
                ::std::option::Option::Some(notification_request::Arguments::PromptMonitorRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            PromptMonitorRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &NotificationRequest| { &m.session },
            |m: &mut NotificationRequest| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subscribe",
            |m: &NotificationRequest| { &m.subscribe },
            |m: &mut NotificationRequest| { &mut m.subscribe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "notification_type",
            |m: &NotificationRequest| { &m.notification_type },
            |m: &mut NotificationRequest| { &mut m.notification_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RPCRegistrationRequest>(
            "rpc_registration_request",
            NotificationRequest::has_rpc_registration_request,
            NotificationRequest::rpc_registration_request,
            NotificationRequest::mut_rpc_registration_request,
            NotificationRequest::set_rpc_registration_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, KeystrokeMonitorRequest>(
            "keystroke_monitor_request",
            NotificationRequest::has_keystroke_monitor_request,
            NotificationRequest::keystroke_monitor_request,
            NotificationRequest::mut_keystroke_monitor_request,
            NotificationRequest::set_keystroke_monitor_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VariableMonitorRequest>(
            "variable_monitor_request",
            NotificationRequest::has_variable_monitor_request,
            NotificationRequest::variable_monitor_request,
            NotificationRequest::mut_variable_monitor_request,
            NotificationRequest::set_variable_monitor_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ProfileChangeRequest>(
            "profile_change_request",
            NotificationRequest::has_profile_change_request,
            NotificationRequest::profile_change_request,
            NotificationRequest::mut_profile_change_request,
            NotificationRequest::set_profile_change_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, KeystrokeFilterRequest>(
            "keystroke_filter_request",
            NotificationRequest::has_keystroke_filter_request,
            NotificationRequest::keystroke_filter_request,
            NotificationRequest::mut_keystroke_filter_request,
            NotificationRequest::set_keystroke_filter_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PromptMonitorRequest>(
            "prompt_monitor_request",
            NotificationRequest::has_prompt_monitor_request,
            NotificationRequest::prompt_monitor_request,
            NotificationRequest::mut_prompt_monitor_request,
            NotificationRequest::set_prompt_monitor_request,
        ));
        oneofs.push(notification_request::Arguments::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NotificationRequest>(
            "NotificationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NotificationRequest {
    const NAME: &'static str = "NotificationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.subscribe = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.notification_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.arguments = ::std::option::Option::Some(notification_request::Arguments::RpcRegistrationRequest(is.read_message()?));
                },
                42 => {
                    self.arguments = ::std::option::Option::Some(notification_request::Arguments::KeystrokeMonitorRequest(is.read_message()?));
                },
                50 => {
                    self.arguments = ::std::option::Option::Some(notification_request::Arguments::VariableMonitorRequest(is.read_message()?));
                },
                58 => {
                    self.arguments = ::std::option::Option::Some(notification_request::Arguments::ProfileChangeRequest(is.read_message()?));
                },
                66 => {
                    self.arguments = ::std::option::Option::Some(notification_request::Arguments::KeystrokeFilterRequest(is.read_message()?));
                },
                74 => {
                    self.arguments = ::std::option::Option::Some(notification_request::Arguments::PromptMonitorRequest(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.subscribe {
            my_size += 1 + 1;
        }
        if let Some(v) = self.notification_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let ::std::option::Option::Some(ref v) = self.arguments {
            match v {
                &notification_request::Arguments::RpcRegistrationRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &notification_request::Arguments::KeystrokeMonitorRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &notification_request::Arguments::VariableMonitorRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &notification_request::Arguments::ProfileChangeRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &notification_request::Arguments::KeystrokeFilterRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &notification_request::Arguments::PromptMonitorRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.subscribe {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.notification_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let ::std::option::Option::Some(ref v) = self.arguments {
            match v {
                &notification_request::Arguments::RpcRegistrationRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &notification_request::Arguments::KeystrokeMonitorRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &notification_request::Arguments::VariableMonitorRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &notification_request::Arguments::ProfileChangeRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &notification_request::Arguments::KeystrokeFilterRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &notification_request::Arguments::PromptMonitorRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NotificationRequest {
        NotificationRequest::new()
    }

    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.subscribe = ::std::option::Option::None;
        self.notification_type = ::std::option::Option::None;
        self.arguments = ::std::option::Option::None;
        self.arguments = ::std::option::Option::None;
        self.arguments = ::std::option::Option::None;
        self.arguments = ::std::option::Option::None;
        self.arguments = ::std::option::Option::None;
        self.arguments = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NotificationRequest {
        static instance: NotificationRequest = NotificationRequest {
            session: ::std::option::Option::None,
            subscribe: ::std::option::Option::None,
            notification_type: ::std::option::Option::None,
            arguments: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NotificationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NotificationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NotificationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NotificationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NotificationRequest`
pub mod notification_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.NotificationRequest.arguments)
    pub enum Arguments {
        // @@protoc_insertion_point(oneof_field:iterm2.NotificationRequest.rpc_registration_request)
        RpcRegistrationRequest(super::RPCRegistrationRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.NotificationRequest.keystroke_monitor_request)
        KeystrokeMonitorRequest(super::KeystrokeMonitorRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.NotificationRequest.variable_monitor_request)
        VariableMonitorRequest(super::VariableMonitorRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.NotificationRequest.profile_change_request)
        ProfileChangeRequest(super::ProfileChangeRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.NotificationRequest.keystroke_filter_request)
        KeystrokeFilterRequest(super::KeystrokeFilterRequest),
        // @@protoc_insertion_point(oneof_field:iterm2.NotificationRequest.prompt_monitor_request)
        PromptMonitorRequest(super::PromptMonitorRequest),
    }

    impl ::protobuf::Oneof for Arguments {
    }

    impl ::protobuf::OneofFull for Arguments {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::NotificationRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("arguments").unwrap()).clone()
        }
    }

    impl Arguments {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Arguments>("arguments")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.NotificationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NotificationResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.NotificationResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<notification_response::Status>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.NotificationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NotificationResponse {
    fn default() -> &'a NotificationResponse {
        <NotificationResponse as ::protobuf::Message>::default_instance()
    }
}

impl NotificationResponse {
    pub fn new() -> NotificationResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.NotificationResponse.Status status = 1;

    pub fn status(&self) -> notification_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(notification_response::Status::OK),
            None => notification_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: notification_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &NotificationResponse| { &m.status },
            |m: &mut NotificationResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NotificationResponse>(
            "NotificationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NotificationResponse {
    const NAME: &'static str = "NotificationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NotificationResponse {
        NotificationResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NotificationResponse {
        static instance: NotificationResponse = NotificationResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NotificationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NotificationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NotificationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NotificationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NotificationResponse`
pub mod notification_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.NotificationResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.NotificationResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.NotificationResponse.Status.SESSION_NOT_FOUND)
        SESSION_NOT_FOUND = 1,
        // @@protoc_insertion_point(enum_value:iterm2.NotificationResponse.Status.REQUEST_MALFORMED)
        REQUEST_MALFORMED = 2,
        // @@protoc_insertion_point(enum_value:iterm2.NotificationResponse.Status.NOT_SUBSCRIBED)
        NOT_SUBSCRIBED = 3,
        // @@protoc_insertion_point(enum_value:iterm2.NotificationResponse.Status.ALREADY_SUBSCRIBED)
        ALREADY_SUBSCRIBED = 4,
        // @@protoc_insertion_point(enum_value:iterm2.NotificationResponse.Status.DUPLICATE_SERVER_ORIGINATED_RPC)
        DUPLICATE_SERVER_ORIGINATED_RPC = 5,
        // @@protoc_insertion_point(enum_value:iterm2.NotificationResponse.Status.INVALID_IDENTIFIER)
        INVALID_IDENTIFIER = 6,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                2 => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                3 => ::std::option::Option::Some(Status::NOT_SUBSCRIBED),
                4 => ::std::option::Option::Some(Status::ALREADY_SUBSCRIBED),
                5 => ::std::option::Option::Some(Status::DUPLICATE_SERVER_ORIGINATED_RPC),
                6 => ::std::option::Option::Some(Status::INVALID_IDENTIFIER),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "SESSION_NOT_FOUND" => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                "REQUEST_MALFORMED" => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                "NOT_SUBSCRIBED" => ::std::option::Option::Some(Status::NOT_SUBSCRIBED),
                "ALREADY_SUBSCRIBED" => ::std::option::Option::Some(Status::ALREADY_SUBSCRIBED),
                "DUPLICATE_SERVER_ORIGINATED_RPC" => ::std::option::Option::Some(Status::DUPLICATE_SERVER_ORIGINATED_RPC),
                "INVALID_IDENTIFIER" => ::std::option::Option::Some(Status::INVALID_IDENTIFIER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::SESSION_NOT_FOUND,
            Status::REQUEST_MALFORMED,
            Status::NOT_SUBSCRIBED,
            Status::ALREADY_SUBSCRIBED,
            Status::DUPLICATE_SERVER_ORIGINATED_RPC,
            Status::INVALID_IDENTIFIER,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("NotificationResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("NotificationResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Notification {
    // message fields
    // @@protoc_insertion_point(field:iterm2.Notification.keystroke_notification)
    pub keystroke_notification: ::protobuf::MessageField<KeystrokeNotification>,
    // @@protoc_insertion_point(field:iterm2.Notification.screen_update_notification)
    pub screen_update_notification: ::protobuf::MessageField<ScreenUpdateNotification>,
    // @@protoc_insertion_point(field:iterm2.Notification.prompt_notification)
    pub prompt_notification: ::protobuf::MessageField<PromptNotification>,
    // @@protoc_insertion_point(field:iterm2.Notification.location_change_notification)
    pub location_change_notification: ::protobuf::MessageField<LocationChangeNotification>,
    // @@protoc_insertion_point(field:iterm2.Notification.custom_escape_sequence_notification)
    pub custom_escape_sequence_notification: ::protobuf::MessageField<CustomEscapeSequenceNotification>,
    // @@protoc_insertion_point(field:iterm2.Notification.new_session_notification)
    pub new_session_notification: ::protobuf::MessageField<NewSessionNotification>,
    // @@protoc_insertion_point(field:iterm2.Notification.terminate_session_notification)
    pub terminate_session_notification: ::protobuf::MessageField<TerminateSessionNotification>,
    // @@protoc_insertion_point(field:iterm2.Notification.layout_changed_notification)
    pub layout_changed_notification: ::protobuf::MessageField<LayoutChangedNotification>,
    // @@protoc_insertion_point(field:iterm2.Notification.focus_changed_notification)
    pub focus_changed_notification: ::protobuf::MessageField<FocusChangedNotification>,
    // @@protoc_insertion_point(field:iterm2.Notification.server_originated_rpc_notification)
    pub server_originated_rpc_notification: ::protobuf::MessageField<ServerOriginatedRPCNotification>,
    // @@protoc_insertion_point(field:iterm2.Notification.broadcast_domains_changed)
    pub broadcast_domains_changed: ::protobuf::MessageField<BroadcastDomainsChangedNotification>,
    // @@protoc_insertion_point(field:iterm2.Notification.variable_changed_notification)
    pub variable_changed_notification: ::protobuf::MessageField<VariableChangedNotification>,
    // @@protoc_insertion_point(field:iterm2.Notification.profile_changed_notification)
    pub profile_changed_notification: ::protobuf::MessageField<ProfileChangedNotification>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Notification {
    fn default() -> &'a Notification {
        <Notification as ::protobuf::Message>::default_instance()
    }
}

impl Notification {
    pub fn new() -> Notification {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KeystrokeNotification>(
            "keystroke_notification",
            |m: &Notification| { &m.keystroke_notification },
            |m: &mut Notification| { &mut m.keystroke_notification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScreenUpdateNotification>(
            "screen_update_notification",
            |m: &Notification| { &m.screen_update_notification },
            |m: &mut Notification| { &mut m.screen_update_notification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PromptNotification>(
            "prompt_notification",
            |m: &Notification| { &m.prompt_notification },
            |m: &mut Notification| { &mut m.prompt_notification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocationChangeNotification>(
            "location_change_notification",
            |m: &Notification| { &m.location_change_notification },
            |m: &mut Notification| { &mut m.location_change_notification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CustomEscapeSequenceNotification>(
            "custom_escape_sequence_notification",
            |m: &Notification| { &m.custom_escape_sequence_notification },
            |m: &mut Notification| { &mut m.custom_escape_sequence_notification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NewSessionNotification>(
            "new_session_notification",
            |m: &Notification| { &m.new_session_notification },
            |m: &mut Notification| { &mut m.new_session_notification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TerminateSessionNotification>(
            "terminate_session_notification",
            |m: &Notification| { &m.terminate_session_notification },
            |m: &mut Notification| { &mut m.terminate_session_notification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LayoutChangedNotification>(
            "layout_changed_notification",
            |m: &Notification| { &m.layout_changed_notification },
            |m: &mut Notification| { &mut m.layout_changed_notification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FocusChangedNotification>(
            "focus_changed_notification",
            |m: &Notification| { &m.focus_changed_notification },
            |m: &mut Notification| { &mut m.focus_changed_notification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServerOriginatedRPCNotification>(
            "server_originated_rpc_notification",
            |m: &Notification| { &m.server_originated_rpc_notification },
            |m: &mut Notification| { &mut m.server_originated_rpc_notification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BroadcastDomainsChangedNotification>(
            "broadcast_domains_changed",
            |m: &Notification| { &m.broadcast_domains_changed },
            |m: &mut Notification| { &mut m.broadcast_domains_changed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VariableChangedNotification>(
            "variable_changed_notification",
            |m: &Notification| { &m.variable_changed_notification },
            |m: &mut Notification| { &mut m.variable_changed_notification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProfileChangedNotification>(
            "profile_changed_notification",
            |m: &Notification| { &m.profile_changed_notification },
            |m: &mut Notification| { &mut m.profile_changed_notification },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Notification>(
            "Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Notification {
    const NAME: &'static str = "Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keystroke_notification)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.screen_update_notification)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.prompt_notification)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.location_change_notification)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.custom_escape_sequence_notification)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.new_session_notification)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.terminate_session_notification)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.layout_changed_notification)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.focus_changed_notification)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.server_originated_rpc_notification)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.broadcast_domains_changed)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.variable_changed_notification)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.profile_changed_notification)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.keystroke_notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.screen_update_notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.prompt_notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.location_change_notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.custom_escape_sequence_notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.new_session_notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.terminate_session_notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.layout_changed_notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.focus_changed_notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.server_originated_rpc_notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.broadcast_domains_changed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.variable_changed_notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.profile_changed_notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.keystroke_notification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.screen_update_notification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.prompt_notification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.location_change_notification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.custom_escape_sequence_notification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.new_session_notification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.terminate_session_notification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.layout_changed_notification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.focus_changed_notification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.server_originated_rpc_notification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.broadcast_domains_changed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.variable_changed_notification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.profile_changed_notification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Notification {
        Notification::new()
    }

    fn clear(&mut self) {
        self.keystroke_notification.clear();
        self.screen_update_notification.clear();
        self.prompt_notification.clear();
        self.location_change_notification.clear();
        self.custom_escape_sequence_notification.clear();
        self.new_session_notification.clear();
        self.terminate_session_notification.clear();
        self.layout_changed_notification.clear();
        self.focus_changed_notification.clear();
        self.server_originated_rpc_notification.clear();
        self.broadcast_domains_changed.clear();
        self.variable_changed_notification.clear();
        self.profile_changed_notification.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Notification {
        static instance: Notification = Notification {
            keystroke_notification: ::protobuf::MessageField::none(),
            screen_update_notification: ::protobuf::MessageField::none(),
            prompt_notification: ::protobuf::MessageField::none(),
            location_change_notification: ::protobuf::MessageField::none(),
            custom_escape_sequence_notification: ::protobuf::MessageField::none(),
            new_session_notification: ::protobuf::MessageField::none(),
            terminate_session_notification: ::protobuf::MessageField::none(),
            layout_changed_notification: ::protobuf::MessageField::none(),
            focus_changed_notification: ::protobuf::MessageField::none(),
            server_originated_rpc_notification: ::protobuf::MessageField::none(),
            broadcast_domains_changed: ::protobuf::MessageField::none(),
            variable_changed_notification: ::protobuf::MessageField::none(),
            profile_changed_notification: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.ProfileChangedNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProfileChangedNotification {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ProfileChangedNotification.guid)
    pub guid: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ProfileChangedNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProfileChangedNotification {
    fn default() -> &'a ProfileChangedNotification {
        <ProfileChangedNotification as ::protobuf::Message>::default_instance()
    }
}

impl ProfileChangedNotification {
    pub fn new() -> ProfileChangedNotification {
        ::std::default::Default::default()
    }

    // optional string guid = 1;

    pub fn guid(&self) -> &str {
        match self.guid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_guid(&mut self) {
        self.guid = ::std::option::Option::None;
    }

    pub fn has_guid(&self) -> bool {
        self.guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid(&mut self, v: ::std::string::String) {
        self.guid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid(&mut self) -> &mut ::std::string::String {
        if self.guid.is_none() {
            self.guid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.guid.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid(&mut self) -> ::std::string::String {
        self.guid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guid",
            |m: &ProfileChangedNotification| { &m.guid },
            |m: &mut ProfileChangedNotification| { &mut m.guid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProfileChangedNotification>(
            "ProfileChangedNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProfileChangedNotification {
    const NAME: &'static str = "ProfileChangedNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.guid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guid.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProfileChangedNotification {
        ProfileChangedNotification::new()
    }

    fn clear(&mut self) {
        self.guid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProfileChangedNotification {
        static instance: ProfileChangedNotification = ProfileChangedNotification {
            guid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProfileChangedNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProfileChangedNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProfileChangedNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProfileChangedNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.VariableChangedNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VariableChangedNotification {
    // message fields
    // @@protoc_insertion_point(field:iterm2.VariableChangedNotification.scope)
    pub scope: ::std::option::Option<::protobuf::EnumOrUnknown<VariableScope>>,
    // @@protoc_insertion_point(field:iterm2.VariableChangedNotification.identifier)
    pub identifier: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.VariableChangedNotification.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.VariableChangedNotification.json_new_value)
    pub json_new_value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.VariableChangedNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VariableChangedNotification {
    fn default() -> &'a VariableChangedNotification {
        <VariableChangedNotification as ::protobuf::Message>::default_instance()
    }
}

impl VariableChangedNotification {
    pub fn new() -> VariableChangedNotification {
        ::std::default::Default::default()
    }

    // optional .iterm2.VariableScope scope = 1;

    pub fn scope(&self) -> VariableScope {
        match self.scope {
            Some(e) => e.enum_value_or(VariableScope::SESSION),
            None => VariableScope::SESSION,
        }
    }

    pub fn clear_scope(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_scope(&self) -> bool {
        self.scope.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: VariableScope) {
        self.scope = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string identifier = 2;

    pub fn identifier(&self) -> &str {
        match self.identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identifier(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::string::String) {
        self.identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
        if self.identifier.is_none() {
            self.identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::string::String {
        self.identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string json_new_value = 4;

    pub fn json_new_value(&self) -> &str {
        match self.json_new_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_json_new_value(&mut self) {
        self.json_new_value = ::std::option::Option::None;
    }

    pub fn has_json_new_value(&self) -> bool {
        self.json_new_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json_new_value(&mut self, v: ::std::string::String) {
        self.json_new_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json_new_value(&mut self) -> &mut ::std::string::String {
        if self.json_new_value.is_none() {
            self.json_new_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.json_new_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_json_new_value(&mut self) -> ::std::string::String {
        self.json_new_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scope",
            |m: &VariableChangedNotification| { &m.scope },
            |m: &mut VariableChangedNotification| { &mut m.scope },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identifier",
            |m: &VariableChangedNotification| { &m.identifier },
            |m: &mut VariableChangedNotification| { &mut m.identifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &VariableChangedNotification| { &m.name },
            |m: &mut VariableChangedNotification| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "json_new_value",
            |m: &VariableChangedNotification| { &m.json_new_value },
            |m: &mut VariableChangedNotification| { &mut m.json_new_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VariableChangedNotification>(
            "VariableChangedNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VariableChangedNotification {
    const NAME: &'static str = "VariableChangedNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.scope = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.identifier = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.json_new_value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.scope {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.json_new_value.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.scope {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.identifier.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.json_new_value.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VariableChangedNotification {
        VariableChangedNotification::new()
    }

    fn clear(&mut self) {
        self.scope = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.json_new_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VariableChangedNotification {
        static instance: VariableChangedNotification = VariableChangedNotification {
            scope: ::std::option::Option::None,
            identifier: ::std::option::Option::None,
            name: ::std::option::Option::None,
            json_new_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VariableChangedNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VariableChangedNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VariableChangedNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VariableChangedNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.BroadcastDomainsChangedNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BroadcastDomainsChangedNotification {
    // message fields
    // @@protoc_insertion_point(field:iterm2.BroadcastDomainsChangedNotification.broadcast_domains)
    pub broadcast_domains: ::std::vec::Vec<BroadcastDomain>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.BroadcastDomainsChangedNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BroadcastDomainsChangedNotification {
    fn default() -> &'a BroadcastDomainsChangedNotification {
        <BroadcastDomainsChangedNotification as ::protobuf::Message>::default_instance()
    }
}

impl BroadcastDomainsChangedNotification {
    pub fn new() -> BroadcastDomainsChangedNotification {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "broadcast_domains",
            |m: &BroadcastDomainsChangedNotification| { &m.broadcast_domains },
            |m: &mut BroadcastDomainsChangedNotification| { &mut m.broadcast_domains },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BroadcastDomainsChangedNotification>(
            "BroadcastDomainsChangedNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BroadcastDomainsChangedNotification {
    const NAME: &'static str = "BroadcastDomainsChangedNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.broadcast_domains.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.broadcast_domains {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.broadcast_domains {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BroadcastDomainsChangedNotification {
        BroadcastDomainsChangedNotification::new()
    }

    fn clear(&mut self) {
        self.broadcast_domains.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BroadcastDomainsChangedNotification {
        static instance: BroadcastDomainsChangedNotification = BroadcastDomainsChangedNotification {
            broadcast_domains: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BroadcastDomainsChangedNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BroadcastDomainsChangedNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BroadcastDomainsChangedNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BroadcastDomainsChangedNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.ServerOriginatedRPC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerOriginatedRPC {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ServerOriginatedRPC.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.ServerOriginatedRPC.arguments)
    pub arguments: ::std::vec::Vec<server_originated_rpc::RPCArgument>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ServerOriginatedRPC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerOriginatedRPC {
    fn default() -> &'a ServerOriginatedRPC {
        <ServerOriginatedRPC as ::protobuf::Message>::default_instance()
    }
}

impl ServerOriginatedRPC {
    pub fn new() -> ServerOriginatedRPC {
        ::std::default::Default::default()
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ServerOriginatedRPC| { &m.name },
            |m: &mut ServerOriginatedRPC| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "arguments",
            |m: &ServerOriginatedRPC| { &m.arguments },
            |m: &mut ServerOriginatedRPC| { &mut m.arguments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerOriginatedRPC>(
            "ServerOriginatedRPC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerOriginatedRPC {
    const NAME: &'static str = "ServerOriginatedRPC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.arguments.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.arguments {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerOriginatedRPC {
        ServerOriginatedRPC::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.arguments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerOriginatedRPC {
        static instance: ServerOriginatedRPC = ServerOriginatedRPC {
            name: ::std::option::Option::None,
            arguments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerOriginatedRPC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerOriginatedRPC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerOriginatedRPC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerOriginatedRPC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ServerOriginatedRPC`
pub mod server_originated_rpc {
    // @@protoc_insertion_point(message:iterm2.ServerOriginatedRPC.RPCArgument)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RPCArgument {
        // message fields
        // @@protoc_insertion_point(field:iterm2.ServerOriginatedRPC.RPCArgument.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.ServerOriginatedRPC.RPCArgument.json_value)
        pub json_value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.ServerOriginatedRPC.RPCArgument.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RPCArgument {
        fn default() -> &'a RPCArgument {
            <RPCArgument as ::protobuf::Message>::default_instance()
        }
    }

    impl RPCArgument {
        pub fn new() -> RPCArgument {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string json_value = 2;

        pub fn json_value(&self) -> &str {
            match self.json_value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_json_value(&mut self) {
            self.json_value = ::std::option::Option::None;
        }

        pub fn has_json_value(&self) -> bool {
            self.json_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_json_value(&mut self, v: ::std::string::String) {
            self.json_value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_json_value(&mut self) -> &mut ::std::string::String {
            if self.json_value.is_none() {
                self.json_value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.json_value.as_mut().unwrap()
        }

        // Take field
        pub fn take_json_value(&mut self) -> ::std::string::String {
            self.json_value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &RPCArgument| { &m.name },
                |m: &mut RPCArgument| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "json_value",
                |m: &RPCArgument| { &m.json_value },
                |m: &mut RPCArgument| { &mut m.json_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RPCArgument>(
                "ServerOriginatedRPC.RPCArgument",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RPCArgument {
        const NAME: &'static str = "RPCArgument";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.json_value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.json_value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.json_value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RPCArgument {
            RPCArgument::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.json_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RPCArgument {
            static instance: RPCArgument = RPCArgument {
                name: ::std::option::Option::None,
                json_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RPCArgument {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ServerOriginatedRPC.RPCArgument").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RPCArgument {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RPCArgument {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:iterm2.ServerOriginatedRPCNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerOriginatedRPCNotification {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ServerOriginatedRPCNotification.request_id)
    pub request_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.ServerOriginatedRPCNotification.rpc)
    pub rpc: ::protobuf::MessageField<ServerOriginatedRPC>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ServerOriginatedRPCNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerOriginatedRPCNotification {
    fn default() -> &'a ServerOriginatedRPCNotification {
        <ServerOriginatedRPCNotification as ::protobuf::Message>::default_instance()
    }
}

impl ServerOriginatedRPCNotification {
    pub fn new() -> ServerOriginatedRPCNotification {
        ::std::default::Default::default()
    }

    // optional string request_id = 1;

    pub fn request_id(&self) -> &str {
        match self.request_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: ::std::string::String) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request_id(&mut self) -> &mut ::std::string::String {
        if self.request_id.is_none() {
            self.request_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.request_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_request_id(&mut self) -> ::std::string::String {
        self.request_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &ServerOriginatedRPCNotification| { &m.request_id },
            |m: &mut ServerOriginatedRPCNotification| { &mut m.request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServerOriginatedRPC>(
            "rpc",
            |m: &ServerOriginatedRPCNotification| { &m.rpc },
            |m: &mut ServerOriginatedRPCNotification| { &mut m.rpc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerOriginatedRPCNotification>(
            "ServerOriginatedRPCNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerOriginatedRPCNotification {
    const NAME: &'static str = "ServerOriginatedRPCNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.request_id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rpc)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rpc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rpc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerOriginatedRPCNotification {
        ServerOriginatedRPCNotification::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.rpc.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerOriginatedRPCNotification {
        static instance: ServerOriginatedRPCNotification = ServerOriginatedRPCNotification {
            request_id: ::std::option::Option::None,
            rpc: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerOriginatedRPCNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerOriginatedRPCNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerOriginatedRPCNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerOriginatedRPCNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.KeystrokeNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeystrokeNotification {
    // message fields
    // @@protoc_insertion_point(field:iterm2.KeystrokeNotification.characters)
    pub characters: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.KeystrokeNotification.charactersIgnoringModifiers)
    pub charactersIgnoringModifiers: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.KeystrokeNotification.modifiers)
    pub modifiers: ::std::vec::Vec<::protobuf::EnumOrUnknown<Modifiers>>,
    // @@protoc_insertion_point(field:iterm2.KeystrokeNotification.keyCode)
    pub keyCode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:iterm2.KeystrokeNotification.session)
    pub session: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.KeystrokeNotification.action)
    pub action: ::std::option::Option<::protobuf::EnumOrUnknown<keystroke_notification::Action>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.KeystrokeNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeystrokeNotification {
    fn default() -> &'a KeystrokeNotification {
        <KeystrokeNotification as ::protobuf::Message>::default_instance()
    }
}

impl KeystrokeNotification {
    pub fn new() -> KeystrokeNotification {
        ::std::default::Default::default()
    }

    // optional string characters = 1;

    pub fn characters(&self) -> &str {
        match self.characters.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_characters(&mut self) {
        self.characters = ::std::option::Option::None;
    }

    pub fn has_characters(&self) -> bool {
        self.characters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_characters(&mut self, v: ::std::string::String) {
        self.characters = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_characters(&mut self) -> &mut ::std::string::String {
        if self.characters.is_none() {
            self.characters = ::std::option::Option::Some(::std::string::String::new());
        }
        self.characters.as_mut().unwrap()
    }

    // Take field
    pub fn take_characters(&mut self) -> ::std::string::String {
        self.characters.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string charactersIgnoringModifiers = 2;

    pub fn charactersIgnoringModifiers(&self) -> &str {
        match self.charactersIgnoringModifiers.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_charactersIgnoringModifiers(&mut self) {
        self.charactersIgnoringModifiers = ::std::option::Option::None;
    }

    pub fn has_charactersIgnoringModifiers(&self) -> bool {
        self.charactersIgnoringModifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_charactersIgnoringModifiers(&mut self, v: ::std::string::String) {
        self.charactersIgnoringModifiers = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_charactersIgnoringModifiers(&mut self) -> &mut ::std::string::String {
        if self.charactersIgnoringModifiers.is_none() {
            self.charactersIgnoringModifiers = ::std::option::Option::Some(::std::string::String::new());
        }
        self.charactersIgnoringModifiers.as_mut().unwrap()
    }

    // Take field
    pub fn take_charactersIgnoringModifiers(&mut self) -> ::std::string::String {
        self.charactersIgnoringModifiers.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 keyCode = 4;

    pub fn keyCode(&self) -> i32 {
        self.keyCode.unwrap_or(0)
    }

    pub fn clear_keyCode(&mut self) {
        self.keyCode = ::std::option::Option::None;
    }

    pub fn has_keyCode(&self) -> bool {
        self.keyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyCode(&mut self, v: i32) {
        self.keyCode = ::std::option::Option::Some(v);
    }

    // optional string session = 5;

    pub fn session(&self) -> &str {
        match self.session.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::string::String) {
        self.session = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session(&mut self) -> &mut ::std::string::String {
        if self.session.is_none() {
            self.session = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session.as_mut().unwrap()
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::string::String {
        self.session.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .iterm2.KeystrokeNotification.Action action = 6;

    pub fn action(&self) -> keystroke_notification::Action {
        match self.action {
            Some(e) => e.enum_value_or(keystroke_notification::Action::KEY_DOWN),
            None => keystroke_notification::Action::KEY_DOWN,
        }
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: keystroke_notification::Action) {
        self.action = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "characters",
            |m: &KeystrokeNotification| { &m.characters },
            |m: &mut KeystrokeNotification| { &mut m.characters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "charactersIgnoringModifiers",
            |m: &KeystrokeNotification| { &m.charactersIgnoringModifiers },
            |m: &mut KeystrokeNotification| { &mut m.charactersIgnoringModifiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modifiers",
            |m: &KeystrokeNotification| { &m.modifiers },
            |m: &mut KeystrokeNotification| { &mut m.modifiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyCode",
            |m: &KeystrokeNotification| { &m.keyCode },
            |m: &mut KeystrokeNotification| { &mut m.keyCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &KeystrokeNotification| { &m.session },
            |m: &mut KeystrokeNotification| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &KeystrokeNotification| { &m.action },
            |m: &mut KeystrokeNotification| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeystrokeNotification>(
            "KeystrokeNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeystrokeNotification {
    const NAME: &'static str = "KeystrokeNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.characters = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.charactersIgnoringModifiers = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.modifiers.push(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.modifiers)?
                },
                32 => {
                    self.keyCode = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.session = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.characters.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.charactersIgnoringModifiers.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.modifiers {
            my_size += ::protobuf::rt::int32_size(3, value.value());
        };
        if let Some(v) = self.keyCode {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.session.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.characters.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.charactersIgnoringModifiers.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.modifiers {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.keyCode {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.session.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.action {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeystrokeNotification {
        KeystrokeNotification::new()
    }

    fn clear(&mut self) {
        self.characters = ::std::option::Option::None;
        self.charactersIgnoringModifiers = ::std::option::Option::None;
        self.modifiers.clear();
        self.keyCode = ::std::option::Option::None;
        self.session = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeystrokeNotification {
        static instance: KeystrokeNotification = KeystrokeNotification {
            characters: ::std::option::Option::None,
            charactersIgnoringModifiers: ::std::option::Option::None,
            modifiers: ::std::vec::Vec::new(),
            keyCode: ::std::option::Option::None,
            session: ::std::option::Option::None,
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeystrokeNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeystrokeNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeystrokeNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeystrokeNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `KeystrokeNotification`
pub mod keystroke_notification {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.KeystrokeNotification.Action)
    pub enum Action {
        // @@protoc_insertion_point(enum_value:iterm2.KeystrokeNotification.Action.KEY_DOWN)
        KEY_DOWN = 0,
        // @@protoc_insertion_point(enum_value:iterm2.KeystrokeNotification.Action.KEY_UP)
        KEY_UP = 1,
        // @@protoc_insertion_point(enum_value:iterm2.KeystrokeNotification.Action.FLAGS_CHANGED)
        FLAGS_CHANGED = 2,
    }

    impl ::protobuf::Enum for Action {
        const NAME: &'static str = "Action";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Action> {
            match value {
                0 => ::std::option::Option::Some(Action::KEY_DOWN),
                1 => ::std::option::Option::Some(Action::KEY_UP),
                2 => ::std::option::Option::Some(Action::FLAGS_CHANGED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Action> {
            match str {
                "KEY_DOWN" => ::std::option::Option::Some(Action::KEY_DOWN),
                "KEY_UP" => ::std::option::Option::Some(Action::KEY_UP),
                "FLAGS_CHANGED" => ::std::option::Option::Some(Action::FLAGS_CHANGED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Action] = &[
            Action::KEY_DOWN,
            Action::KEY_UP,
            Action::FLAGS_CHANGED,
        ];
    }

    impl ::protobuf::EnumFull for Action {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("KeystrokeNotification.Action").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Action {
        fn default() -> Self {
            Action::KEY_DOWN
        }
    }

    impl Action {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Action>("KeystrokeNotification.Action")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.ScreenUpdateNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScreenUpdateNotification {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ScreenUpdateNotification.session)
    pub session: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ScreenUpdateNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScreenUpdateNotification {
    fn default() -> &'a ScreenUpdateNotification {
        <ScreenUpdateNotification as ::protobuf::Message>::default_instance()
    }
}

impl ScreenUpdateNotification {
    pub fn new() -> ScreenUpdateNotification {
        ::std::default::Default::default()
    }

    // optional string session = 1;

    pub fn session(&self) -> &str {
        match self.session.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::string::String) {
        self.session = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session(&mut self) -> &mut ::std::string::String {
        if self.session.is_none() {
            self.session = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session.as_mut().unwrap()
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::string::String {
        self.session.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &ScreenUpdateNotification| { &m.session },
            |m: &mut ScreenUpdateNotification| { &mut m.session },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScreenUpdateNotification>(
            "ScreenUpdateNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScreenUpdateNotification {
    const NAME: &'static str = "ScreenUpdateNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScreenUpdateNotification {
        ScreenUpdateNotification::new()
    }

    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScreenUpdateNotification {
        static instance: ScreenUpdateNotification = ScreenUpdateNotification {
            session: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScreenUpdateNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScreenUpdateNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScreenUpdateNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScreenUpdateNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.PromptNotificationPrompt)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PromptNotificationPrompt {
    // message fields
    // @@protoc_insertion_point(field:iterm2.PromptNotificationPrompt.placeholder)
    pub placeholder: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.PromptNotificationPrompt.prompt)
    pub prompt: ::protobuf::MessageField<GetPromptResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.PromptNotificationPrompt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PromptNotificationPrompt {
    fn default() -> &'a PromptNotificationPrompt {
        <PromptNotificationPrompt as ::protobuf::Message>::default_instance()
    }
}

impl PromptNotificationPrompt {
    pub fn new() -> PromptNotificationPrompt {
        ::std::default::Default::default()
    }

    // optional string placeholder = 1;

    pub fn placeholder(&self) -> &str {
        match self.placeholder.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_placeholder(&mut self) {
        self.placeholder = ::std::option::Option::None;
    }

    pub fn has_placeholder(&self) -> bool {
        self.placeholder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_placeholder(&mut self, v: ::std::string::String) {
        self.placeholder = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_placeholder(&mut self) -> &mut ::std::string::String {
        if self.placeholder.is_none() {
            self.placeholder = ::std::option::Option::Some(::std::string::String::new());
        }
        self.placeholder.as_mut().unwrap()
    }

    // Take field
    pub fn take_placeholder(&mut self) -> ::std::string::String {
        self.placeholder.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "placeholder",
            |m: &PromptNotificationPrompt| { &m.placeholder },
            |m: &mut PromptNotificationPrompt| { &mut m.placeholder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetPromptResponse>(
            "prompt",
            |m: &PromptNotificationPrompt| { &m.prompt },
            |m: &mut PromptNotificationPrompt| { &mut m.prompt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PromptNotificationPrompt>(
            "PromptNotificationPrompt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PromptNotificationPrompt {
    const NAME: &'static str = "PromptNotificationPrompt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.placeholder = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.prompt)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.placeholder.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.prompt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.placeholder.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.prompt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PromptNotificationPrompt {
        PromptNotificationPrompt::new()
    }

    fn clear(&mut self) {
        self.placeholder = ::std::option::Option::None;
        self.prompt.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PromptNotificationPrompt {
        static instance: PromptNotificationPrompt = PromptNotificationPrompt {
            placeholder: ::std::option::Option::None,
            prompt: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PromptNotificationPrompt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PromptNotificationPrompt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PromptNotificationPrompt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PromptNotificationPrompt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.PromptNotificationCommandStart)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PromptNotificationCommandStart {
    // message fields
    // @@protoc_insertion_point(field:iterm2.PromptNotificationCommandStart.command)
    pub command: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.PromptNotificationCommandStart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PromptNotificationCommandStart {
    fn default() -> &'a PromptNotificationCommandStart {
        <PromptNotificationCommandStart as ::protobuf::Message>::default_instance()
    }
}

impl PromptNotificationCommandStart {
    pub fn new() -> PromptNotificationCommandStart {
        ::std::default::Default::default()
    }

    // optional string command = 1;

    pub fn command(&self) -> &str {
        match self.command.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::std::string::String) {
        self.command = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut ::std::string::String {
        if self.command.is_none() {
            self.command = ::std::option::Option::Some(::std::string::String::new());
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> ::std::string::String {
        self.command.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command",
            |m: &PromptNotificationCommandStart| { &m.command },
            |m: &mut PromptNotificationCommandStart| { &mut m.command },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PromptNotificationCommandStart>(
            "PromptNotificationCommandStart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PromptNotificationCommandStart {
    const NAME: &'static str = "PromptNotificationCommandStart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.command = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.command.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PromptNotificationCommandStart {
        PromptNotificationCommandStart::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PromptNotificationCommandStart {
        static instance: PromptNotificationCommandStart = PromptNotificationCommandStart {
            command: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PromptNotificationCommandStart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PromptNotificationCommandStart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PromptNotificationCommandStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PromptNotificationCommandStart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.PromptNotificationCommandEnd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PromptNotificationCommandEnd {
    // message fields
    // @@protoc_insertion_point(field:iterm2.PromptNotificationCommandEnd.status)
    pub status: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.PromptNotificationCommandEnd.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PromptNotificationCommandEnd {
    fn default() -> &'a PromptNotificationCommandEnd {
        <PromptNotificationCommandEnd as ::protobuf::Message>::default_instance()
    }
}

impl PromptNotificationCommandEnd {
    pub fn new() -> PromptNotificationCommandEnd {
        ::std::default::Default::default()
    }

    // optional int32 status = 1;

    pub fn status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &PromptNotificationCommandEnd| { &m.status },
            |m: &mut PromptNotificationCommandEnd| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PromptNotificationCommandEnd>(
            "PromptNotificationCommandEnd",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PromptNotificationCommandEnd {
    const NAME: &'static str = "PromptNotificationCommandEnd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PromptNotificationCommandEnd {
        PromptNotificationCommandEnd::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PromptNotificationCommandEnd {
        static instance: PromptNotificationCommandEnd = PromptNotificationCommandEnd {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PromptNotificationCommandEnd {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PromptNotificationCommandEnd").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PromptNotificationCommandEnd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PromptNotificationCommandEnd {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.PromptNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PromptNotification {
    // message fields
    // @@protoc_insertion_point(field:iterm2.PromptNotification.session)
    pub session: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.PromptNotification.unique_prompt_id)
    pub unique_prompt_id: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub event: ::std::option::Option<prompt_notification::Event>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.PromptNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PromptNotification {
    fn default() -> &'a PromptNotification {
        <PromptNotification as ::protobuf::Message>::default_instance()
    }
}

impl PromptNotification {
    pub fn new() -> PromptNotification {
        ::std::default::Default::default()
    }

    // optional string session = 1;

    pub fn session(&self) -> &str {
        match self.session.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::string::String) {
        self.session = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session(&mut self) -> &mut ::std::string::String {
        if self.session.is_none() {
            self.session = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session.as_mut().unwrap()
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::string::String {
        self.session.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .iterm2.PromptNotificationPrompt prompt = 2;

    pub fn prompt(&self) -> &PromptNotificationPrompt {
        match self.event {
            ::std::option::Option::Some(prompt_notification::Event::Prompt(ref v)) => v,
            _ => <PromptNotificationPrompt as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_prompt(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_prompt(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(prompt_notification::Event::Prompt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prompt(&mut self, v: PromptNotificationPrompt) {
        self.event = ::std::option::Option::Some(prompt_notification::Event::Prompt(v))
    }

    // Mutable pointer to the field.
    pub fn mut_prompt(&mut self) -> &mut PromptNotificationPrompt {
        if let ::std::option::Option::Some(prompt_notification::Event::Prompt(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(prompt_notification::Event::Prompt(PromptNotificationPrompt::new()));
        }
        match self.event {
            ::std::option::Option::Some(prompt_notification::Event::Prompt(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_prompt(&mut self) -> PromptNotificationPrompt {
        if self.has_prompt() {
            match self.event.take() {
                ::std::option::Option::Some(prompt_notification::Event::Prompt(v)) => v,
                _ => panic!(),
            }
        } else {
            PromptNotificationPrompt::new()
        }
    }

    // optional .iterm2.PromptNotificationCommandStart command_start = 3;

    pub fn command_start(&self) -> &PromptNotificationCommandStart {
        match self.event {
            ::std::option::Option::Some(prompt_notification::Event::CommandStart(ref v)) => v,
            _ => <PromptNotificationCommandStart as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_command_start(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_command_start(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(prompt_notification::Event::CommandStart(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_command_start(&mut self, v: PromptNotificationCommandStart) {
        self.event = ::std::option::Option::Some(prompt_notification::Event::CommandStart(v))
    }

    // Mutable pointer to the field.
    pub fn mut_command_start(&mut self) -> &mut PromptNotificationCommandStart {
        if let ::std::option::Option::Some(prompt_notification::Event::CommandStart(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(prompt_notification::Event::CommandStart(PromptNotificationCommandStart::new()));
        }
        match self.event {
            ::std::option::Option::Some(prompt_notification::Event::CommandStart(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_command_start(&mut self) -> PromptNotificationCommandStart {
        if self.has_command_start() {
            match self.event.take() {
                ::std::option::Option::Some(prompt_notification::Event::CommandStart(v)) => v,
                _ => panic!(),
            }
        } else {
            PromptNotificationCommandStart::new()
        }
    }

    // optional .iterm2.PromptNotificationCommandEnd command_end = 4;

    pub fn command_end(&self) -> &PromptNotificationCommandEnd {
        match self.event {
            ::std::option::Option::Some(prompt_notification::Event::CommandEnd(ref v)) => v,
            _ => <PromptNotificationCommandEnd as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_command_end(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_command_end(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(prompt_notification::Event::CommandEnd(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_command_end(&mut self, v: PromptNotificationCommandEnd) {
        self.event = ::std::option::Option::Some(prompt_notification::Event::CommandEnd(v))
    }

    // Mutable pointer to the field.
    pub fn mut_command_end(&mut self) -> &mut PromptNotificationCommandEnd {
        if let ::std::option::Option::Some(prompt_notification::Event::CommandEnd(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(prompt_notification::Event::CommandEnd(PromptNotificationCommandEnd::new()));
        }
        match self.event {
            ::std::option::Option::Some(prompt_notification::Event::CommandEnd(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_command_end(&mut self) -> PromptNotificationCommandEnd {
        if self.has_command_end() {
            match self.event.take() {
                ::std::option::Option::Some(prompt_notification::Event::CommandEnd(v)) => v,
                _ => panic!(),
            }
        } else {
            PromptNotificationCommandEnd::new()
        }
    }

    // optional string unique_prompt_id = 5;

    pub fn unique_prompt_id(&self) -> &str {
        match self.unique_prompt_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_prompt_id(&mut self) {
        self.unique_prompt_id = ::std::option::Option::None;
    }

    pub fn has_unique_prompt_id(&self) -> bool {
        self.unique_prompt_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_prompt_id(&mut self, v: ::std::string::String) {
        self.unique_prompt_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_prompt_id(&mut self) -> &mut ::std::string::String {
        if self.unique_prompt_id.is_none() {
            self.unique_prompt_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_prompt_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_prompt_id(&mut self) -> ::std::string::String {
        self.unique_prompt_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &PromptNotification| { &m.session },
            |m: &mut PromptNotification| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PromptNotificationPrompt>(
            "prompt",
            PromptNotification::has_prompt,
            PromptNotification::prompt,
            PromptNotification::mut_prompt,
            PromptNotification::set_prompt,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PromptNotificationCommandStart>(
            "command_start",
            PromptNotification::has_command_start,
            PromptNotification::command_start,
            PromptNotification::mut_command_start,
            PromptNotification::set_command_start,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PromptNotificationCommandEnd>(
            "command_end",
            PromptNotification::has_command_end,
            PromptNotification::command_end,
            PromptNotification::mut_command_end,
            PromptNotification::set_command_end,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unique_prompt_id",
            |m: &PromptNotification| { &m.unique_prompt_id },
            |m: &mut PromptNotification| { &mut m.unique_prompt_id },
        ));
        oneofs.push(prompt_notification::Event::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PromptNotification>(
            "PromptNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PromptNotification {
    const NAME: &'static str = "PromptNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.event = ::std::option::Option::Some(prompt_notification::Event::Prompt(is.read_message()?));
                },
                26 => {
                    self.event = ::std::option::Option::Some(prompt_notification::Event::CommandStart(is.read_message()?));
                },
                34 => {
                    self.event = ::std::option::Option::Some(prompt_notification::Event::CommandEnd(is.read_message()?));
                },
                42 => {
                    self.unique_prompt_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.unique_prompt_id.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.event {
            match v {
                &prompt_notification::Event::Prompt(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &prompt_notification::Event::CommandStart(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &prompt_notification::Event::CommandEnd(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.unique_prompt_id.as_ref() {
            os.write_string(5, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.event {
            match v {
                &prompt_notification::Event::Prompt(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &prompt_notification::Event::CommandStart(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &prompt_notification::Event::CommandEnd(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PromptNotification {
        PromptNotification::new()
    }

    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.unique_prompt_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PromptNotification {
        static instance: PromptNotification = PromptNotification {
            session: ::std::option::Option::None,
            unique_prompt_id: ::std::option::Option::None,
            event: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PromptNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PromptNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PromptNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PromptNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PromptNotification`
pub mod prompt_notification {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.PromptNotification.event)
    pub enum Event {
        // @@protoc_insertion_point(oneof_field:iterm2.PromptNotification.prompt)
        Prompt(super::PromptNotificationPrompt),
        // @@protoc_insertion_point(oneof_field:iterm2.PromptNotification.command_start)
        CommandStart(super::PromptNotificationCommandStart),
        // @@protoc_insertion_point(oneof_field:iterm2.PromptNotification.command_end)
        CommandEnd(super::PromptNotificationCommandEnd),
    }

    impl ::protobuf::Oneof for Event {
    }

    impl ::protobuf::OneofFull for Event {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::PromptNotification as ::protobuf::MessageFull>::descriptor().oneof_by_name("event").unwrap()).clone()
        }
    }

    impl Event {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Event>("event")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.LocationChangeNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LocationChangeNotification {
    // message fields
    // @@protoc_insertion_point(field:iterm2.LocationChangeNotification.host_name)
    pub host_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.LocationChangeNotification.user_name)
    pub user_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.LocationChangeNotification.directory)
    pub directory: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.LocationChangeNotification.session)
    pub session: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.LocationChangeNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LocationChangeNotification {
    fn default() -> &'a LocationChangeNotification {
        <LocationChangeNotification as ::protobuf::Message>::default_instance()
    }
}

impl LocationChangeNotification {
    pub fn new() -> LocationChangeNotification {
        ::std::default::Default::default()
    }

    // optional string host_name = 1;

    pub fn host_name(&self) -> &str {
        match self.host_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host_name(&mut self) {
        self.host_name = ::std::option::Option::None;
    }

    pub fn has_host_name(&self) -> bool {
        self.host_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_name(&mut self, v: ::std::string::String) {
        self.host_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
        if self.host_name.is_none() {
            self.host_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_name(&mut self) -> ::std::string::String {
        self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string user_name = 2;

    pub fn user_name(&self) -> &str {
        match self.user_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user_name(&mut self) {
        self.user_name = ::std::option::Option::None;
    }

    pub fn has_user_name(&self) -> bool {
        self.user_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_name(&mut self, v: ::std::string::String) {
        self.user_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_name(&mut self) -> &mut ::std::string::String {
        if self.user_name.is_none() {
            self.user_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_name(&mut self) -> ::std::string::String {
        self.user_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string directory = 3;

    pub fn directory(&self) -> &str {
        match self.directory.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directory(&mut self) {
        self.directory = ::std::option::Option::None;
    }

    pub fn has_directory(&self) -> bool {
        self.directory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directory(&mut self, v: ::std::string::String) {
        self.directory = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directory(&mut self) -> &mut ::std::string::String {
        if self.directory.is_none() {
            self.directory = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directory.as_mut().unwrap()
    }

    // Take field
    pub fn take_directory(&mut self) -> ::std::string::String {
        self.directory.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string session = 4;

    pub fn session(&self) -> &str {
        match self.session.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::string::String) {
        self.session = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session(&mut self) -> &mut ::std::string::String {
        if self.session.is_none() {
            self.session = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session.as_mut().unwrap()
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::string::String {
        self.session.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_name",
            |m: &LocationChangeNotification| { &m.host_name },
            |m: &mut LocationChangeNotification| { &mut m.host_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_name",
            |m: &LocationChangeNotification| { &m.user_name },
            |m: &mut LocationChangeNotification| { &mut m.user_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directory",
            |m: &LocationChangeNotification| { &m.directory },
            |m: &mut LocationChangeNotification| { &mut m.directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &LocationChangeNotification| { &m.session },
            |m: &mut LocationChangeNotification| { &mut m.session },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocationChangeNotification>(
            "LocationChangeNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LocationChangeNotification {
    const NAME: &'static str = "LocationChangeNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.host_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.user_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.directory = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.session = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.host_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.user_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.directory.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.session.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.host_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.user_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.directory.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.session.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LocationChangeNotification {
        LocationChangeNotification::new()
    }

    fn clear(&mut self) {
        self.host_name = ::std::option::Option::None;
        self.user_name = ::std::option::Option::None;
        self.directory = ::std::option::Option::None;
        self.session = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LocationChangeNotification {
        static instance: LocationChangeNotification = LocationChangeNotification {
            host_name: ::std::option::Option::None,
            user_name: ::std::option::Option::None,
            directory: ::std::option::Option::None,
            session: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LocationChangeNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LocationChangeNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LocationChangeNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocationChangeNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.CustomEscapeSequenceNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CustomEscapeSequenceNotification {
    // message fields
    // @@protoc_insertion_point(field:iterm2.CustomEscapeSequenceNotification.session)
    pub session: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.CustomEscapeSequenceNotification.sender_identity)
    pub sender_identity: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.CustomEscapeSequenceNotification.payload)
    pub payload: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.CustomEscapeSequenceNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CustomEscapeSequenceNotification {
    fn default() -> &'a CustomEscapeSequenceNotification {
        <CustomEscapeSequenceNotification as ::protobuf::Message>::default_instance()
    }
}

impl CustomEscapeSequenceNotification {
    pub fn new() -> CustomEscapeSequenceNotification {
        ::std::default::Default::default()
    }

    // optional string session = 1;

    pub fn session(&self) -> &str {
        match self.session.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::string::String) {
        self.session = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session(&mut self) -> &mut ::std::string::String {
        if self.session.is_none() {
            self.session = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session.as_mut().unwrap()
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::string::String {
        self.session.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sender_identity = 2;

    pub fn sender_identity(&self) -> &str {
        match self.sender_identity.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sender_identity(&mut self) {
        self.sender_identity = ::std::option::Option::None;
    }

    pub fn has_sender_identity(&self) -> bool {
        self.sender_identity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_identity(&mut self, v: ::std::string::String) {
        self.sender_identity = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_identity(&mut self) -> &mut ::std::string::String {
        if self.sender_identity.is_none() {
            self.sender_identity = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sender_identity.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_identity(&mut self) -> ::std::string::String {
        self.sender_identity.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string payload = 3;

    pub fn payload(&self) -> &str {
        match self.payload.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::string::String) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::string::String {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::string::String::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::string::String {
        self.payload.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &CustomEscapeSequenceNotification| { &m.session },
            |m: &mut CustomEscapeSequenceNotification| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sender_identity",
            |m: &CustomEscapeSequenceNotification| { &m.sender_identity },
            |m: &mut CustomEscapeSequenceNotification| { &mut m.sender_identity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &CustomEscapeSequenceNotification| { &m.payload },
            |m: &mut CustomEscapeSequenceNotification| { &mut m.payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomEscapeSequenceNotification>(
            "CustomEscapeSequenceNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CustomEscapeSequenceNotification {
    const NAME: &'static str = "CustomEscapeSequenceNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.sender_identity = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.payload = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sender_identity.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.sender_identity.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CustomEscapeSequenceNotification {
        CustomEscapeSequenceNotification::new()
    }

    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.sender_identity = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CustomEscapeSequenceNotification {
        static instance: CustomEscapeSequenceNotification = CustomEscapeSequenceNotification {
            session: ::std::option::Option::None,
            sender_identity: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CustomEscapeSequenceNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CustomEscapeSequenceNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CustomEscapeSequenceNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomEscapeSequenceNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.NewSessionNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NewSessionNotification {
    // message fields
    // @@protoc_insertion_point(field:iterm2.NewSessionNotification.session_id)
    pub session_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.NewSessionNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NewSessionNotification {
    fn default() -> &'a NewSessionNotification {
        <NewSessionNotification as ::protobuf::Message>::default_instance()
    }
}

impl NewSessionNotification {
    pub fn new() -> NewSessionNotification {
        ::std::default::Default::default()
    }

    // optional string session_id = 1;

    pub fn session_id(&self) -> &str {
        match self.session_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::string::String) {
        self.session_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
        if self.session_id.is_none() {
            self.session_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::string::String {
        self.session_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_id",
            |m: &NewSessionNotification| { &m.session_id },
            |m: &mut NewSessionNotification| { &mut m.session_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NewSessionNotification>(
            "NewSessionNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NewSessionNotification {
    const NAME: &'static str = "NewSessionNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session_id.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NewSessionNotification {
        NewSessionNotification::new()
    }

    fn clear(&mut self) {
        self.session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NewSessionNotification {
        static instance: NewSessionNotification = NewSessionNotification {
            session_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NewSessionNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NewSessionNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NewSessionNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewSessionNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.FocusChangedNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FocusChangedNotification {
    // message oneof groups
    pub event: ::std::option::Option<focus_changed_notification::Event>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.FocusChangedNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FocusChangedNotification {
    fn default() -> &'a FocusChangedNotification {
        <FocusChangedNotification as ::protobuf::Message>::default_instance()
    }
}

impl FocusChangedNotification {
    pub fn new() -> FocusChangedNotification {
        ::std::default::Default::default()
    }

    // optional bool application_active = 1;

    pub fn application_active(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(focus_changed_notification::Event::ApplicationActive(v)) => v,
            _ => false,
        }
    }

    pub fn clear_application_active(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_application_active(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(focus_changed_notification::Event::ApplicationActive(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_application_active(&mut self, v: bool) {
        self.event = ::std::option::Option::Some(focus_changed_notification::Event::ApplicationActive(v))
    }

    // optional .iterm2.FocusChangedNotification.Window window = 2;

    pub fn window(&self) -> &focus_changed_notification::Window {
        match self.event {
            ::std::option::Option::Some(focus_changed_notification::Event::Window(ref v)) => v,
            _ => <focus_changed_notification::Window as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_window(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_window(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(focus_changed_notification::Event::Window(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_window(&mut self, v: focus_changed_notification::Window) {
        self.event = ::std::option::Option::Some(focus_changed_notification::Event::Window(v))
    }

    // Mutable pointer to the field.
    pub fn mut_window(&mut self) -> &mut focus_changed_notification::Window {
        if let ::std::option::Option::Some(focus_changed_notification::Event::Window(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(focus_changed_notification::Event::Window(focus_changed_notification::Window::new()));
        }
        match self.event {
            ::std::option::Option::Some(focus_changed_notification::Event::Window(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_window(&mut self) -> focus_changed_notification::Window {
        if self.has_window() {
            match self.event.take() {
                ::std::option::Option::Some(focus_changed_notification::Event::Window(v)) => v,
                _ => panic!(),
            }
        } else {
            focus_changed_notification::Window::new()
        }
    }

    // optional string selected_tab = 3;

    pub fn selected_tab(&self) -> &str {
        match self.event {
            ::std::option::Option::Some(focus_changed_notification::Event::SelectedTab(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_selected_tab(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_selected_tab(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(focus_changed_notification::Event::SelectedTab(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_selected_tab(&mut self, v: ::std::string::String) {
        self.event = ::std::option::Option::Some(focus_changed_notification::Event::SelectedTab(v))
    }

    // Mutable pointer to the field.
    pub fn mut_selected_tab(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(focus_changed_notification::Event::SelectedTab(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(focus_changed_notification::Event::SelectedTab(::std::string::String::new()));
        }
        match self.event {
            ::std::option::Option::Some(focus_changed_notification::Event::SelectedTab(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_selected_tab(&mut self) -> ::std::string::String {
        if self.has_selected_tab() {
            match self.event.take() {
                ::std::option::Option::Some(focus_changed_notification::Event::SelectedTab(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional string session = 4;

    pub fn session(&self) -> &str {
        match self.event {
            ::std::option::Option::Some(focus_changed_notification::Event::Session(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_session(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(focus_changed_notification::Event::Session(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::string::String) {
        self.event = ::std::option::Option::Some(focus_changed_notification::Event::Session(v))
    }

    // Mutable pointer to the field.
    pub fn mut_session(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(focus_changed_notification::Event::Session(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(focus_changed_notification::Event::Session(::std::string::String::new()));
        }
        match self.event {
            ::std::option::Option::Some(focus_changed_notification::Event::Session(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::string::String {
        if self.has_session() {
            match self.event.take() {
                ::std::option::Option::Some(focus_changed_notification::Event::Session(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "application_active",
            FocusChangedNotification::has_application_active,
            FocusChangedNotification::application_active,
            FocusChangedNotification::set_application_active,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, focus_changed_notification::Window>(
            "window",
            FocusChangedNotification::has_window,
            FocusChangedNotification::window,
            FocusChangedNotification::mut_window,
            FocusChangedNotification::set_window,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "selected_tab",
            FocusChangedNotification::has_selected_tab,
            FocusChangedNotification::selected_tab,
            FocusChangedNotification::set_selected_tab,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "session",
            FocusChangedNotification::has_session,
            FocusChangedNotification::session,
            FocusChangedNotification::set_session,
        ));
        oneofs.push(focus_changed_notification::Event::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FocusChangedNotification>(
            "FocusChangedNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FocusChangedNotification {
    const NAME: &'static str = "FocusChangedNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event = ::std::option::Option::Some(focus_changed_notification::Event::ApplicationActive(is.read_bool()?));
                },
                18 => {
                    self.event = ::std::option::Option::Some(focus_changed_notification::Event::Window(is.read_message()?));
                },
                26 => {
                    self.event = ::std::option::Option::Some(focus_changed_notification::Event::SelectedTab(is.read_string()?));
                },
                34 => {
                    self.event = ::std::option::Option::Some(focus_changed_notification::Event::Session(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.event {
            match v {
                &focus_changed_notification::Event::ApplicationActive(v) => {
                    my_size += 1 + 1;
                },
                &focus_changed_notification::Event::Window(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &focus_changed_notification::Event::SelectedTab(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
                &focus_changed_notification::Event::Session(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.event {
            match v {
                &focus_changed_notification::Event::ApplicationActive(v) => {
                    os.write_bool(1, v)?;
                },
                &focus_changed_notification::Event::Window(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &focus_changed_notification::Event::SelectedTab(ref v) => {
                    os.write_string(3, v)?;
                },
                &focus_changed_notification::Event::Session(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FocusChangedNotification {
        FocusChangedNotification::new()
    }

    fn clear(&mut self) {
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FocusChangedNotification {
        static instance: FocusChangedNotification = FocusChangedNotification {
            event: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FocusChangedNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FocusChangedNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FocusChangedNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FocusChangedNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FocusChangedNotification`
pub mod focus_changed_notification {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.FocusChangedNotification.event)
    pub enum Event {
        // @@protoc_insertion_point(oneof_field:iterm2.FocusChangedNotification.application_active)
        ApplicationActive(bool),
        // @@protoc_insertion_point(oneof_field:iterm2.FocusChangedNotification.window)
        Window(Window),
        // @@protoc_insertion_point(oneof_field:iterm2.FocusChangedNotification.selected_tab)
        SelectedTab(::std::string::String),
        // @@protoc_insertion_point(oneof_field:iterm2.FocusChangedNotification.session)
        Session(::std::string::String),
    }

    impl ::protobuf::Oneof for Event {
    }

    impl ::protobuf::OneofFull for Event {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::FocusChangedNotification as ::protobuf::MessageFull>::descriptor().oneof_by_name("event").unwrap()).clone()
        }
    }

    impl Event {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Event>("event")
        }
    }
    // @@protoc_insertion_point(message:iterm2.FocusChangedNotification.Window)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Window {
        // message fields
        // @@protoc_insertion_point(field:iterm2.FocusChangedNotification.Window.window_status)
        pub window_status: ::std::option::Option<::protobuf::EnumOrUnknown<window::WindowStatus>>,
        // @@protoc_insertion_point(field:iterm2.FocusChangedNotification.Window.window_id)
        pub window_id: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.FocusChangedNotification.Window.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Window {
        fn default() -> &'a Window {
            <Window as ::protobuf::Message>::default_instance()
        }
    }

    impl Window {
        pub fn new() -> Window {
            ::std::default::Default::default()
        }

        // optional .iterm2.FocusChangedNotification.Window.WindowStatus window_status = 1;

        pub fn window_status(&self) -> window::WindowStatus {
            match self.window_status {
                Some(e) => e.enum_value_or(window::WindowStatus::TERMINAL_WINDOW_BECAME_KEY),
                None => window::WindowStatus::TERMINAL_WINDOW_BECAME_KEY,
            }
        }

        pub fn clear_window_status(&mut self) {
            self.window_status = ::std::option::Option::None;
        }

        pub fn has_window_status(&self) -> bool {
            self.window_status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_window_status(&mut self, v: window::WindowStatus) {
            self.window_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string window_id = 2;

        pub fn window_id(&self) -> &str {
            match self.window_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_window_id(&mut self) {
            self.window_id = ::std::option::Option::None;
        }

        pub fn has_window_id(&self) -> bool {
            self.window_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_window_id(&mut self, v: ::std::string::String) {
            self.window_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_window_id(&mut self) -> &mut ::std::string::String {
            if self.window_id.is_none() {
                self.window_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.window_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_window_id(&mut self) -> ::std::string::String {
            self.window_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "window_status",
                |m: &Window| { &m.window_status },
                |m: &mut Window| { &mut m.window_status },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "window_id",
                |m: &Window| { &m.window_id },
                |m: &mut Window| { &mut m.window_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Window>(
                "FocusChangedNotification.Window",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Window {
        const NAME: &'static str = "Window";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.window_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        self.window_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.window_status {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.window_id.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.window_status {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.window_id.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Window {
            Window::new()
        }

        fn clear(&mut self) {
            self.window_status = ::std::option::Option::None;
            self.window_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Window {
            static instance: Window = Window {
                window_status: ::std::option::Option::None,
                window_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Window {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("FocusChangedNotification.Window").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Window {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Window {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Window`
    pub mod window {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:iterm2.FocusChangedNotification.Window.WindowStatus)
        pub enum WindowStatus {
            // @@protoc_insertion_point(enum_value:iterm2.FocusChangedNotification.Window.WindowStatus.TERMINAL_WINDOW_BECAME_KEY)
            TERMINAL_WINDOW_BECAME_KEY = 0,
            // @@protoc_insertion_point(enum_value:iterm2.FocusChangedNotification.Window.WindowStatus.TERMINAL_WINDOW_IS_CURRENT)
            TERMINAL_WINDOW_IS_CURRENT = 1,
            // @@protoc_insertion_point(enum_value:iterm2.FocusChangedNotification.Window.WindowStatus.TERMINAL_WINDOW_RESIGNED_KEY)
            TERMINAL_WINDOW_RESIGNED_KEY = 2,
        }

        impl ::protobuf::Enum for WindowStatus {
            const NAME: &'static str = "WindowStatus";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<WindowStatus> {
                match value {
                    0 => ::std::option::Option::Some(WindowStatus::TERMINAL_WINDOW_BECAME_KEY),
                    1 => ::std::option::Option::Some(WindowStatus::TERMINAL_WINDOW_IS_CURRENT),
                    2 => ::std::option::Option::Some(WindowStatus::TERMINAL_WINDOW_RESIGNED_KEY),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<WindowStatus> {
                match str {
                    "TERMINAL_WINDOW_BECAME_KEY" => ::std::option::Option::Some(WindowStatus::TERMINAL_WINDOW_BECAME_KEY),
                    "TERMINAL_WINDOW_IS_CURRENT" => ::std::option::Option::Some(WindowStatus::TERMINAL_WINDOW_IS_CURRENT),
                    "TERMINAL_WINDOW_RESIGNED_KEY" => ::std::option::Option::Some(WindowStatus::TERMINAL_WINDOW_RESIGNED_KEY),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [WindowStatus] = &[
                WindowStatus::TERMINAL_WINDOW_BECAME_KEY,
                WindowStatus::TERMINAL_WINDOW_IS_CURRENT,
                WindowStatus::TERMINAL_WINDOW_RESIGNED_KEY,
            ];
        }

        impl ::protobuf::EnumFull for WindowStatus {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("FocusChangedNotification.Window.WindowStatus").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for WindowStatus {
            fn default() -> Self {
                WindowStatus::TERMINAL_WINDOW_BECAME_KEY
            }
        }

        impl WindowStatus {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WindowStatus>("FocusChangedNotification.Window.WindowStatus")
            }
        }
    }
}

// @@protoc_insertion_point(message:iterm2.TerminateSessionNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TerminateSessionNotification {
    // message fields
    // @@protoc_insertion_point(field:iterm2.TerminateSessionNotification.session_id)
    pub session_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.TerminateSessionNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TerminateSessionNotification {
    fn default() -> &'a TerminateSessionNotification {
        <TerminateSessionNotification as ::protobuf::Message>::default_instance()
    }
}

impl TerminateSessionNotification {
    pub fn new() -> TerminateSessionNotification {
        ::std::default::Default::default()
    }

    // optional string session_id = 1;

    pub fn session_id(&self) -> &str {
        match self.session_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::string::String) {
        self.session_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
        if self.session_id.is_none() {
            self.session_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::string::String {
        self.session_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_id",
            |m: &TerminateSessionNotification| { &m.session_id },
            |m: &mut TerminateSessionNotification| { &mut m.session_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TerminateSessionNotification>(
            "TerminateSessionNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TerminateSessionNotification {
    const NAME: &'static str = "TerminateSessionNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session_id.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TerminateSessionNotification {
        TerminateSessionNotification::new()
    }

    fn clear(&mut self) {
        self.session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TerminateSessionNotification {
        static instance: TerminateSessionNotification = TerminateSessionNotification {
            session_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TerminateSessionNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TerminateSessionNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TerminateSessionNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TerminateSessionNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.LayoutChangedNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LayoutChangedNotification {
    // message fields
    // @@protoc_insertion_point(field:iterm2.LayoutChangedNotification.list_sessions_response)
    pub list_sessions_response: ::protobuf::MessageField<ListSessionsResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.LayoutChangedNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LayoutChangedNotification {
    fn default() -> &'a LayoutChangedNotification {
        <LayoutChangedNotification as ::protobuf::Message>::default_instance()
    }
}

impl LayoutChangedNotification {
    pub fn new() -> LayoutChangedNotification {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListSessionsResponse>(
            "list_sessions_response",
            |m: &LayoutChangedNotification| { &m.list_sessions_response },
            |m: &mut LayoutChangedNotification| { &mut m.list_sessions_response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LayoutChangedNotification>(
            "LayoutChangedNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LayoutChangedNotification {
    const NAME: &'static str = "LayoutChangedNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.list_sessions_response)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.list_sessions_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.list_sessions_response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LayoutChangedNotification {
        LayoutChangedNotification::new()
    }

    fn clear(&mut self) {
        self.list_sessions_response.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LayoutChangedNotification {
        static instance: LayoutChangedNotification = LayoutChangedNotification {
            list_sessions_response: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LayoutChangedNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LayoutChangedNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LayoutChangedNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LayoutChangedNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.GetBufferRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBufferRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.GetBufferRequest.session)
    pub session: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.GetBufferRequest.line_range)
    pub line_range: ::protobuf::MessageField<LineRange>,
    // @@protoc_insertion_point(field:iterm2.GetBufferRequest.include_styles)
    pub include_styles: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.GetBufferRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBufferRequest {
    fn default() -> &'a GetBufferRequest {
        <GetBufferRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBufferRequest {
    pub fn new() -> GetBufferRequest {
        ::std::default::Default::default()
    }

    // optional string session = 1;

    pub fn session(&self) -> &str {
        match self.session.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::string::String) {
        self.session = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session(&mut self) -> &mut ::std::string::String {
        if self.session.is_none() {
            self.session = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session.as_mut().unwrap()
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::string::String {
        self.session.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool include_styles = 3;

    pub fn include_styles(&self) -> bool {
        self.include_styles.unwrap_or(false)
    }

    pub fn clear_include_styles(&mut self) {
        self.include_styles = ::std::option::Option::None;
    }

    pub fn has_include_styles(&self) -> bool {
        self.include_styles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_styles(&mut self, v: bool) {
        self.include_styles = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &GetBufferRequest| { &m.session },
            |m: &mut GetBufferRequest| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LineRange>(
            "line_range",
            |m: &GetBufferRequest| { &m.line_range },
            |m: &mut GetBufferRequest| { &mut m.line_range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_styles",
            |m: &GetBufferRequest| { &m.include_styles },
            |m: &mut GetBufferRequest| { &mut m.include_styles },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBufferRequest>(
            "GetBufferRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBufferRequest {
    const NAME: &'static str = "GetBufferRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.line_range)?;
                },
                24 => {
                    self.include_styles = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.line_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.include_styles {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.line_range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.include_styles {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBufferRequest {
        GetBufferRequest::new()
    }

    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.line_range.clear();
        self.include_styles = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBufferRequest {
        static instance: GetBufferRequest = GetBufferRequest {
            session: ::std::option::Option::None,
            line_range: ::protobuf::MessageField::none(),
            include_styles: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBufferRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBufferRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBufferRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBufferRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.GetBufferResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBufferResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.GetBufferResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<get_buffer_response::Status>>,
    // @@protoc_insertion_point(field:iterm2.GetBufferResponse.range)
    pub range: ::protobuf::MessageField<Range>,
    // @@protoc_insertion_point(field:iterm2.GetBufferResponse.contents)
    pub contents: ::std::vec::Vec<LineContents>,
    // @@protoc_insertion_point(field:iterm2.GetBufferResponse.cursor)
    pub cursor: ::protobuf::MessageField<Coord>,
    // @@protoc_insertion_point(field:iterm2.GetBufferResponse.num_lines_above_screen)
    pub num_lines_above_screen: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:iterm2.GetBufferResponse.windowed_coord_range)
    pub windowed_coord_range: ::protobuf::MessageField<WindowedCoordRange>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.GetBufferResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBufferResponse {
    fn default() -> &'a GetBufferResponse {
        <GetBufferResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBufferResponse {
    pub fn new() -> GetBufferResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.GetBufferResponse.Status status = 1;

    pub fn status(&self) -> get_buffer_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(get_buffer_response::Status::OK),
            None => get_buffer_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: get_buffer_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 num_lines_above_screen = 5;

    pub fn num_lines_above_screen(&self) -> i64 {
        self.num_lines_above_screen.unwrap_or(0)
    }

    pub fn clear_num_lines_above_screen(&mut self) {
        self.num_lines_above_screen = ::std::option::Option::None;
    }

    pub fn has_num_lines_above_screen(&self) -> bool {
        self.num_lines_above_screen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_lines_above_screen(&mut self, v: i64) {
        self.num_lines_above_screen = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &GetBufferResponse| { &m.status },
            |m: &mut GetBufferResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Range>(
            "range",
            |m: &GetBufferResponse| { &m.range },
            |m: &mut GetBufferResponse| { &mut m.range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "contents",
            |m: &GetBufferResponse| { &m.contents },
            |m: &mut GetBufferResponse| { &mut m.contents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Coord>(
            "cursor",
            |m: &GetBufferResponse| { &m.cursor },
            |m: &mut GetBufferResponse| { &mut m.cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_lines_above_screen",
            |m: &GetBufferResponse| { &m.num_lines_above_screen },
            |m: &mut GetBufferResponse| { &mut m.num_lines_above_screen },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WindowedCoordRange>(
            "windowed_coord_range",
            |m: &GetBufferResponse| { &m.windowed_coord_range },
            |m: &mut GetBufferResponse| { &mut m.windowed_coord_range },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBufferResponse>(
            "GetBufferResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBufferResponse {
    const NAME: &'static str = "GetBufferResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.range)?;
                },
                26 => {
                    self.contents.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cursor)?;
                },
                40 => {
                    self.num_lines_above_screen = ::std::option::Option::Some(is.read_int64()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.windowed_coord_range)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.contents {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.cursor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.num_lines_above_screen {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.windowed_coord_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.contents {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.cursor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.num_lines_above_screen {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.windowed_coord_range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBufferResponse {
        GetBufferResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.range.clear();
        self.contents.clear();
        self.cursor.clear();
        self.num_lines_above_screen = ::std::option::Option::None;
        self.windowed_coord_range.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBufferResponse {
        static instance: GetBufferResponse = GetBufferResponse {
            status: ::std::option::Option::None,
            range: ::protobuf::MessageField::none(),
            contents: ::std::vec::Vec::new(),
            cursor: ::protobuf::MessageField::none(),
            num_lines_above_screen: ::std::option::Option::None,
            windowed_coord_range: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBufferResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBufferResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBufferResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBufferResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GetBufferResponse`
pub mod get_buffer_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.GetBufferResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.GetBufferResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.GetBufferResponse.Status.SESSION_NOT_FOUND)
        SESSION_NOT_FOUND = 1,
        // @@protoc_insertion_point(enum_value:iterm2.GetBufferResponse.Status.INVALID_LINE_RANGE)
        INVALID_LINE_RANGE = 2,
        // @@protoc_insertion_point(enum_value:iterm2.GetBufferResponse.Status.REQUEST_MALFORMED)
        REQUEST_MALFORMED = 3,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                2 => ::std::option::Option::Some(Status::INVALID_LINE_RANGE),
                3 => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "SESSION_NOT_FOUND" => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                "INVALID_LINE_RANGE" => ::std::option::Option::Some(Status::INVALID_LINE_RANGE),
                "REQUEST_MALFORMED" => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::SESSION_NOT_FOUND,
            Status::INVALID_LINE_RANGE,
            Status::REQUEST_MALFORMED,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("GetBufferResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("GetBufferResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.GetPromptRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetPromptRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.GetPromptRequest.session)
    pub session: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.GetPromptRequest.unique_prompt_id)
    pub unique_prompt_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.GetPromptRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetPromptRequest {
    fn default() -> &'a GetPromptRequest {
        <GetPromptRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPromptRequest {
    pub fn new() -> GetPromptRequest {
        ::std::default::Default::default()
    }

    // optional string session = 1;

    pub fn session(&self) -> &str {
        match self.session.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::string::String) {
        self.session = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session(&mut self) -> &mut ::std::string::String {
        if self.session.is_none() {
            self.session = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session.as_mut().unwrap()
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::string::String {
        self.session.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string unique_prompt_id = 2;

    pub fn unique_prompt_id(&self) -> &str {
        match self.unique_prompt_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_prompt_id(&mut self) {
        self.unique_prompt_id = ::std::option::Option::None;
    }

    pub fn has_unique_prompt_id(&self) -> bool {
        self.unique_prompt_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_prompt_id(&mut self, v: ::std::string::String) {
        self.unique_prompt_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_prompt_id(&mut self) -> &mut ::std::string::String {
        if self.unique_prompt_id.is_none() {
            self.unique_prompt_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_prompt_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_prompt_id(&mut self) -> ::std::string::String {
        self.unique_prompt_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &GetPromptRequest| { &m.session },
            |m: &mut GetPromptRequest| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unique_prompt_id",
            |m: &GetPromptRequest| { &m.unique_prompt_id },
            |m: &mut GetPromptRequest| { &mut m.unique_prompt_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetPromptRequest>(
            "GetPromptRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetPromptRequest {
    const NAME: &'static str = "GetPromptRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.unique_prompt_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.unique_prompt_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.unique_prompt_id.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetPromptRequest {
        GetPromptRequest::new()
    }

    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.unique_prompt_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetPromptRequest {
        static instance: GetPromptRequest = GetPromptRequest {
            session: ::std::option::Option::None,
            unique_prompt_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetPromptRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetPromptRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetPromptRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPromptRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.GetPromptResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetPromptResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.GetPromptResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<get_prompt_response::Status>>,
    // @@protoc_insertion_point(field:iterm2.GetPromptResponse.prompt_range)
    pub prompt_range: ::protobuf::MessageField<CoordRange>,
    // @@protoc_insertion_point(field:iterm2.GetPromptResponse.command_range)
    pub command_range: ::protobuf::MessageField<CoordRange>,
    // @@protoc_insertion_point(field:iterm2.GetPromptResponse.output_range)
    pub output_range: ::protobuf::MessageField<CoordRange>,
    // @@protoc_insertion_point(field:iterm2.GetPromptResponse.working_directory)
    pub working_directory: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.GetPromptResponse.command)
    pub command: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.GetPromptResponse.prompt_state)
    pub prompt_state: ::std::option::Option<::protobuf::EnumOrUnknown<get_prompt_response::State>>,
    // @@protoc_insertion_point(field:iterm2.GetPromptResponse.exit_status)
    pub exit_status: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:iterm2.GetPromptResponse.unique_prompt_id)
    pub unique_prompt_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.GetPromptResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetPromptResponse {
    fn default() -> &'a GetPromptResponse {
        <GetPromptResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPromptResponse {
    pub fn new() -> GetPromptResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.GetPromptResponse.Status status = 1;

    pub fn status(&self) -> get_prompt_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(get_prompt_response::Status::OK),
            None => get_prompt_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: get_prompt_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string working_directory = 5;

    pub fn working_directory(&self) -> &str {
        match self.working_directory.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_working_directory(&mut self) {
        self.working_directory = ::std::option::Option::None;
    }

    pub fn has_working_directory(&self) -> bool {
        self.working_directory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_working_directory(&mut self, v: ::std::string::String) {
        self.working_directory = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_working_directory(&mut self) -> &mut ::std::string::String {
        if self.working_directory.is_none() {
            self.working_directory = ::std::option::Option::Some(::std::string::String::new());
        }
        self.working_directory.as_mut().unwrap()
    }

    // Take field
    pub fn take_working_directory(&mut self) -> ::std::string::String {
        self.working_directory.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string command = 6;

    pub fn command(&self) -> &str {
        match self.command.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::std::string::String) {
        self.command = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut ::std::string::String {
        if self.command.is_none() {
            self.command = ::std::option::Option::Some(::std::string::String::new());
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> ::std::string::String {
        self.command.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .iterm2.GetPromptResponse.State prompt_state = 7;

    pub fn prompt_state(&self) -> get_prompt_response::State {
        match self.prompt_state {
            Some(e) => e.enum_value_or(get_prompt_response::State::EDITING),
            None => get_prompt_response::State::EDITING,
        }
    }

    pub fn clear_prompt_state(&mut self) {
        self.prompt_state = ::std::option::Option::None;
    }

    pub fn has_prompt_state(&self) -> bool {
        self.prompt_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prompt_state(&mut self, v: get_prompt_response::State) {
        self.prompt_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 exit_status = 9;

    pub fn exit_status(&self) -> u32 {
        self.exit_status.unwrap_or(0)
    }

    pub fn clear_exit_status(&mut self) {
        self.exit_status = ::std::option::Option::None;
    }

    pub fn has_exit_status(&self) -> bool {
        self.exit_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exit_status(&mut self, v: u32) {
        self.exit_status = ::std::option::Option::Some(v);
    }

    // optional string unique_prompt_id = 10;

    pub fn unique_prompt_id(&self) -> &str {
        match self.unique_prompt_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_prompt_id(&mut self) {
        self.unique_prompt_id = ::std::option::Option::None;
    }

    pub fn has_unique_prompt_id(&self) -> bool {
        self.unique_prompt_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_prompt_id(&mut self, v: ::std::string::String) {
        self.unique_prompt_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_prompt_id(&mut self) -> &mut ::std::string::String {
        if self.unique_prompt_id.is_none() {
            self.unique_prompt_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_prompt_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_prompt_id(&mut self) -> ::std::string::String {
        self.unique_prompt_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &GetPromptResponse| { &m.status },
            |m: &mut GetPromptResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CoordRange>(
            "prompt_range",
            |m: &GetPromptResponse| { &m.prompt_range },
            |m: &mut GetPromptResponse| { &mut m.prompt_range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CoordRange>(
            "command_range",
            |m: &GetPromptResponse| { &m.command_range },
            |m: &mut GetPromptResponse| { &mut m.command_range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CoordRange>(
            "output_range",
            |m: &GetPromptResponse| { &m.output_range },
            |m: &mut GetPromptResponse| { &mut m.output_range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "working_directory",
            |m: &GetPromptResponse| { &m.working_directory },
            |m: &mut GetPromptResponse| { &mut m.working_directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command",
            |m: &GetPromptResponse| { &m.command },
            |m: &mut GetPromptResponse| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prompt_state",
            |m: &GetPromptResponse| { &m.prompt_state },
            |m: &mut GetPromptResponse| { &mut m.prompt_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "exit_status",
            |m: &GetPromptResponse| { &m.exit_status },
            |m: &mut GetPromptResponse| { &mut m.exit_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unique_prompt_id",
            |m: &GetPromptResponse| { &m.unique_prompt_id },
            |m: &mut GetPromptResponse| { &mut m.unique_prompt_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetPromptResponse>(
            "GetPromptResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetPromptResponse {
    const NAME: &'static str = "GetPromptResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.prompt_range)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.command_range)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.output_range)?;
                },
                42 => {
                    self.working_directory = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.command = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.prompt_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.exit_status = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.unique_prompt_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.prompt_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.command_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.output_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.working_directory.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.command.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.prompt_state {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.exit_status {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.unique_prompt_id.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.prompt_range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.command_range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.output_range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.working_directory.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.command.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.prompt_state {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.exit_status {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.unique_prompt_id.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetPromptResponse {
        GetPromptResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.prompt_range.clear();
        self.command_range.clear();
        self.output_range.clear();
        self.working_directory = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.prompt_state = ::std::option::Option::None;
        self.exit_status = ::std::option::Option::None;
        self.unique_prompt_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetPromptResponse {
        static instance: GetPromptResponse = GetPromptResponse {
            status: ::std::option::Option::None,
            prompt_range: ::protobuf::MessageField::none(),
            command_range: ::protobuf::MessageField::none(),
            output_range: ::protobuf::MessageField::none(),
            working_directory: ::std::option::Option::None,
            command: ::std::option::Option::None,
            prompt_state: ::std::option::Option::None,
            exit_status: ::std::option::Option::None,
            unique_prompt_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetPromptResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetPromptResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetPromptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPromptResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GetPromptResponse`
pub mod get_prompt_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.GetPromptResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.GetPromptResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.GetPromptResponse.Status.SESSION_NOT_FOUND)
        SESSION_NOT_FOUND = 1,
        // @@protoc_insertion_point(enum_value:iterm2.GetPromptResponse.Status.REQUEST_MALFORMED)
        REQUEST_MALFORMED = 2,
        // @@protoc_insertion_point(enum_value:iterm2.GetPromptResponse.Status.PROMPT_UNAVAILABLE)
        PROMPT_UNAVAILABLE = 3,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                2 => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                3 => ::std::option::Option::Some(Status::PROMPT_UNAVAILABLE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "SESSION_NOT_FOUND" => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                "REQUEST_MALFORMED" => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                "PROMPT_UNAVAILABLE" => ::std::option::Option::Some(Status::PROMPT_UNAVAILABLE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::SESSION_NOT_FOUND,
            Status::REQUEST_MALFORMED,
            Status::PROMPT_UNAVAILABLE,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("GetPromptResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("GetPromptResponse.Status")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.GetPromptResponse.State)
    pub enum State {
        // @@protoc_insertion_point(enum_value:iterm2.GetPromptResponse.State.EDITING)
        EDITING = 0,
        // @@protoc_insertion_point(enum_value:iterm2.GetPromptResponse.State.RUNNING)
        RUNNING = 1,
        // @@protoc_insertion_point(enum_value:iterm2.GetPromptResponse.State.FINISHED)
        FINISHED = 2,
    }

    impl ::protobuf::Enum for State {
        const NAME: &'static str = "State";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<State> {
            match value {
                0 => ::std::option::Option::Some(State::EDITING),
                1 => ::std::option::Option::Some(State::RUNNING),
                2 => ::std::option::Option::Some(State::FINISHED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<State> {
            match str {
                "EDITING" => ::std::option::Option::Some(State::EDITING),
                "RUNNING" => ::std::option::Option::Some(State::RUNNING),
                "FINISHED" => ::std::option::Option::Some(State::FINISHED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [State] = &[
            State::EDITING,
            State::RUNNING,
            State::FINISHED,
        ];
    }

    impl ::protobuf::EnumFull for State {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("GetPromptResponse.State").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for State {
        fn default() -> Self {
            State::EDITING
        }
    }

    impl State {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<State>("GetPromptResponse.State")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.ListPromptsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListPromptsRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ListPromptsRequest.session)
    pub session: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.ListPromptsRequest.first_unique_id)
    pub first_unique_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.ListPromptsRequest.last_unique_id)
    pub last_unique_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ListPromptsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListPromptsRequest {
    fn default() -> &'a ListPromptsRequest {
        <ListPromptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListPromptsRequest {
    pub fn new() -> ListPromptsRequest {
        ::std::default::Default::default()
    }

    // optional string session = 1;

    pub fn session(&self) -> &str {
        match self.session.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::string::String) {
        self.session = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session(&mut self) -> &mut ::std::string::String {
        if self.session.is_none() {
            self.session = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session.as_mut().unwrap()
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::string::String {
        self.session.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string first_unique_id = 2;

    pub fn first_unique_id(&self) -> &str {
        match self.first_unique_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_first_unique_id(&mut self) {
        self.first_unique_id = ::std::option::Option::None;
    }

    pub fn has_first_unique_id(&self) -> bool {
        self.first_unique_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_unique_id(&mut self, v: ::std::string::String) {
        self.first_unique_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_first_unique_id(&mut self) -> &mut ::std::string::String {
        if self.first_unique_id.is_none() {
            self.first_unique_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.first_unique_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_first_unique_id(&mut self) -> ::std::string::String {
        self.first_unique_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string last_unique_id = 3;

    pub fn last_unique_id(&self) -> &str {
        match self.last_unique_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_last_unique_id(&mut self) {
        self.last_unique_id = ::std::option::Option::None;
    }

    pub fn has_last_unique_id(&self) -> bool {
        self.last_unique_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_unique_id(&mut self, v: ::std::string::String) {
        self.last_unique_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_unique_id(&mut self) -> &mut ::std::string::String {
        if self.last_unique_id.is_none() {
            self.last_unique_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.last_unique_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_unique_id(&mut self) -> ::std::string::String {
        self.last_unique_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &ListPromptsRequest| { &m.session },
            |m: &mut ListPromptsRequest| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_unique_id",
            |m: &ListPromptsRequest| { &m.first_unique_id },
            |m: &mut ListPromptsRequest| { &mut m.first_unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_unique_id",
            |m: &ListPromptsRequest| { &m.last_unique_id },
            |m: &mut ListPromptsRequest| { &mut m.last_unique_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListPromptsRequest>(
            "ListPromptsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListPromptsRequest {
    const NAME: &'static str = "ListPromptsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.first_unique_id = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.last_unique_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.first_unique_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.last_unique_id.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.first_unique_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.last_unique_id.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListPromptsRequest {
        ListPromptsRequest::new()
    }

    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.first_unique_id = ::std::option::Option::None;
        self.last_unique_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListPromptsRequest {
        static instance: ListPromptsRequest = ListPromptsRequest {
            session: ::std::option::Option::None,
            first_unique_id: ::std::option::Option::None,
            last_unique_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListPromptsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListPromptsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListPromptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPromptsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.ListPromptsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListPromptsResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ListPromptsResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<list_prompts_response::Status>>,
    // @@protoc_insertion_point(field:iterm2.ListPromptsResponse.unique_prompt_id)
    pub unique_prompt_id: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ListPromptsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListPromptsResponse {
    fn default() -> &'a ListPromptsResponse {
        <ListPromptsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPromptsResponse {
    pub fn new() -> ListPromptsResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.ListPromptsResponse.Status status = 1;

    pub fn status(&self) -> list_prompts_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(list_prompts_response::Status::OK),
            None => list_prompts_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: list_prompts_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &ListPromptsResponse| { &m.status },
            |m: &mut ListPromptsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unique_prompt_id",
            |m: &ListPromptsResponse| { &m.unique_prompt_id },
            |m: &mut ListPromptsResponse| { &mut m.unique_prompt_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListPromptsResponse>(
            "ListPromptsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListPromptsResponse {
    const NAME: &'static str = "ListPromptsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.unique_prompt_id.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.unique_prompt_id {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.unique_prompt_id {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListPromptsResponse {
        ListPromptsResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.unique_prompt_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListPromptsResponse {
        static instance: ListPromptsResponse = ListPromptsResponse {
            status: ::std::option::Option::None,
            unique_prompt_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListPromptsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListPromptsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListPromptsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPromptsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListPromptsResponse`
pub mod list_prompts_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.ListPromptsResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.ListPromptsResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.ListPromptsResponse.Status.SESSION_NOT_FOUND)
        SESSION_NOT_FOUND = 1,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "SESSION_NOT_FOUND" => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::SESSION_NOT_FOUND,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ListPromptsResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("ListPromptsResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.GetProfilePropertyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetProfilePropertyRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.GetProfilePropertyRequest.session)
    pub session: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.GetProfilePropertyRequest.keys)
    pub keys: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.GetProfilePropertyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetProfilePropertyRequest {
    fn default() -> &'a GetProfilePropertyRequest {
        <GetProfilePropertyRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetProfilePropertyRequest {
    pub fn new() -> GetProfilePropertyRequest {
        ::std::default::Default::default()
    }

    // optional string session = 1;

    pub fn session(&self) -> &str {
        match self.session.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::string::String) {
        self.session = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session(&mut self) -> &mut ::std::string::String {
        if self.session.is_none() {
            self.session = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session.as_mut().unwrap()
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::string::String {
        self.session.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &GetProfilePropertyRequest| { &m.session },
            |m: &mut GetProfilePropertyRequest| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &GetProfilePropertyRequest| { &m.keys },
            |m: &mut GetProfilePropertyRequest| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetProfilePropertyRequest>(
            "GetProfilePropertyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetProfilePropertyRequest {
    const NAME: &'static str = "GetProfilePropertyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.keys.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.keys {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.keys {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetProfilePropertyRequest {
        GetProfilePropertyRequest::new()
    }

    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetProfilePropertyRequest {
        static instance: GetProfilePropertyRequest = GetProfilePropertyRequest {
            session: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetProfilePropertyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetProfilePropertyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetProfilePropertyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetProfilePropertyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.ProfileProperty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProfileProperty {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ProfileProperty.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.ProfileProperty.json_value)
    pub json_value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ProfileProperty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProfileProperty {
    fn default() -> &'a ProfileProperty {
        <ProfileProperty as ::protobuf::Message>::default_instance()
    }
}

impl ProfileProperty {
    pub fn new() -> ProfileProperty {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string json_value = 2;

    pub fn json_value(&self) -> &str {
        match self.json_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_json_value(&mut self) {
        self.json_value = ::std::option::Option::None;
    }

    pub fn has_json_value(&self) -> bool {
        self.json_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json_value(&mut self, v: ::std::string::String) {
        self.json_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json_value(&mut self) -> &mut ::std::string::String {
        if self.json_value.is_none() {
            self.json_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.json_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_json_value(&mut self) -> ::std::string::String {
        self.json_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &ProfileProperty| { &m.key },
            |m: &mut ProfileProperty| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "json_value",
            |m: &ProfileProperty| { &m.json_value },
            |m: &mut ProfileProperty| { &mut m.json_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProfileProperty>(
            "ProfileProperty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProfileProperty {
    const NAME: &'static str = "ProfileProperty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.json_value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.json_value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.json_value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProfileProperty {
        ProfileProperty::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.json_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProfileProperty {
        static instance: ProfileProperty = ProfileProperty {
            key: ::std::option::Option::None,
            json_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProfileProperty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProfileProperty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProfileProperty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProfileProperty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.GetProfilePropertyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetProfilePropertyResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.GetProfilePropertyResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<get_profile_property_response::Status>>,
    // @@protoc_insertion_point(field:iterm2.GetProfilePropertyResponse.properties)
    pub properties: ::std::vec::Vec<ProfileProperty>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.GetProfilePropertyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetProfilePropertyResponse {
    fn default() -> &'a GetProfilePropertyResponse {
        <GetProfilePropertyResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetProfilePropertyResponse {
    pub fn new() -> GetProfilePropertyResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.GetProfilePropertyResponse.Status status = 1;

    pub fn status(&self) -> get_profile_property_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(get_profile_property_response::Status::OK),
            None => get_profile_property_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: get_profile_property_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &GetProfilePropertyResponse| { &m.status },
            |m: &mut GetProfilePropertyResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "properties",
            |m: &GetProfilePropertyResponse| { &m.properties },
            |m: &mut GetProfilePropertyResponse| { &mut m.properties },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetProfilePropertyResponse>(
            "GetProfilePropertyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetProfilePropertyResponse {
    const NAME: &'static str = "GetProfilePropertyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.properties.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.properties {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetProfilePropertyResponse {
        GetProfilePropertyResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetProfilePropertyResponse {
        static instance: GetProfilePropertyResponse = GetProfilePropertyResponse {
            status: ::std::option::Option::None,
            properties: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetProfilePropertyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetProfilePropertyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetProfilePropertyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetProfilePropertyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GetProfilePropertyResponse`
pub mod get_profile_property_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.GetProfilePropertyResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.GetProfilePropertyResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.GetProfilePropertyResponse.Status.SESSION_NOT_FOUND)
        SESSION_NOT_FOUND = 1,
        // @@protoc_insertion_point(enum_value:iterm2.GetProfilePropertyResponse.Status.REQUEST_MALFORMED)
        REQUEST_MALFORMED = 2,
        // @@protoc_insertion_point(enum_value:iterm2.GetProfilePropertyResponse.Status.ERROR)
        ERROR = 3,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                2 => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                3 => ::std::option::Option::Some(Status::ERROR),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "SESSION_NOT_FOUND" => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                "REQUEST_MALFORMED" => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                "ERROR" => ::std::option::Option::Some(Status::ERROR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::SESSION_NOT_FOUND,
            Status::REQUEST_MALFORMED,
            Status::ERROR,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("GetProfilePropertyResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("GetProfilePropertyResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.SetProfilePropertyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetProfilePropertyRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SetProfilePropertyRequest.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.SetProfilePropertyRequest.json_value)
    pub json_value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.SetProfilePropertyRequest.assignments)
    pub assignments: ::std::vec::Vec<set_profile_property_request::Assignment>,
    // message oneof groups
    pub target: ::std::option::Option<set_profile_property_request::Target>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SetProfilePropertyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetProfilePropertyRequest {
    fn default() -> &'a SetProfilePropertyRequest {
        <SetProfilePropertyRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetProfilePropertyRequest {
    pub fn new() -> SetProfilePropertyRequest {
        ::std::default::Default::default()
    }

    // optional string session = 1;

    pub fn session(&self) -> &str {
        match self.target {
            ::std::option::Option::Some(set_profile_property_request::Target::Session(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_session(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(set_profile_property_request::Target::Session(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(set_profile_property_request::Target::Session(v))
    }

    // Mutable pointer to the field.
    pub fn mut_session(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(set_profile_property_request::Target::Session(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(set_profile_property_request::Target::Session(::std::string::String::new()));
        }
        match self.target {
            ::std::option::Option::Some(set_profile_property_request::Target::Session(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::string::String {
        if self.has_session() {
            match self.target.take() {
                ::std::option::Option::Some(set_profile_property_request::Target::Session(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional .iterm2.SetProfilePropertyRequest.GuidList guid_list = 2;

    pub fn guid_list(&self) -> &set_profile_property_request::GuidList {
        match self.target {
            ::std::option::Option::Some(set_profile_property_request::Target::GuidList(ref v)) => v,
            _ => <set_profile_property_request::GuidList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_guid_list(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_guid_list(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(set_profile_property_request::Target::GuidList(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_guid_list(&mut self, v: set_profile_property_request::GuidList) {
        self.target = ::std::option::Option::Some(set_profile_property_request::Target::GuidList(v))
    }

    // Mutable pointer to the field.
    pub fn mut_guid_list(&mut self) -> &mut set_profile_property_request::GuidList {
        if let ::std::option::Option::Some(set_profile_property_request::Target::GuidList(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(set_profile_property_request::Target::GuidList(set_profile_property_request::GuidList::new()));
        }
        match self.target {
            ::std::option::Option::Some(set_profile_property_request::Target::GuidList(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_guid_list(&mut self) -> set_profile_property_request::GuidList {
        if self.has_guid_list() {
            match self.target.take() {
                ::std::option::Option::Some(set_profile_property_request::Target::GuidList(v)) => v,
                _ => panic!(),
            }
        } else {
            set_profile_property_request::GuidList::new()
        }
    }

    // optional string key = 3;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string json_value = 4;

    pub fn json_value(&self) -> &str {
        match self.json_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_json_value(&mut self) {
        self.json_value = ::std::option::Option::None;
    }

    pub fn has_json_value(&self) -> bool {
        self.json_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json_value(&mut self, v: ::std::string::String) {
        self.json_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json_value(&mut self) -> &mut ::std::string::String {
        if self.json_value.is_none() {
            self.json_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.json_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_json_value(&mut self) -> ::std::string::String {
        self.json_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "session",
            SetProfilePropertyRequest::has_session,
            SetProfilePropertyRequest::session,
            SetProfilePropertyRequest::set_session,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, set_profile_property_request::GuidList>(
            "guid_list",
            SetProfilePropertyRequest::has_guid_list,
            SetProfilePropertyRequest::guid_list,
            SetProfilePropertyRequest::mut_guid_list,
            SetProfilePropertyRequest::set_guid_list,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &SetProfilePropertyRequest| { &m.key },
            |m: &mut SetProfilePropertyRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "json_value",
            |m: &SetProfilePropertyRequest| { &m.json_value },
            |m: &mut SetProfilePropertyRequest| { &mut m.json_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "assignments",
            |m: &SetProfilePropertyRequest| { &m.assignments },
            |m: &mut SetProfilePropertyRequest| { &mut m.assignments },
        ));
        oneofs.push(set_profile_property_request::Target::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetProfilePropertyRequest>(
            "SetProfilePropertyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetProfilePropertyRequest {
    const NAME: &'static str = "SetProfilePropertyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.target = ::std::option::Option::Some(set_profile_property_request::Target::Session(is.read_string()?));
                },
                18 => {
                    self.target = ::std::option::Option::Some(set_profile_property_request::Target::GuidList(is.read_message()?));
                },
                26 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.json_value = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.assignments.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.json_value.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.assignments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &set_profile_property_request::Target::Session(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &set_profile_property_request::Target::GuidList(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.json_value.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.assignments {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &set_profile_property_request::Target::Session(ref v) => {
                    os.write_string(1, v)?;
                },
                &set_profile_property_request::Target::GuidList(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetProfilePropertyRequest {
        SetProfilePropertyRequest::new()
    }

    fn clear(&mut self) {
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.json_value = ::std::option::Option::None;
        self.assignments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetProfilePropertyRequest {
        static instance: SetProfilePropertyRequest = SetProfilePropertyRequest {
            key: ::std::option::Option::None,
            json_value: ::std::option::Option::None,
            assignments: ::std::vec::Vec::new(),
            target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetProfilePropertyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetProfilePropertyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetProfilePropertyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetProfilePropertyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SetProfilePropertyRequest`
pub mod set_profile_property_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.SetProfilePropertyRequest.target)
    pub enum Target {
        // @@protoc_insertion_point(oneof_field:iterm2.SetProfilePropertyRequest.session)
        Session(::std::string::String),
        // @@protoc_insertion_point(oneof_field:iterm2.SetProfilePropertyRequest.guid_list)
        GuidList(GuidList),
    }

    impl ::protobuf::Oneof for Target {
    }

    impl ::protobuf::OneofFull for Target {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::SetProfilePropertyRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("target").unwrap()).clone()
        }
    }

    impl Target {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Target>("target")
        }
    }
    // @@protoc_insertion_point(message:iterm2.SetProfilePropertyRequest.GuidList)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GuidList {
        // message fields
        // @@protoc_insertion_point(field:iterm2.SetProfilePropertyRequest.GuidList.guids)
        pub guids: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.SetProfilePropertyRequest.GuidList.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GuidList {
        fn default() -> &'a GuidList {
            <GuidList as ::protobuf::Message>::default_instance()
        }
    }

    impl GuidList {
        pub fn new() -> GuidList {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "guids",
                |m: &GuidList| { &m.guids },
                |m: &mut GuidList| { &mut m.guids },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GuidList>(
                "SetProfilePropertyRequest.GuidList",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GuidList {
        const NAME: &'static str = "GuidList";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.guids.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.guids {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.guids {
                os.write_string(1, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GuidList {
            GuidList::new()
        }

        fn clear(&mut self) {
            self.guids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GuidList {
            static instance: GuidList = GuidList {
                guids: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GuidList {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SetProfilePropertyRequest.GuidList").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GuidList {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GuidList {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.SetProfilePropertyRequest.Assignment)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Assignment {
        // message fields
        // @@protoc_insertion_point(field:iterm2.SetProfilePropertyRequest.Assignment.key)
        pub key: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.SetProfilePropertyRequest.Assignment.json_value)
        pub json_value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.SetProfilePropertyRequest.Assignment.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Assignment {
        fn default() -> &'a Assignment {
            <Assignment as ::protobuf::Message>::default_instance()
        }
    }

    impl Assignment {
        pub fn new() -> Assignment {
            ::std::default::Default::default()
        }

        // optional string key = 1;

        pub fn key(&self) -> &str {
            match self.key.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_key(&mut self) {
            self.key = ::std::option::Option::None;
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            if self.key.is_none() {
                self.key = ::std::option::Option::Some(::std::string::String::new());
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            self.key.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string json_value = 2;

        pub fn json_value(&self) -> &str {
            match self.json_value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_json_value(&mut self) {
            self.json_value = ::std::option::Option::None;
        }

        pub fn has_json_value(&self) -> bool {
            self.json_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_json_value(&mut self, v: ::std::string::String) {
            self.json_value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_json_value(&mut self) -> &mut ::std::string::String {
            if self.json_value.is_none() {
                self.json_value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.json_value.as_mut().unwrap()
        }

        // Take field
        pub fn take_json_value(&mut self) -> ::std::string::String {
            self.json_value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "key",
                |m: &Assignment| { &m.key },
                |m: &mut Assignment| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "json_value",
                |m: &Assignment| { &m.json_value },
                |m: &mut Assignment| { &mut m.json_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Assignment>(
                "SetProfilePropertyRequest.Assignment",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Assignment {
        const NAME: &'static str = "Assignment";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.json_value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.key.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.json_value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.key.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.json_value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Assignment {
            Assignment::new()
        }

        fn clear(&mut self) {
            self.key = ::std::option::Option::None;
            self.json_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Assignment {
            static instance: Assignment = Assignment {
                key: ::std::option::Option::None,
                json_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Assignment {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SetProfilePropertyRequest.Assignment").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Assignment {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Assignment {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:iterm2.SetProfilePropertyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetProfilePropertyResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SetProfilePropertyResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<set_profile_property_response::Status>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SetProfilePropertyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetProfilePropertyResponse {
    fn default() -> &'a SetProfilePropertyResponse {
        <SetProfilePropertyResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetProfilePropertyResponse {
    pub fn new() -> SetProfilePropertyResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.SetProfilePropertyResponse.Status status = 1;

    pub fn status(&self) -> set_profile_property_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(set_profile_property_response::Status::OK),
            None => set_profile_property_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: set_profile_property_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &SetProfilePropertyResponse| { &m.status },
            |m: &mut SetProfilePropertyResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetProfilePropertyResponse>(
            "SetProfilePropertyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetProfilePropertyResponse {
    const NAME: &'static str = "SetProfilePropertyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetProfilePropertyResponse {
        SetProfilePropertyResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetProfilePropertyResponse {
        static instance: SetProfilePropertyResponse = SetProfilePropertyResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetProfilePropertyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetProfilePropertyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetProfilePropertyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetProfilePropertyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SetProfilePropertyResponse`
pub mod set_profile_property_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.SetProfilePropertyResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.SetProfilePropertyResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.SetProfilePropertyResponse.Status.SESSION_NOT_FOUND)
        SESSION_NOT_FOUND = 1,
        // @@protoc_insertion_point(enum_value:iterm2.SetProfilePropertyResponse.Status.REQUEST_MALFORMED)
        REQUEST_MALFORMED = 2,
        // @@protoc_insertion_point(enum_value:iterm2.SetProfilePropertyResponse.Status.BAD_GUID)
        BAD_GUID = 3,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                2 => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                3 => ::std::option::Option::Some(Status::BAD_GUID),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "SESSION_NOT_FOUND" => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                "REQUEST_MALFORMED" => ::std::option::Option::Some(Status::REQUEST_MALFORMED),
                "BAD_GUID" => ::std::option::Option::Some(Status::BAD_GUID),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::SESSION_NOT_FOUND,
            Status::REQUEST_MALFORMED,
            Status::BAD_GUID,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SetProfilePropertyResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("SetProfilePropertyResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.TransactionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TransactionRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.TransactionRequest.begin)
    pub begin: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.TransactionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionRequest {
    fn default() -> &'a TransactionRequest {
        <TransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl TransactionRequest {
    pub fn new() -> TransactionRequest {
        ::std::default::Default::default()
    }

    // optional bool begin = 1;

    pub fn begin(&self) -> bool {
        self.begin.unwrap_or(false)
    }

    pub fn clear_begin(&mut self) {
        self.begin = ::std::option::Option::None;
    }

    pub fn has_begin(&self) -> bool {
        self.begin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_begin(&mut self, v: bool) {
        self.begin = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "begin",
            |m: &TransactionRequest| { &m.begin },
            |m: &mut TransactionRequest| { &mut m.begin },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionRequest>(
            "TransactionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionRequest {
    const NAME: &'static str = "TransactionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.begin = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.begin {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.begin {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionRequest {
        TransactionRequest::new()
    }

    fn clear(&mut self) {
        self.begin = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionRequest {
        static instance: TransactionRequest = TransactionRequest {
            begin: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.TransactionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TransactionResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.TransactionResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<transaction_response::Status>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.TransactionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionResponse {
    fn default() -> &'a TransactionResponse {
        <TransactionResponse as ::protobuf::Message>::default_instance()
    }
}

impl TransactionResponse {
    pub fn new() -> TransactionResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.TransactionResponse.Status status = 1;

    pub fn status(&self) -> transaction_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(transaction_response::Status::OK),
            None => transaction_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: transaction_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &TransactionResponse| { &m.status },
            |m: &mut TransactionResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionResponse>(
            "TransactionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionResponse {
    const NAME: &'static str = "TransactionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionResponse {
        TransactionResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionResponse {
        static instance: TransactionResponse = TransactionResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TransactionResponse`
pub mod transaction_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.TransactionResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.TransactionResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.TransactionResponse.Status.NO_TRANSACTION)
        NO_TRANSACTION = 1,
        // @@protoc_insertion_point(enum_value:iterm2.TransactionResponse.Status.ALREADY_IN_TRANSACTION)
        ALREADY_IN_TRANSACTION = 2,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::NO_TRANSACTION),
                2 => ::std::option::Option::Some(Status::ALREADY_IN_TRANSACTION),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "NO_TRANSACTION" => ::std::option::Option::Some(Status::NO_TRANSACTION),
                "ALREADY_IN_TRANSACTION" => ::std::option::Option::Some(Status::ALREADY_IN_TRANSACTION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::NO_TRANSACTION,
            Status::ALREADY_IN_TRANSACTION,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TransactionResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("TransactionResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.LineRange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LineRange {
    // message fields
    // @@protoc_insertion_point(field:iterm2.LineRange.screen_contents_only)
    pub screen_contents_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.LineRange.trailing_lines)
    pub trailing_lines: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:iterm2.LineRange.windowed_coord_range)
    pub windowed_coord_range: ::protobuf::MessageField<WindowedCoordRange>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.LineRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LineRange {
    fn default() -> &'a LineRange {
        <LineRange as ::protobuf::Message>::default_instance()
    }
}

impl LineRange {
    pub fn new() -> LineRange {
        ::std::default::Default::default()
    }

    // optional bool screen_contents_only = 1;

    pub fn screen_contents_only(&self) -> bool {
        self.screen_contents_only.unwrap_or(false)
    }

    pub fn clear_screen_contents_only(&mut self) {
        self.screen_contents_only = ::std::option::Option::None;
    }

    pub fn has_screen_contents_only(&self) -> bool {
        self.screen_contents_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screen_contents_only(&mut self, v: bool) {
        self.screen_contents_only = ::std::option::Option::Some(v);
    }

    // optional int32 trailing_lines = 2;

    pub fn trailing_lines(&self) -> i32 {
        self.trailing_lines.unwrap_or(0)
    }

    pub fn clear_trailing_lines(&mut self) {
        self.trailing_lines = ::std::option::Option::None;
    }

    pub fn has_trailing_lines(&self) -> bool {
        self.trailing_lines.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trailing_lines(&mut self, v: i32) {
        self.trailing_lines = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "screen_contents_only",
            |m: &LineRange| { &m.screen_contents_only },
            |m: &mut LineRange| { &mut m.screen_contents_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trailing_lines",
            |m: &LineRange| { &m.trailing_lines },
            |m: &mut LineRange| { &mut m.trailing_lines },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WindowedCoordRange>(
            "windowed_coord_range",
            |m: &LineRange| { &m.windowed_coord_range },
            |m: &mut LineRange| { &mut m.windowed_coord_range },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LineRange>(
            "LineRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LineRange {
    const NAME: &'static str = "LineRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.screen_contents_only = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.trailing_lines = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.windowed_coord_range)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.screen_contents_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.trailing_lines {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.windowed_coord_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.screen_contents_only {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.trailing_lines {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.windowed_coord_range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LineRange {
        LineRange::new()
    }

    fn clear(&mut self) {
        self.screen_contents_only = ::std::option::Option::None;
        self.trailing_lines = ::std::option::Option::None;
        self.windowed_coord_range.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LineRange {
        static instance: LineRange = LineRange {
            screen_contents_only: ::std::option::Option::None,
            trailing_lines: ::std::option::Option::None,
            windowed_coord_range: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LineRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LineRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LineRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LineRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.Range)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Range {
    // message fields
    // @@protoc_insertion_point(field:iterm2.Range.location)
    pub location: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:iterm2.Range.length)
    pub length: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.Range.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Range {
    fn default() -> &'a Range {
        <Range as ::protobuf::Message>::default_instance()
    }
}

impl Range {
    pub fn new() -> Range {
        ::std::default::Default::default()
    }

    // optional int64 location = 1;

    pub fn location(&self) -> i64 {
        self.location.unwrap_or(0)
    }

    pub fn clear_location(&mut self) {
        self.location = ::std::option::Option::None;
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: i64) {
        self.location = ::std::option::Option::Some(v);
    }

    // optional int64 length = 2;

    pub fn length(&self) -> i64 {
        self.length.unwrap_or(0)
    }

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i64) {
        self.length = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "location",
            |m: &Range| { &m.location },
            |m: &mut Range| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "length",
            |m: &Range| { &m.length },
            |m: &mut Range| { &mut m.length },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Range>(
            "Range",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Range {
    const NAME: &'static str = "Range";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.location = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.length = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.location {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.location {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.length {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Range {
        Range::new()
    }

    fn clear(&mut self) {
        self.location = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Range {
        static instance: Range = Range {
            location: ::std::option::Option::None,
            length: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Range {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Range").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Range {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.CoordRange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CoordRange {
    // message fields
    // @@protoc_insertion_point(field:iterm2.CoordRange.start)
    pub start: ::protobuf::MessageField<Coord>,
    // @@protoc_insertion_point(field:iterm2.CoordRange.end)
    pub end: ::protobuf::MessageField<Coord>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.CoordRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CoordRange {
    fn default() -> &'a CoordRange {
        <CoordRange as ::protobuf::Message>::default_instance()
    }
}

impl CoordRange {
    pub fn new() -> CoordRange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Coord>(
            "start",
            |m: &CoordRange| { &m.start },
            |m: &mut CoordRange| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Coord>(
            "end",
            |m: &CoordRange| { &m.end },
            |m: &mut CoordRange| { &mut m.end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CoordRange>(
            "CoordRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CoordRange {
    const NAME: &'static str = "CoordRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.end.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CoordRange {
        CoordRange::new()
    }

    fn clear(&mut self) {
        self.start.clear();
        self.end.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CoordRange {
        static instance: CoordRange = CoordRange {
            start: ::protobuf::MessageField::none(),
            end: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CoordRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CoordRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CoordRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoordRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.Coord)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Coord {
    // message fields
    // @@protoc_insertion_point(field:iterm2.Coord.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:iterm2.Coord.y)
    pub y: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.Coord.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Coord {
    fn default() -> &'a Coord {
        <Coord as ::protobuf::Message>::default_instance()
    }
}

impl Coord {
    pub fn new() -> Coord {
        ::std::default::Default::default()
    }

    // optional int32 x = 1;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int64 y = 2;

    pub fn y(&self) -> i64 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i64) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &Coord| { &m.x },
            |m: &mut Coord| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &Coord| { &m.y },
            |m: &mut Coord| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Coord>(
            "Coord",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Coord {
    const NAME: &'static str = "Coord";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.y = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Coord {
        Coord::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Coord {
        static instance: Coord = Coord {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Coord {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Coord").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Coord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Coord {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.RGBColor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RGBColor {
    // message fields
    // @@protoc_insertion_point(field:iterm2.RGBColor.red)
    pub red: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:iterm2.RGBColor.green)
    pub green: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:iterm2.RGBColor.blue)
    pub blue: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.RGBColor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RGBColor {
    fn default() -> &'a RGBColor {
        <RGBColor as ::protobuf::Message>::default_instance()
    }
}

impl RGBColor {
    pub fn new() -> RGBColor {
        ::std::default::Default::default()
    }

    // optional uint32 red = 1;

    pub fn red(&self) -> u32 {
        self.red.unwrap_or(0)
    }

    pub fn clear_red(&mut self) {
        self.red = ::std::option::Option::None;
    }

    pub fn has_red(&self) -> bool {
        self.red.is_some()
    }

    // Param is passed by value, moved
    pub fn set_red(&mut self, v: u32) {
        self.red = ::std::option::Option::Some(v);
    }

    // optional uint32 green = 2;

    pub fn green(&self) -> u32 {
        self.green.unwrap_or(0)
    }

    pub fn clear_green(&mut self) {
        self.green = ::std::option::Option::None;
    }

    pub fn has_green(&self) -> bool {
        self.green.is_some()
    }

    // Param is passed by value, moved
    pub fn set_green(&mut self, v: u32) {
        self.green = ::std::option::Option::Some(v);
    }

    // optional uint32 blue = 3;

    pub fn blue(&self) -> u32 {
        self.blue.unwrap_or(0)
    }

    pub fn clear_blue(&mut self) {
        self.blue = ::std::option::Option::None;
    }

    pub fn has_blue(&self) -> bool {
        self.blue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blue(&mut self, v: u32) {
        self.blue = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "red",
            |m: &RGBColor| { &m.red },
            |m: &mut RGBColor| { &mut m.red },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "green",
            |m: &RGBColor| { &m.green },
            |m: &mut RGBColor| { &mut m.green },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blue",
            |m: &RGBColor| { &m.blue },
            |m: &mut RGBColor| { &mut m.blue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RGBColor>(
            "RGBColor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RGBColor {
    const NAME: &'static str = "RGBColor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.red = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.green = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.blue = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.red {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.green {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.blue {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.red {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.green {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.blue {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RGBColor {
        RGBColor::new()
    }

    fn clear(&mut self) {
        self.red = ::std::option::Option::None;
        self.green = ::std::option::Option::None;
        self.blue = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RGBColor {
        static instance: RGBColor = RGBColor {
            red: ::std::option::Option::None,
            green: ::std::option::Option::None,
            blue: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RGBColor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RGBColor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RGBColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RGBColor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.URL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct URL {
    // message fields
    // @@protoc_insertion_point(field:iterm2.URL.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.URL.identifier)
    pub identifier: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.URL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a URL {
    fn default() -> &'a URL {
        <URL as ::protobuf::Message>::default_instance()
    }
}

impl URL {
    pub fn new() -> URL {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string identifier = 2;

    pub fn identifier(&self) -> &str {
        match self.identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identifier(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::string::String) {
        self.identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
        if self.identifier.is_none() {
            self.identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::string::String {
        self.identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &URL| { &m.url },
            |m: &mut URL| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identifier",
            |m: &URL| { &m.identifier },
            |m: &mut URL| { &mut m.identifier },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<URL>(
            "URL",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for URL {
    const NAME: &'static str = "URL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.identifier = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.identifier.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> URL {
        URL::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static URL {
        static instance: URL = URL {
            url: ::std::option::Option::None,
            identifier: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for URL {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("URL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for URL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for URL {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.CellStyle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CellStyle {
    // message fields
    // @@protoc_insertion_point(field:iterm2.CellStyle.bold)
    pub bold: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.CellStyle.faint)
    pub faint: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.CellStyle.italic)
    pub italic: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.CellStyle.blink)
    pub blink: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.CellStyle.underline)
    pub underline: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.CellStyle.strikethrough)
    pub strikethrough: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.CellStyle.invisible)
    pub invisible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.CellStyle.inverse)
    pub inverse: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.CellStyle.guarded)
    pub guarded: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.CellStyle.image)
    pub image: ::std::option::Option<::protobuf::EnumOrUnknown<ImagePlaceholderType>>,
    // @@protoc_insertion_point(field:iterm2.CellStyle.underlineColor)
    pub underlineColor: ::protobuf::MessageField<RGBColor>,
    // @@protoc_insertion_point(field:iterm2.CellStyle.blockID)
    pub blockID: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.CellStyle.url)
    pub url: ::protobuf::MessageField<URL>,
    // @@protoc_insertion_point(field:iterm2.CellStyle.repeats)
    pub repeats: ::std::option::Option<u32>,
    // message oneof groups
    pub fgColor: ::std::option::Option<cell_style::FgColor>,
    pub bgColor: ::std::option::Option<cell_style::BgColor>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.CellStyle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CellStyle {
    fn default() -> &'a CellStyle {
        <CellStyle as ::protobuf::Message>::default_instance()
    }
}

impl CellStyle {
    pub fn new() -> CellStyle {
        ::std::default::Default::default()
    }

    // optional uint32 fgStandard = 1;

    pub fn fgStandard(&self) -> u32 {
        match self.fgColor {
            ::std::option::Option::Some(cell_style::FgColor::FgStandard(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_fgStandard(&mut self) {
        self.fgColor = ::std::option::Option::None;
    }

    pub fn has_fgStandard(&self) -> bool {
        match self.fgColor {
            ::std::option::Option::Some(cell_style::FgColor::FgStandard(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fgStandard(&mut self, v: u32) {
        self.fgColor = ::std::option::Option::Some(cell_style::FgColor::FgStandard(v))
    }

    // optional .iterm2.AlternateColor fgAlternate = 2;

    pub fn fgAlternate(&self) -> AlternateColor {
        match self.fgColor {
            ::std::option::Option::Some(cell_style::FgColor::FgAlternate(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => AlternateColor::DEFAULT,
        }
    }

    pub fn clear_fgAlternate(&mut self) {
        self.fgColor = ::std::option::Option::None;
    }

    pub fn has_fgAlternate(&self) -> bool {
        match self.fgColor {
            ::std::option::Option::Some(cell_style::FgColor::FgAlternate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fgAlternate(&mut self, v: AlternateColor) {
        self.fgColor = ::std::option::Option::Some(cell_style::FgColor::FgAlternate(::protobuf::EnumOrUnknown::new(v)))
    }

    // optional .iterm2.RGBColor fgRgb = 3;

    pub fn fgRgb(&self) -> &RGBColor {
        match self.fgColor {
            ::std::option::Option::Some(cell_style::FgColor::FgRgb(ref v)) => v,
            _ => <RGBColor as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_fgRgb(&mut self) {
        self.fgColor = ::std::option::Option::None;
    }

    pub fn has_fgRgb(&self) -> bool {
        match self.fgColor {
            ::std::option::Option::Some(cell_style::FgColor::FgRgb(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fgRgb(&mut self, v: RGBColor) {
        self.fgColor = ::std::option::Option::Some(cell_style::FgColor::FgRgb(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fgRgb(&mut self) -> &mut RGBColor {
        if let ::std::option::Option::Some(cell_style::FgColor::FgRgb(_)) = self.fgColor {
        } else {
            self.fgColor = ::std::option::Option::Some(cell_style::FgColor::FgRgb(RGBColor::new()));
        }
        match self.fgColor {
            ::std::option::Option::Some(cell_style::FgColor::FgRgb(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fgRgb(&mut self) -> RGBColor {
        if self.has_fgRgb() {
            match self.fgColor.take() {
                ::std::option::Option::Some(cell_style::FgColor::FgRgb(v)) => v,
                _ => panic!(),
            }
        } else {
            RGBColor::new()
        }
    }

    // optional uint32 fgAlternatePlacementX = 4;

    pub fn fgAlternatePlacementX(&self) -> u32 {
        match self.fgColor {
            ::std::option::Option::Some(cell_style::FgColor::FgAlternatePlacementX(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_fgAlternatePlacementX(&mut self) {
        self.fgColor = ::std::option::Option::None;
    }

    pub fn has_fgAlternatePlacementX(&self) -> bool {
        match self.fgColor {
            ::std::option::Option::Some(cell_style::FgColor::FgAlternatePlacementX(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fgAlternatePlacementX(&mut self, v: u32) {
        self.fgColor = ::std::option::Option::Some(cell_style::FgColor::FgAlternatePlacementX(v))
    }

    // optional uint32 bgStandard = 5;

    pub fn bgStandard(&self) -> u32 {
        match self.bgColor {
            ::std::option::Option::Some(cell_style::BgColor::BgStandard(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_bgStandard(&mut self) {
        self.bgColor = ::std::option::Option::None;
    }

    pub fn has_bgStandard(&self) -> bool {
        match self.bgColor {
            ::std::option::Option::Some(cell_style::BgColor::BgStandard(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bgStandard(&mut self, v: u32) {
        self.bgColor = ::std::option::Option::Some(cell_style::BgColor::BgStandard(v))
    }

    // optional .iterm2.AlternateColor bgAlternate = 6;

    pub fn bgAlternate(&self) -> AlternateColor {
        match self.bgColor {
            ::std::option::Option::Some(cell_style::BgColor::BgAlternate(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => AlternateColor::DEFAULT,
        }
    }

    pub fn clear_bgAlternate(&mut self) {
        self.bgColor = ::std::option::Option::None;
    }

    pub fn has_bgAlternate(&self) -> bool {
        match self.bgColor {
            ::std::option::Option::Some(cell_style::BgColor::BgAlternate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bgAlternate(&mut self, v: AlternateColor) {
        self.bgColor = ::std::option::Option::Some(cell_style::BgColor::BgAlternate(::protobuf::EnumOrUnknown::new(v)))
    }

    // optional .iterm2.RGBColor bgRgb = 7;

    pub fn bgRgb(&self) -> &RGBColor {
        match self.bgColor {
            ::std::option::Option::Some(cell_style::BgColor::BgRgb(ref v)) => v,
            _ => <RGBColor as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_bgRgb(&mut self) {
        self.bgColor = ::std::option::Option::None;
    }

    pub fn has_bgRgb(&self) -> bool {
        match self.bgColor {
            ::std::option::Option::Some(cell_style::BgColor::BgRgb(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bgRgb(&mut self, v: RGBColor) {
        self.bgColor = ::std::option::Option::Some(cell_style::BgColor::BgRgb(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bgRgb(&mut self) -> &mut RGBColor {
        if let ::std::option::Option::Some(cell_style::BgColor::BgRgb(_)) = self.bgColor {
        } else {
            self.bgColor = ::std::option::Option::Some(cell_style::BgColor::BgRgb(RGBColor::new()));
        }
        match self.bgColor {
            ::std::option::Option::Some(cell_style::BgColor::BgRgb(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bgRgb(&mut self) -> RGBColor {
        if self.has_bgRgb() {
            match self.bgColor.take() {
                ::std::option::Option::Some(cell_style::BgColor::BgRgb(v)) => v,
                _ => panic!(),
            }
        } else {
            RGBColor::new()
        }
    }

    // optional uint32 bgAlternatePlacementY = 8;

    pub fn bgAlternatePlacementY(&self) -> u32 {
        match self.bgColor {
            ::std::option::Option::Some(cell_style::BgColor::BgAlternatePlacementY(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_bgAlternatePlacementY(&mut self) {
        self.bgColor = ::std::option::Option::None;
    }

    pub fn has_bgAlternatePlacementY(&self) -> bool {
        match self.bgColor {
            ::std::option::Option::Some(cell_style::BgColor::BgAlternatePlacementY(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bgAlternatePlacementY(&mut self, v: u32) {
        self.bgColor = ::std::option::Option::Some(cell_style::BgColor::BgAlternatePlacementY(v))
    }

    // optional bool bold = 9;

    pub fn bold(&self) -> bool {
        self.bold.unwrap_or(false)
    }

    pub fn clear_bold(&mut self) {
        self.bold = ::std::option::Option::None;
    }

    pub fn has_bold(&self) -> bool {
        self.bold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bold(&mut self, v: bool) {
        self.bold = ::std::option::Option::Some(v);
    }

    // optional bool faint = 10;

    pub fn faint(&self) -> bool {
        self.faint.unwrap_or(false)
    }

    pub fn clear_faint(&mut self) {
        self.faint = ::std::option::Option::None;
    }

    pub fn has_faint(&self) -> bool {
        self.faint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_faint(&mut self, v: bool) {
        self.faint = ::std::option::Option::Some(v);
    }

    // optional bool italic = 11;

    pub fn italic(&self) -> bool {
        self.italic.unwrap_or(false)
    }

    pub fn clear_italic(&mut self) {
        self.italic = ::std::option::Option::None;
    }

    pub fn has_italic(&self) -> bool {
        self.italic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_italic(&mut self, v: bool) {
        self.italic = ::std::option::Option::Some(v);
    }

    // optional bool blink = 12;

    pub fn blink(&self) -> bool {
        self.blink.unwrap_or(false)
    }

    pub fn clear_blink(&mut self) {
        self.blink = ::std::option::Option::None;
    }

    pub fn has_blink(&self) -> bool {
        self.blink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blink(&mut self, v: bool) {
        self.blink = ::std::option::Option::Some(v);
    }

    // optional bool underline = 13;

    pub fn underline(&self) -> bool {
        self.underline.unwrap_or(false)
    }

    pub fn clear_underline(&mut self) {
        self.underline = ::std::option::Option::None;
    }

    pub fn has_underline(&self) -> bool {
        self.underline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_underline(&mut self, v: bool) {
        self.underline = ::std::option::Option::Some(v);
    }

    // optional bool strikethrough = 14;

    pub fn strikethrough(&self) -> bool {
        self.strikethrough.unwrap_or(false)
    }

    pub fn clear_strikethrough(&mut self) {
        self.strikethrough = ::std::option::Option::None;
    }

    pub fn has_strikethrough(&self) -> bool {
        self.strikethrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strikethrough(&mut self, v: bool) {
        self.strikethrough = ::std::option::Option::Some(v);
    }

    // optional bool invisible = 15;

    pub fn invisible(&self) -> bool {
        self.invisible.unwrap_or(false)
    }

    pub fn clear_invisible(&mut self) {
        self.invisible = ::std::option::Option::None;
    }

    pub fn has_invisible(&self) -> bool {
        self.invisible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invisible(&mut self, v: bool) {
        self.invisible = ::std::option::Option::Some(v);
    }

    // optional bool inverse = 16;

    pub fn inverse(&self) -> bool {
        self.inverse.unwrap_or(false)
    }

    pub fn clear_inverse(&mut self) {
        self.inverse = ::std::option::Option::None;
    }

    pub fn has_inverse(&self) -> bool {
        self.inverse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inverse(&mut self, v: bool) {
        self.inverse = ::std::option::Option::Some(v);
    }

    // optional bool guarded = 17;

    pub fn guarded(&self) -> bool {
        self.guarded.unwrap_or(false)
    }

    pub fn clear_guarded(&mut self) {
        self.guarded = ::std::option::Option::None;
    }

    pub fn has_guarded(&self) -> bool {
        self.guarded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guarded(&mut self, v: bool) {
        self.guarded = ::std::option::Option::Some(v);
    }

    // optional .iterm2.ImagePlaceholderType image = 18;

    pub fn image(&self) -> ImagePlaceholderType {
        match self.image {
            Some(e) => e.enum_value_or(ImagePlaceholderType::NONE),
            None => ImagePlaceholderType::NONE,
        }
    }

    pub fn clear_image(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ImagePlaceholderType) {
        self.image = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string blockID = 20;

    pub fn blockID(&self) -> &str {
        match self.blockID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_blockID(&mut self) {
        self.blockID = ::std::option::Option::None;
    }

    pub fn has_blockID(&self) -> bool {
        self.blockID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockID(&mut self, v: ::std::string::String) {
        self.blockID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockID(&mut self) -> &mut ::std::string::String {
        if self.blockID.is_none() {
            self.blockID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.blockID.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockID(&mut self) -> ::std::string::String {
        self.blockID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 repeats = 22;

    pub fn repeats(&self) -> u32 {
        self.repeats.unwrap_or(0)
    }

    pub fn clear_repeats(&mut self) {
        self.repeats = ::std::option::Option::None;
    }

    pub fn has_repeats(&self) -> bool {
        self.repeats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeats(&mut self, v: u32) {
        self.repeats = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(2);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "fgStandard",
            CellStyle::has_fgStandard,
            CellStyle::fgStandard,
            CellStyle::set_fgStandard,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "fgAlternate",
            |message: &CellStyle| match &message.fgColor {
                ::std::option::Option::Some(cell_style::FgColor::FgAlternate(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut CellStyle, e: ::protobuf::EnumOrUnknown<AlternateColor>| {
                message.fgColor = ::std::option::Option::Some(cell_style::FgColor::FgAlternate(e));
            },
            AlternateColor::DEFAULT,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RGBColor>(
            "fgRgb",
            CellStyle::has_fgRgb,
            CellStyle::fgRgb,
            CellStyle::mut_fgRgb,
            CellStyle::set_fgRgb,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "fgAlternatePlacementX",
            CellStyle::has_fgAlternatePlacementX,
            CellStyle::fgAlternatePlacementX,
            CellStyle::set_fgAlternatePlacementX,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "bgStandard",
            CellStyle::has_bgStandard,
            CellStyle::bgStandard,
            CellStyle::set_bgStandard,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "bgAlternate",
            |message: &CellStyle| match &message.bgColor {
                ::std::option::Option::Some(cell_style::BgColor::BgAlternate(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut CellStyle, e: ::protobuf::EnumOrUnknown<AlternateColor>| {
                message.bgColor = ::std::option::Option::Some(cell_style::BgColor::BgAlternate(e));
            },
            AlternateColor::DEFAULT,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RGBColor>(
            "bgRgb",
            CellStyle::has_bgRgb,
            CellStyle::bgRgb,
            CellStyle::mut_bgRgb,
            CellStyle::set_bgRgb,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "bgAlternatePlacementY",
            CellStyle::has_bgAlternatePlacementY,
            CellStyle::bgAlternatePlacementY,
            CellStyle::set_bgAlternatePlacementY,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bold",
            |m: &CellStyle| { &m.bold },
            |m: &mut CellStyle| { &mut m.bold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "faint",
            |m: &CellStyle| { &m.faint },
            |m: &mut CellStyle| { &mut m.faint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "italic",
            |m: &CellStyle| { &m.italic },
            |m: &mut CellStyle| { &mut m.italic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blink",
            |m: &CellStyle| { &m.blink },
            |m: &mut CellStyle| { &mut m.blink },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "underline",
            |m: &CellStyle| { &m.underline },
            |m: &mut CellStyle| { &mut m.underline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strikethrough",
            |m: &CellStyle| { &m.strikethrough },
            |m: &mut CellStyle| { &mut m.strikethrough },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "invisible",
            |m: &CellStyle| { &m.invisible },
            |m: &mut CellStyle| { &mut m.invisible },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inverse",
            |m: &CellStyle| { &m.inverse },
            |m: &mut CellStyle| { &mut m.inverse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guarded",
            |m: &CellStyle| { &m.guarded },
            |m: &mut CellStyle| { &mut m.guarded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "image",
            |m: &CellStyle| { &m.image },
            |m: &mut CellStyle| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RGBColor>(
            "underlineColor",
            |m: &CellStyle| { &m.underlineColor },
            |m: &mut CellStyle| { &mut m.underlineColor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blockID",
            |m: &CellStyle| { &m.blockID },
            |m: &mut CellStyle| { &mut m.blockID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, URL>(
            "url",
            |m: &CellStyle| { &m.url },
            |m: &mut CellStyle| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "repeats",
            |m: &CellStyle| { &m.repeats },
            |m: &mut CellStyle| { &mut m.repeats },
        ));
        oneofs.push(cell_style::FgColor::generated_oneof_descriptor_data());
        oneofs.push(cell_style::BgColor::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CellStyle>(
            "CellStyle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CellStyle {
    const NAME: &'static str = "CellStyle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fgColor = ::std::option::Option::Some(cell_style::FgColor::FgStandard(is.read_uint32()?));
                },
                16 => {
                    self.fgColor = ::std::option::Option::Some(cell_style::FgColor::FgAlternate(is.read_enum_or_unknown()?));
                },
                26 => {
                    self.fgColor = ::std::option::Option::Some(cell_style::FgColor::FgRgb(is.read_message()?));
                },
                32 => {
                    self.fgColor = ::std::option::Option::Some(cell_style::FgColor::FgAlternatePlacementX(is.read_uint32()?));
                },
                40 => {
                    self.bgColor = ::std::option::Option::Some(cell_style::BgColor::BgStandard(is.read_uint32()?));
                },
                48 => {
                    self.bgColor = ::std::option::Option::Some(cell_style::BgColor::BgAlternate(is.read_enum_or_unknown()?));
                },
                58 => {
                    self.bgColor = ::std::option::Option::Some(cell_style::BgColor::BgRgb(is.read_message()?));
                },
                64 => {
                    self.bgColor = ::std::option::Option::Some(cell_style::BgColor::BgAlternatePlacementY(is.read_uint32()?));
                },
                72 => {
                    self.bold = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.faint = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.italic = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.blink = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.underline = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.strikethrough = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.invisible = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.inverse = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.guarded = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.image = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.underlineColor)?;
                },
                162 => {
                    self.blockID = ::std::option::Option::Some(is.read_string()?);
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.url)?;
                },
                176 => {
                    self.repeats = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bold {
            my_size += 1 + 1;
        }
        if let Some(v) = self.faint {
            my_size += 1 + 1;
        }
        if let Some(v) = self.italic {
            my_size += 1 + 1;
        }
        if let Some(v) = self.blink {
            my_size += 1 + 1;
        }
        if let Some(v) = self.underline {
            my_size += 1 + 1;
        }
        if let Some(v) = self.strikethrough {
            my_size += 1 + 1;
        }
        if let Some(v) = self.invisible {
            my_size += 1 + 1;
        }
        if let Some(v) = self.inverse {
            my_size += 2 + 1;
        }
        if let Some(v) = self.guarded {
            my_size += 2 + 1;
        }
        if let Some(v) = self.image {
            my_size += ::protobuf::rt::int32_size(18, v.value());
        }
        if let Some(v) = self.underlineColor.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.blockID.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.url.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.repeats {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let ::std::option::Option::Some(ref v) = self.fgColor {
            match v {
                &cell_style::FgColor::FgStandard(v) => {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                },
                &cell_style::FgColor::FgAlternate(v) => {
                    my_size += ::protobuf::rt::int32_size(2, v.value());
                },
                &cell_style::FgColor::FgRgb(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cell_style::FgColor::FgAlternatePlacementX(v) => {
                    my_size += ::protobuf::rt::uint32_size(4, v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.bgColor {
            match v {
                &cell_style::BgColor::BgStandard(v) => {
                    my_size += ::protobuf::rt::uint32_size(5, v);
                },
                &cell_style::BgColor::BgAlternate(v) => {
                    my_size += ::protobuf::rt::int32_size(6, v.value());
                },
                &cell_style::BgColor::BgRgb(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cell_style::BgColor::BgAlternatePlacementY(v) => {
                    my_size += ::protobuf::rt::uint32_size(8, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bold {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.faint {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.italic {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.blink {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.underline {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.strikethrough {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.invisible {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.inverse {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.guarded {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.image {
            os.write_enum(18, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.underlineColor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.blockID.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.repeats {
            os.write_uint32(22, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.fgColor {
            match v {
                &cell_style::FgColor::FgStandard(v) => {
                    os.write_uint32(1, v)?;
                },
                &cell_style::FgColor::FgAlternate(v) => {
                    os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &cell_style::FgColor::FgRgb(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &cell_style::FgColor::FgAlternatePlacementX(v) => {
                    os.write_uint32(4, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.bgColor {
            match v {
                &cell_style::BgColor::BgStandard(v) => {
                    os.write_uint32(5, v)?;
                },
                &cell_style::BgColor::BgAlternate(v) => {
                    os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &cell_style::BgColor::BgRgb(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &cell_style::BgColor::BgAlternatePlacementY(v) => {
                    os.write_uint32(8, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CellStyle {
        CellStyle::new()
    }

    fn clear(&mut self) {
        self.fgColor = ::std::option::Option::None;
        self.fgColor = ::std::option::Option::None;
        self.fgColor = ::std::option::Option::None;
        self.fgColor = ::std::option::Option::None;
        self.bgColor = ::std::option::Option::None;
        self.bgColor = ::std::option::Option::None;
        self.bgColor = ::std::option::Option::None;
        self.bgColor = ::std::option::Option::None;
        self.bold = ::std::option::Option::None;
        self.faint = ::std::option::Option::None;
        self.italic = ::std::option::Option::None;
        self.blink = ::std::option::Option::None;
        self.underline = ::std::option::Option::None;
        self.strikethrough = ::std::option::Option::None;
        self.invisible = ::std::option::Option::None;
        self.inverse = ::std::option::Option::None;
        self.guarded = ::std::option::Option::None;
        self.image = ::std::option::Option::None;
        self.underlineColor.clear();
        self.blockID = ::std::option::Option::None;
        self.url.clear();
        self.repeats = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CellStyle {
        static instance: CellStyle = CellStyle {
            bold: ::std::option::Option::None,
            faint: ::std::option::Option::None,
            italic: ::std::option::Option::None,
            blink: ::std::option::Option::None,
            underline: ::std::option::Option::None,
            strikethrough: ::std::option::Option::None,
            invisible: ::std::option::Option::None,
            inverse: ::std::option::Option::None,
            guarded: ::std::option::Option::None,
            image: ::std::option::Option::None,
            underlineColor: ::protobuf::MessageField::none(),
            blockID: ::std::option::Option::None,
            url: ::protobuf::MessageField::none(),
            repeats: ::std::option::Option::None,
            fgColor: ::std::option::Option::None,
            bgColor: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CellStyle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CellStyle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CellStyle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CellStyle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CellStyle`
pub mod cell_style {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.CellStyle.fgColor)
    pub enum FgColor {
        // @@protoc_insertion_point(oneof_field:iterm2.CellStyle.fgStandard)
        FgStandard(u32),
        // @@protoc_insertion_point(oneof_field:iterm2.CellStyle.fgAlternate)
        FgAlternate(::protobuf::EnumOrUnknown<super::AlternateColor>),
        // @@protoc_insertion_point(oneof_field:iterm2.CellStyle.fgRgb)
        FgRgb(super::RGBColor),
        // @@protoc_insertion_point(oneof_field:iterm2.CellStyle.fgAlternatePlacementX)
        FgAlternatePlacementX(u32),
    }

    impl ::protobuf::Oneof for FgColor {
    }

    impl ::protobuf::OneofFull for FgColor {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CellStyle as ::protobuf::MessageFull>::descriptor().oneof_by_name("fgColor").unwrap()).clone()
        }
    }

    impl FgColor {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<FgColor>("fgColor")
        }
    }

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:iterm2.CellStyle.bgColor)
    pub enum BgColor {
        // @@protoc_insertion_point(oneof_field:iterm2.CellStyle.bgStandard)
        BgStandard(u32),
        // @@protoc_insertion_point(oneof_field:iterm2.CellStyle.bgAlternate)
        BgAlternate(::protobuf::EnumOrUnknown<super::AlternateColor>),
        // @@protoc_insertion_point(oneof_field:iterm2.CellStyle.bgRgb)
        BgRgb(super::RGBColor),
        // @@protoc_insertion_point(oneof_field:iterm2.CellStyle.bgAlternatePlacementY)
        BgAlternatePlacementY(u32),
    }

    impl ::protobuf::Oneof for BgColor {
    }

    impl ::protobuf::OneofFull for BgColor {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CellStyle as ::protobuf::MessageFull>::descriptor().oneof_by_name("bgColor").unwrap()).clone()
        }
    }

    impl BgColor {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<BgColor>("bgColor")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.LineContents)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LineContents {
    // message fields
    // @@protoc_insertion_point(field:iterm2.LineContents.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.LineContents.code_points_per_cell)
    pub code_points_per_cell: ::std::vec::Vec<CodePointsPerCell>,
    // @@protoc_insertion_point(field:iterm2.LineContents.continuation)
    pub continuation: ::std::option::Option<::protobuf::EnumOrUnknown<line_contents::Continuation>>,
    // @@protoc_insertion_point(field:iterm2.LineContents.style)
    pub style: ::std::vec::Vec<CellStyle>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.LineContents.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LineContents {
    fn default() -> &'a LineContents {
        <LineContents as ::protobuf::Message>::default_instance()
    }
}

impl LineContents {
    pub fn new() -> LineContents {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .iterm2.LineContents.Continuation continuation = 3;

    pub fn continuation(&self) -> line_contents::Continuation {
        match self.continuation {
            Some(e) => e.enum_value_or(line_contents::Continuation::CONTINUATION_HARD_EOL),
            None => line_contents::Continuation::CONTINUATION_HARD_EOL,
        }
    }

    pub fn clear_continuation(&mut self) {
        self.continuation = ::std::option::Option::None;
    }

    pub fn has_continuation(&self) -> bool {
        self.continuation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_continuation(&mut self, v: line_contents::Continuation) {
        self.continuation = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &LineContents| { &m.text },
            |m: &mut LineContents| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "code_points_per_cell",
            |m: &LineContents| { &m.code_points_per_cell },
            |m: &mut LineContents| { &mut m.code_points_per_cell },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "continuation",
            |m: &LineContents| { &m.continuation },
            |m: &mut LineContents| { &mut m.continuation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "style",
            |m: &LineContents| { &m.style },
            |m: &mut LineContents| { &mut m.style },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LineContents>(
            "LineContents",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LineContents {
    const NAME: &'static str = "LineContents";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.code_points_per_cell.push(is.read_message()?);
                },
                24 => {
                    self.continuation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.style.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.code_points_per_cell {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.continuation {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        for value in &self.style {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.code_points_per_cell {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.continuation {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.style {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LineContents {
        LineContents::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.code_points_per_cell.clear();
        self.continuation = ::std::option::Option::None;
        self.style.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LineContents {
        static instance: LineContents = LineContents {
            text: ::std::option::Option::None,
            code_points_per_cell: ::std::vec::Vec::new(),
            continuation: ::std::option::Option::None,
            style: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LineContents {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LineContents").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LineContents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LineContents {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LineContents`
pub mod line_contents {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.LineContents.Continuation)
    pub enum Continuation {
        // @@protoc_insertion_point(enum_value:iterm2.LineContents.Continuation.CONTINUATION_HARD_EOL)
        CONTINUATION_HARD_EOL = 1,
        // @@protoc_insertion_point(enum_value:iterm2.LineContents.Continuation.CONTINUATION_SOFT_EOL)
        CONTINUATION_SOFT_EOL = 2,
    }

    impl ::protobuf::Enum for Continuation {
        const NAME: &'static str = "Continuation";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Continuation> {
            match value {
                1 => ::std::option::Option::Some(Continuation::CONTINUATION_HARD_EOL),
                2 => ::std::option::Option::Some(Continuation::CONTINUATION_SOFT_EOL),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Continuation> {
            match str {
                "CONTINUATION_HARD_EOL" => ::std::option::Option::Some(Continuation::CONTINUATION_HARD_EOL),
                "CONTINUATION_SOFT_EOL" => ::std::option::Option::Some(Continuation::CONTINUATION_SOFT_EOL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Continuation] = &[
            Continuation::CONTINUATION_HARD_EOL,
            Continuation::CONTINUATION_SOFT_EOL,
        ];
    }

    impl ::protobuf::EnumFull for Continuation {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("LineContents.Continuation").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Continuation::CONTINUATION_HARD_EOL => 0,
                Continuation::CONTINUATION_SOFT_EOL => 1,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Continuation {
        fn default() -> Self {
            Continuation::CONTINUATION_HARD_EOL
        }
    }

    impl Continuation {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Continuation>("LineContents.Continuation")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.CodePointsPerCell)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CodePointsPerCell {
    // message fields
    // @@protoc_insertion_point(field:iterm2.CodePointsPerCell.num_code_points)
    pub num_code_points: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:iterm2.CodePointsPerCell.repeats)
    pub repeats: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.CodePointsPerCell.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CodePointsPerCell {
    fn default() -> &'a CodePointsPerCell {
        <CodePointsPerCell as ::protobuf::Message>::default_instance()
    }
}

impl CodePointsPerCell {
    pub fn new() -> CodePointsPerCell {
        ::std::default::Default::default()
    }

    // optional int32 num_code_points = 1;

    pub fn num_code_points(&self) -> i32 {
        self.num_code_points.unwrap_or(1i32)
    }

    pub fn clear_num_code_points(&mut self) {
        self.num_code_points = ::std::option::Option::None;
    }

    pub fn has_num_code_points(&self) -> bool {
        self.num_code_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_code_points(&mut self, v: i32) {
        self.num_code_points = ::std::option::Option::Some(v);
    }

    // optional int32 repeats = 2;

    pub fn repeats(&self) -> i32 {
        self.repeats.unwrap_or(0)
    }

    pub fn clear_repeats(&mut self) {
        self.repeats = ::std::option::Option::None;
    }

    pub fn has_repeats(&self) -> bool {
        self.repeats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeats(&mut self, v: i32) {
        self.repeats = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_code_points",
            |m: &CodePointsPerCell| { &m.num_code_points },
            |m: &mut CodePointsPerCell| { &mut m.num_code_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "repeats",
            |m: &CodePointsPerCell| { &m.repeats },
            |m: &mut CodePointsPerCell| { &mut m.repeats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CodePointsPerCell>(
            "CodePointsPerCell",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CodePointsPerCell {
    const NAME: &'static str = "CodePointsPerCell";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_code_points = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.repeats = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num_code_points {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.repeats {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.num_code_points {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.repeats {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CodePointsPerCell {
        CodePointsPerCell::new()
    }

    fn clear(&mut self) {
        self.num_code_points = ::std::option::Option::None;
        self.repeats = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CodePointsPerCell {
        static instance: CodePointsPerCell = CodePointsPerCell {
            num_code_points: ::std::option::Option::None,
            repeats: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CodePointsPerCell {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CodePointsPerCell").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CodePointsPerCell {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodePointsPerCell {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.ListSessionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListSessionsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ListSessionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSessionsRequest {
    fn default() -> &'a ListSessionsRequest {
        <ListSessionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSessionsRequest {
    pub fn new() -> ListSessionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSessionsRequest>(
            "ListSessionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSessionsRequest {
    const NAME: &'static str = "ListSessionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSessionsRequest {
        ListSessionsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSessionsRequest {
        static instance: ListSessionsRequest = ListSessionsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSessionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSessionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSessionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSessionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.SendTextRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SendTextRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SendTextRequest.session)
    pub session: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.SendTextRequest.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.SendTextRequest.suppress_broadcast)
    pub suppress_broadcast: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SendTextRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SendTextRequest {
    fn default() -> &'a SendTextRequest {
        <SendTextRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendTextRequest {
    pub fn new() -> SendTextRequest {
        ::std::default::Default::default()
    }

    // optional string session = 1;

    pub fn session(&self) -> &str {
        match self.session.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::string::String) {
        self.session = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session(&mut self) -> &mut ::std::string::String {
        if self.session.is_none() {
            self.session = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session.as_mut().unwrap()
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::string::String {
        self.session.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool suppress_broadcast = 3;

    pub fn suppress_broadcast(&self) -> bool {
        self.suppress_broadcast.unwrap_or(false)
    }

    pub fn clear_suppress_broadcast(&mut self) {
        self.suppress_broadcast = ::std::option::Option::None;
    }

    pub fn has_suppress_broadcast(&self) -> bool {
        self.suppress_broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suppress_broadcast(&mut self, v: bool) {
        self.suppress_broadcast = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &SendTextRequest| { &m.session },
            |m: &mut SendTextRequest| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &SendTextRequest| { &m.text },
            |m: &mut SendTextRequest| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "suppress_broadcast",
            |m: &SendTextRequest| { &m.suppress_broadcast },
            |m: &mut SendTextRequest| { &mut m.suppress_broadcast },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SendTextRequest>(
            "SendTextRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SendTextRequest {
    const NAME: &'static str = "SendTextRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.suppress_broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.suppress_broadcast {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.suppress_broadcast {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SendTextRequest {
        SendTextRequest::new()
    }

    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.suppress_broadcast = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SendTextRequest {
        static instance: SendTextRequest = SendTextRequest {
            session: ::std::option::Option::None,
            text: ::std::option::Option::None,
            suppress_broadcast: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SendTextRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SendTextRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SendTextRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendTextRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.SendTextResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SendTextResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SendTextResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<send_text_response::Status>>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SendTextResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SendTextResponse {
    fn default() -> &'a SendTextResponse {
        <SendTextResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendTextResponse {
    pub fn new() -> SendTextResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.SendTextResponse.Status status = 1;

    pub fn status(&self) -> send_text_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(send_text_response::Status::OK),
            None => send_text_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: send_text_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &SendTextResponse| { &m.status },
            |m: &mut SendTextResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SendTextResponse>(
            "SendTextResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SendTextResponse {
    const NAME: &'static str = "SendTextResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SendTextResponse {
        SendTextResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SendTextResponse {
        static instance: SendTextResponse = SendTextResponse {
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SendTextResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SendTextResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SendTextResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendTextResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SendTextResponse`
pub mod send_text_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.SendTextResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.SendTextResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.SendTextResponse.Status.SESSION_NOT_FOUND)
        SESSION_NOT_FOUND = 1,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "SESSION_NOT_FOUND" => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::SESSION_NOT_FOUND,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SendTextResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("SendTextResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.Size)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Size {
    // message fields
    // @@protoc_insertion_point(field:iterm2.Size.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:iterm2.Size.height)
    pub height: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.Size.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Size {
    fn default() -> &'a Size {
        <Size as ::protobuf::Message>::default_instance()
    }
}

impl Size {
    pub fn new() -> Size {
        ::std::default::Default::default()
    }

    // optional int32 width = 1;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 2;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &Size| { &m.width },
            |m: &mut Size| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &Size| { &m.height },
            |m: &mut Size| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Size>(
            "Size",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Size {
    const NAME: &'static str = "Size";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Size {
        Size::new()
    }

    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Size {
        static instance: Size = Size {
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Size {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Size").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Size {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Size {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.Point)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Point {
    // message fields
    // @@protoc_insertion_point(field:iterm2.Point.x)
    pub x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:iterm2.Point.y)
    pub y: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.Point.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Point {
    fn default() -> &'a Point {
        <Point as ::protobuf::Message>::default_instance()
    }
}

impl Point {
    pub fn new() -> Point {
        ::std::default::Default::default()
    }

    // optional int32 x = 1;

    pub fn x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 2;

    pub fn y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &Point| { &m.x },
            |m: &mut Point| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &Point| { &m.y },
            |m: &mut Point| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Point>(
            "Point",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Point {
    const NAME: &'static str = "Point";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.x = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.y = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Point {
        Point::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Point {
        static instance: Point = Point {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Point {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Point").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Point {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Point {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.Frame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Frame {
    // message fields
    // @@protoc_insertion_point(field:iterm2.Frame.origin)
    pub origin: ::protobuf::MessageField<Point>,
    // @@protoc_insertion_point(field:iterm2.Frame.size)
    pub size: ::protobuf::MessageField<Size>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.Frame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Frame {
    fn default() -> &'a Frame {
        <Frame as ::protobuf::Message>::default_instance()
    }
}

impl Frame {
    pub fn new() -> Frame {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Point>(
            "origin",
            |m: &Frame| { &m.origin },
            |m: &mut Frame| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Size>(
            "size",
            |m: &Frame| { &m.size },
            |m: &mut Frame| { &mut m.size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Frame>(
            "Frame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Frame {
    const NAME: &'static str = "Frame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.size)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.size.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.size.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Frame {
        Frame::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.size.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Frame {
        static instance: Frame = Frame {
            origin: ::protobuf::MessageField::none(),
            size: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Frame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Frame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Frame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Frame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.SessionSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SessionSummary {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SessionSummary.unique_identifier)
    pub unique_identifier: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.SessionSummary.frame)
    pub frame: ::protobuf::MessageField<Frame>,
    // @@protoc_insertion_point(field:iterm2.SessionSummary.grid_size)
    pub grid_size: ::protobuf::MessageField<Size>,
    // @@protoc_insertion_point(field:iterm2.SessionSummary.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SessionSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SessionSummary {
    fn default() -> &'a SessionSummary {
        <SessionSummary as ::protobuf::Message>::default_instance()
    }
}

impl SessionSummary {
    pub fn new() -> SessionSummary {
        ::std::default::Default::default()
    }

    // optional string unique_identifier = 1;

    pub fn unique_identifier(&self) -> &str {
        match self.unique_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_identifier(&mut self) {
        self.unique_identifier = ::std::option::Option::None;
    }

    pub fn has_unique_identifier(&self) -> bool {
        self.unique_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_identifier(&mut self, v: ::std::string::String) {
        self.unique_identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_identifier(&mut self) -> &mut ::std::string::String {
        if self.unique_identifier.is_none() {
            self.unique_identifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_identifier(&mut self) -> ::std::string::String {
        self.unique_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 4;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unique_identifier",
            |m: &SessionSummary| { &m.unique_identifier },
            |m: &mut SessionSummary| { &mut m.unique_identifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Frame>(
            "frame",
            |m: &SessionSummary| { &m.frame },
            |m: &mut SessionSummary| { &mut m.frame },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Size>(
            "grid_size",
            |m: &SessionSummary| { &m.grid_size },
            |m: &mut SessionSummary| { &mut m.grid_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &SessionSummary| { &m.title },
            |m: &mut SessionSummary| { &mut m.title },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SessionSummary>(
            "SessionSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SessionSummary {
    const NAME: &'static str = "SessionSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.unique_identifier = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.frame)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.grid_size)?;
                },
                34 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unique_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.frame.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.grid_size.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unique_identifier.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.frame.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.grid_size.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SessionSummary {
        SessionSummary::new()
    }

    fn clear(&mut self) {
        self.unique_identifier = ::std::option::Option::None;
        self.frame.clear();
        self.grid_size.clear();
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SessionSummary {
        static instance: SessionSummary = SessionSummary {
            unique_identifier: ::std::option::Option::None,
            frame: ::protobuf::MessageField::none(),
            grid_size: ::protobuf::MessageField::none(),
            title: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SessionSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SessionSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SessionSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.SplitTreeNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SplitTreeNode {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SplitTreeNode.vertical)
    pub vertical: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.SplitTreeNode.links)
    pub links: ::std::vec::Vec<split_tree_node::SplitTreeLink>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SplitTreeNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SplitTreeNode {
    fn default() -> &'a SplitTreeNode {
        <SplitTreeNode as ::protobuf::Message>::default_instance()
    }
}

impl SplitTreeNode {
    pub fn new() -> SplitTreeNode {
        ::std::default::Default::default()
    }

    // optional bool vertical = 1;

    pub fn vertical(&self) -> bool {
        self.vertical.unwrap_or(false)
    }

    pub fn clear_vertical(&mut self) {
        self.vertical = ::std::option::Option::None;
    }

    pub fn has_vertical(&self) -> bool {
        self.vertical.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vertical(&mut self, v: bool) {
        self.vertical = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vertical",
            |m: &SplitTreeNode| { &m.vertical },
            |m: &mut SplitTreeNode| { &mut m.vertical },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "links",
            |m: &SplitTreeNode| { &m.links },
            |m: &mut SplitTreeNode| { &mut m.links },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SplitTreeNode>(
            "SplitTreeNode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SplitTreeNode {
    const NAME: &'static str = "SplitTreeNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.vertical = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.links.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vertical {
            my_size += 1 + 1;
        }
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vertical {
            os.write_bool(1, v)?;
        }
        for v in &self.links {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SplitTreeNode {
        SplitTreeNode::new()
    }

    fn clear(&mut self) {
        self.vertical = ::std::option::Option::None;
        self.links.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SplitTreeNode {
        static instance: SplitTreeNode = SplitTreeNode {
            vertical: ::std::option::Option::None,
            links: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SplitTreeNode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SplitTreeNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SplitTreeNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SplitTreeNode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SplitTreeNode`
pub mod split_tree_node {
    // @@protoc_insertion_point(message:iterm2.SplitTreeNode.SplitTreeLink)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SplitTreeLink {
        // message oneof groups
        pub child: ::std::option::Option<split_tree_link::Child>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.SplitTreeNode.SplitTreeLink.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SplitTreeLink {
        fn default() -> &'a SplitTreeLink {
            <SplitTreeLink as ::protobuf::Message>::default_instance()
        }
    }

    impl SplitTreeLink {
        pub fn new() -> SplitTreeLink {
            ::std::default::Default::default()
        }

        // optional .iterm2.SessionSummary session = 1;

        pub fn session(&self) -> &super::SessionSummary {
            match self.child {
                ::std::option::Option::Some(split_tree_link::Child::Session(ref v)) => v,
                _ => <super::SessionSummary as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_session(&mut self) {
            self.child = ::std::option::Option::None;
        }

        pub fn has_session(&self) -> bool {
            match self.child {
                ::std::option::Option::Some(split_tree_link::Child::Session(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_session(&mut self, v: super::SessionSummary) {
            self.child = ::std::option::Option::Some(split_tree_link::Child::Session(v))
        }

        // Mutable pointer to the field.
        pub fn mut_session(&mut self) -> &mut super::SessionSummary {
            if let ::std::option::Option::Some(split_tree_link::Child::Session(_)) = self.child {
            } else {
                self.child = ::std::option::Option::Some(split_tree_link::Child::Session(super::SessionSummary::new()));
            }
            match self.child {
                ::std::option::Option::Some(split_tree_link::Child::Session(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_session(&mut self) -> super::SessionSummary {
            if self.has_session() {
                match self.child.take() {
                    ::std::option::Option::Some(split_tree_link::Child::Session(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::SessionSummary::new()
            }
        }

        // optional .iterm2.SplitTreeNode node = 2;

        pub fn node(&self) -> &super::SplitTreeNode {
            match self.child {
                ::std::option::Option::Some(split_tree_link::Child::Node(ref v)) => v,
                _ => <super::SplitTreeNode as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_node(&mut self) {
            self.child = ::std::option::Option::None;
        }

        pub fn has_node(&self) -> bool {
            match self.child {
                ::std::option::Option::Some(split_tree_link::Child::Node(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_node(&mut self, v: super::SplitTreeNode) {
            self.child = ::std::option::Option::Some(split_tree_link::Child::Node(v))
        }

        // Mutable pointer to the field.
        pub fn mut_node(&mut self) -> &mut super::SplitTreeNode {
            if let ::std::option::Option::Some(split_tree_link::Child::Node(_)) = self.child {
            } else {
                self.child = ::std::option::Option::Some(split_tree_link::Child::Node(super::SplitTreeNode::new()));
            }
            match self.child {
                ::std::option::Option::Some(split_tree_link::Child::Node(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_node(&mut self) -> super::SplitTreeNode {
            if self.has_node() {
                match self.child.take() {
                    ::std::option::Option::Some(split_tree_link::Child::Node(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::SplitTreeNode::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::SessionSummary>(
                "session",
                SplitTreeLink::has_session,
                SplitTreeLink::session,
                SplitTreeLink::mut_session,
                SplitTreeLink::set_session,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::SplitTreeNode>(
                "node",
                SplitTreeLink::has_node,
                SplitTreeLink::node,
                SplitTreeLink::mut_node,
                SplitTreeLink::set_node,
            ));
            oneofs.push(split_tree_link::Child::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SplitTreeLink>(
                "SplitTreeNode.SplitTreeLink",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SplitTreeLink {
        const NAME: &'static str = "SplitTreeLink";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.child = ::std::option::Option::Some(split_tree_link::Child::Session(is.read_message()?));
                    },
                    18 => {
                        self.child = ::std::option::Option::Some(split_tree_link::Child::Node(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.child {
                match v {
                    &split_tree_link::Child::Session(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &split_tree_link::Child::Node(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.child {
                match v {
                    &split_tree_link::Child::Session(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &split_tree_link::Child::Node(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SplitTreeLink {
            SplitTreeLink::new()
        }

        fn clear(&mut self) {
            self.child = ::std::option::Option::None;
            self.child = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SplitTreeLink {
            static instance: SplitTreeLink = SplitTreeLink {
                child: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SplitTreeLink {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SplitTreeNode.SplitTreeLink").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SplitTreeLink {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SplitTreeLink {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `SplitTreeLink`
    pub mod split_tree_link {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:iterm2.SplitTreeNode.SplitTreeLink.child)
        pub enum Child {
            // @@protoc_insertion_point(oneof_field:iterm2.SplitTreeNode.SplitTreeLink.session)
            Session(super::super::SessionSummary),
            // @@protoc_insertion_point(oneof_field:iterm2.SplitTreeNode.SplitTreeLink.node)
            Node(super::super::SplitTreeNode),
        }

        impl ::protobuf::Oneof for Child {
        }

        impl ::protobuf::OneofFull for Child {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::SplitTreeLink as ::protobuf::MessageFull>::descriptor().oneof_by_name("child").unwrap()).clone()
            }
        }

        impl Child {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Child>("child")
            }
        }
    }
}

// @@protoc_insertion_point(message:iterm2.ListSessionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListSessionsResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.ListSessionsResponse.windows)
    pub windows: ::std::vec::Vec<list_sessions_response::Window>,
    // @@protoc_insertion_point(field:iterm2.ListSessionsResponse.buried_sessions)
    pub buried_sessions: ::std::vec::Vec<SessionSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.ListSessionsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSessionsResponse {
    fn default() -> &'a ListSessionsResponse {
        <ListSessionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListSessionsResponse {
    pub fn new() -> ListSessionsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "windows",
            |m: &ListSessionsResponse| { &m.windows },
            |m: &mut ListSessionsResponse| { &mut m.windows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buried_sessions",
            |m: &ListSessionsResponse| { &m.buried_sessions },
            |m: &mut ListSessionsResponse| { &mut m.buried_sessions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSessionsResponse>(
            "ListSessionsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSessionsResponse {
    const NAME: &'static str = "ListSessionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.windows.push(is.read_message()?);
                },
                18 => {
                    self.buried_sessions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.windows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.buried_sessions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.windows {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.buried_sessions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSessionsResponse {
        ListSessionsResponse::new()
    }

    fn clear(&mut self) {
        self.windows.clear();
        self.buried_sessions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSessionsResponse {
        static instance: ListSessionsResponse = ListSessionsResponse {
            windows: ::std::vec::Vec::new(),
            buried_sessions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSessionsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSessionsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSessionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSessionsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListSessionsResponse`
pub mod list_sessions_response {
    // @@protoc_insertion_point(message:iterm2.ListSessionsResponse.Window)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Window {
        // message fields
        // @@protoc_insertion_point(field:iterm2.ListSessionsResponse.Window.tabs)
        pub tabs: ::std::vec::Vec<Tab>,
        // @@protoc_insertion_point(field:iterm2.ListSessionsResponse.Window.window_id)
        pub window_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.ListSessionsResponse.Window.frame)
        pub frame: ::protobuf::MessageField<super::Frame>,
        // @@protoc_insertion_point(field:iterm2.ListSessionsResponse.Window.number)
        pub number: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.ListSessionsResponse.Window.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Window {
        fn default() -> &'a Window {
            <Window as ::protobuf::Message>::default_instance()
        }
    }

    impl Window {
        pub fn new() -> Window {
            ::std::default::Default::default()
        }

        // optional string window_id = 2;

        pub fn window_id(&self) -> &str {
            match self.window_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_window_id(&mut self) {
            self.window_id = ::std::option::Option::None;
        }

        pub fn has_window_id(&self) -> bool {
            self.window_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_window_id(&mut self, v: ::std::string::String) {
            self.window_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_window_id(&mut self) -> &mut ::std::string::String {
            if self.window_id.is_none() {
                self.window_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.window_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_window_id(&mut self) -> ::std::string::String {
            self.window_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 number = 4;

        pub fn number(&self) -> i32 {
            self.number.unwrap_or(0)
        }

        pub fn clear_number(&mut self) {
            self.number = ::std::option::Option::None;
        }

        pub fn has_number(&self) -> bool {
            self.number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_number(&mut self, v: i32) {
            self.number = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "tabs",
                |m: &Window| { &m.tabs },
                |m: &mut Window| { &mut m.tabs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "window_id",
                |m: &Window| { &m.window_id },
                |m: &mut Window| { &mut m.window_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Frame>(
                "frame",
                |m: &Window| { &m.frame },
                |m: &mut Window| { &mut m.frame },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "number",
                |m: &Window| { &m.number },
                |m: &mut Window| { &mut m.number },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Window>(
                "ListSessionsResponse.Window",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Window {
        const NAME: &'static str = "Window";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.tabs.push(is.read_message()?);
                    },
                    18 => {
                        self.window_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.frame)?;
                    },
                    32 => {
                        self.number = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.tabs {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.window_id.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.frame.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.number {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.tabs {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            if let Some(v) = self.window_id.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.frame.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.number {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Window {
            Window::new()
        }

        fn clear(&mut self) {
            self.tabs.clear();
            self.window_id = ::std::option::Option::None;
            self.frame.clear();
            self.number = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Window {
            static instance: Window = Window {
                tabs: ::std::vec::Vec::new(),
                window_id: ::std::option::Option::None,
                frame: ::protobuf::MessageField::none(),
                number: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Window {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListSessionsResponse.Window").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Window {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Window {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:iterm2.ListSessionsResponse.Tab)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tab {
        // message fields
        // @@protoc_insertion_point(field:iterm2.ListSessionsResponse.Tab.root)
        pub root: ::protobuf::MessageField<super::SplitTreeNode>,
        // @@protoc_insertion_point(field:iterm2.ListSessionsResponse.Tab.tab_id)
        pub tab_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.ListSessionsResponse.Tab.tmux_window_id)
        pub tmux_window_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.ListSessionsResponse.Tab.tmux_connection_id)
        pub tmux_connection_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:iterm2.ListSessionsResponse.Tab.minimized_sessions)
        pub minimized_sessions: ::std::vec::Vec<super::SessionSummary>,
        // special fields
        // @@protoc_insertion_point(special_field:iterm2.ListSessionsResponse.Tab.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tab {
        fn default() -> &'a Tab {
            <Tab as ::protobuf::Message>::default_instance()
        }
    }

    impl Tab {
        pub fn new() -> Tab {
            ::std::default::Default::default()
        }

        // optional string tab_id = 2;

        pub fn tab_id(&self) -> &str {
            match self.tab_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_tab_id(&mut self) {
            self.tab_id = ::std::option::Option::None;
        }

        pub fn has_tab_id(&self) -> bool {
            self.tab_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tab_id(&mut self, v: ::std::string::String) {
            self.tab_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tab_id(&mut self) -> &mut ::std::string::String {
            if self.tab_id.is_none() {
                self.tab_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.tab_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_tab_id(&mut self) -> ::std::string::String {
            self.tab_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string tmux_window_id = 4;

        pub fn tmux_window_id(&self) -> &str {
            match self.tmux_window_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_tmux_window_id(&mut self) {
            self.tmux_window_id = ::std::option::Option::None;
        }

        pub fn has_tmux_window_id(&self) -> bool {
            self.tmux_window_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tmux_window_id(&mut self, v: ::std::string::String) {
            self.tmux_window_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tmux_window_id(&mut self) -> &mut ::std::string::String {
            if self.tmux_window_id.is_none() {
                self.tmux_window_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.tmux_window_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_tmux_window_id(&mut self) -> ::std::string::String {
            self.tmux_window_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string tmux_connection_id = 5;

        pub fn tmux_connection_id(&self) -> &str {
            match self.tmux_connection_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_tmux_connection_id(&mut self) {
            self.tmux_connection_id = ::std::option::Option::None;
        }

        pub fn has_tmux_connection_id(&self) -> bool {
            self.tmux_connection_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tmux_connection_id(&mut self, v: ::std::string::String) {
            self.tmux_connection_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tmux_connection_id(&mut self) -> &mut ::std::string::String {
            if self.tmux_connection_id.is_none() {
                self.tmux_connection_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.tmux_connection_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_tmux_connection_id(&mut self) -> ::std::string::String {
            self.tmux_connection_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::SplitTreeNode>(
                "root",
                |m: &Tab| { &m.root },
                |m: &mut Tab| { &mut m.root },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tab_id",
                |m: &Tab| { &m.tab_id },
                |m: &mut Tab| { &mut m.tab_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tmux_window_id",
                |m: &Tab| { &m.tmux_window_id },
                |m: &mut Tab| { &mut m.tmux_window_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tmux_connection_id",
                |m: &Tab| { &m.tmux_connection_id },
                |m: &mut Tab| { &mut m.tmux_connection_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "minimized_sessions",
                |m: &Tab| { &m.minimized_sessions },
                |m: &mut Tab| { &mut m.minimized_sessions },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tab>(
                "ListSessionsResponse.Tab",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Tab {
        const NAME: &'static str = "Tab";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.root)?;
                    },
                    18 => {
                        self.tab_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.tmux_window_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.tmux_connection_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.minimized_sessions.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.root.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.tab_id.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.tmux_window_id.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.tmux_connection_id.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            for value in &self.minimized_sessions {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.root.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.tab_id.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.tmux_window_id.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.tmux_connection_id.as_ref() {
                os.write_string(5, v)?;
            }
            for v in &self.minimized_sessions {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tab {
            Tab::new()
        }

        fn clear(&mut self) {
            self.root.clear();
            self.tab_id = ::std::option::Option::None;
            self.tmux_window_id = ::std::option::Option::None;
            self.tmux_connection_id = ::std::option::Option::None;
            self.minimized_sessions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tab {
            static instance: Tab = Tab {
                root: ::protobuf::MessageField::none(),
                tab_id: ::std::option::Option::None,
                tmux_window_id: ::std::option::Option::None,
                tmux_connection_id: ::std::option::Option::None,
                minimized_sessions: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Tab {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListSessionsResponse.Tab").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Tab {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Tab {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:iterm2.CreateTabRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreateTabRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.CreateTabRequest.profile_name)
    pub profile_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.CreateTabRequest.window_id)
    pub window_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.CreateTabRequest.tab_index)
    pub tab_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:iterm2.CreateTabRequest.command)
    pub command: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.CreateTabRequest.custom_profile_properties)
    pub custom_profile_properties: ::std::vec::Vec<ProfileProperty>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.CreateTabRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateTabRequest {
    fn default() -> &'a CreateTabRequest {
        <CreateTabRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateTabRequest {
    pub fn new() -> CreateTabRequest {
        ::std::default::Default::default()
    }

    // optional string profile_name = 1;

    pub fn profile_name(&self) -> &str {
        match self.profile_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_profile_name(&mut self) {
        self.profile_name = ::std::option::Option::None;
    }

    pub fn has_profile_name(&self) -> bool {
        self.profile_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile_name(&mut self, v: ::std::string::String) {
        self.profile_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile_name(&mut self) -> &mut ::std::string::String {
        if self.profile_name.is_none() {
            self.profile_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.profile_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_profile_name(&mut self) -> ::std::string::String {
        self.profile_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string window_id = 2;

    pub fn window_id(&self) -> &str {
        match self.window_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_window_id(&mut self) {
        self.window_id = ::std::option::Option::None;
    }

    pub fn has_window_id(&self) -> bool {
        self.window_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window_id(&mut self, v: ::std::string::String) {
        self.window_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_window_id(&mut self) -> &mut ::std::string::String {
        if self.window_id.is_none() {
            self.window_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.window_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_window_id(&mut self) -> ::std::string::String {
        self.window_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 tab_index = 3;

    pub fn tab_index(&self) -> u32 {
        self.tab_index.unwrap_or(0)
    }

    pub fn clear_tab_index(&mut self) {
        self.tab_index = ::std::option::Option::None;
    }

    pub fn has_tab_index(&self) -> bool {
        self.tab_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tab_index(&mut self, v: u32) {
        self.tab_index = ::std::option::Option::Some(v);
    }

    // optional string command = 4;

    pub fn command(&self) -> &str {
        match self.command.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::std::string::String) {
        self.command = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut ::std::string::String {
        if self.command.is_none() {
            self.command = ::std::option::Option::Some(::std::string::String::new());
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> ::std::string::String {
        self.command.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "profile_name",
            |m: &CreateTabRequest| { &m.profile_name },
            |m: &mut CreateTabRequest| { &mut m.profile_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "window_id",
            |m: &CreateTabRequest| { &m.window_id },
            |m: &mut CreateTabRequest| { &mut m.window_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tab_index",
            |m: &CreateTabRequest| { &m.tab_index },
            |m: &mut CreateTabRequest| { &mut m.tab_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command",
            |m: &CreateTabRequest| { &m.command },
            |m: &mut CreateTabRequest| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "custom_profile_properties",
            |m: &CreateTabRequest| { &m.custom_profile_properties },
            |m: &mut CreateTabRequest| { &mut m.custom_profile_properties },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateTabRequest>(
            "CreateTabRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateTabRequest {
    const NAME: &'static str = "CreateTabRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.profile_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.window_id = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.tab_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.command = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.custom_profile_properties.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.profile_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.window_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.tab_index {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.command.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.custom_profile_properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.profile_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.window_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.tab_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.command.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.custom_profile_properties {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateTabRequest {
        CreateTabRequest::new()
    }

    fn clear(&mut self) {
        self.profile_name = ::std::option::Option::None;
        self.window_id = ::std::option::Option::None;
        self.tab_index = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.custom_profile_properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateTabRequest {
        static instance: CreateTabRequest = CreateTabRequest {
            profile_name: ::std::option::Option::None,
            window_id: ::std::option::Option::None,
            tab_index: ::std::option::Option::None,
            command: ::std::option::Option::None,
            custom_profile_properties: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateTabRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateTabRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateTabRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateTabRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:iterm2.CreateTabResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreateTabResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.CreateTabResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<create_tab_response::Status>>,
    // @@protoc_insertion_point(field:iterm2.CreateTabResponse.window_id)
    pub window_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.CreateTabResponse.tab_id)
    pub tab_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:iterm2.CreateTabResponse.session_id)
    pub session_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.CreateTabResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateTabResponse {
    fn default() -> &'a CreateTabResponse {
        <CreateTabResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateTabResponse {
    pub fn new() -> CreateTabResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.CreateTabResponse.Status status = 1;

    pub fn status(&self) -> create_tab_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(create_tab_response::Status::OK),
            None => create_tab_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: create_tab_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string window_id = 2;

    pub fn window_id(&self) -> &str {
        match self.window_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_window_id(&mut self) {
        self.window_id = ::std::option::Option::None;
    }

    pub fn has_window_id(&self) -> bool {
        self.window_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window_id(&mut self, v: ::std::string::String) {
        self.window_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_window_id(&mut self) -> &mut ::std::string::String {
        if self.window_id.is_none() {
            self.window_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.window_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_window_id(&mut self) -> ::std::string::String {
        self.window_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 tab_id = 3;

    pub fn tab_id(&self) -> i32 {
        self.tab_id.unwrap_or(0)
    }

    pub fn clear_tab_id(&mut self) {
        self.tab_id = ::std::option::Option::None;
    }

    pub fn has_tab_id(&self) -> bool {
        self.tab_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tab_id(&mut self, v: i32) {
        self.tab_id = ::std::option::Option::Some(v);
    }

    // optional string session_id = 4;

    pub fn session_id(&self) -> &str {
        match self.session_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::string::String) {
        self.session_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
        if self.session_id.is_none() {
            self.session_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::string::String {
        self.session_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &CreateTabResponse| { &m.status },
            |m: &mut CreateTabResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "window_id",
            |m: &CreateTabResponse| { &m.window_id },
            |m: &mut CreateTabResponse| { &mut m.window_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tab_id",
            |m: &CreateTabResponse| { &m.tab_id },
            |m: &mut CreateTabResponse| { &mut m.tab_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_id",
            |m: &CreateTabResponse| { &m.session_id },
            |m: &mut CreateTabResponse| { &mut m.session_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateTabResponse>(
            "CreateTabResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateTabResponse {
    const NAME: &'static str = "CreateTabResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.window_id = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.tab_id = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.session_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.window_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.tab_id {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.session_id.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.window_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.tab_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.session_id.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateTabResponse {
        CreateTabResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.window_id = ::std::option::Option::None;
        self.tab_id = ::std::option::Option::None;
        self.session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateTabResponse {
        static instance: CreateTabResponse = CreateTabResponse {
            status: ::std::option::Option::None,
            window_id: ::std::option::Option::None,
            tab_id: ::std::option::Option::None,
            session_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateTabResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateTabResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateTabResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateTabResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CreateTabResponse`
pub mod create_tab_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.CreateTabResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.CreateTabResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.CreateTabResponse.Status.INVALID_PROFILE_NAME)
        INVALID_PROFILE_NAME = 1,
        // @@protoc_insertion_point(enum_value:iterm2.CreateTabResponse.Status.INVALID_WINDOW_ID)
        INVALID_WINDOW_ID = 2,
        // @@protoc_insertion_point(enum_value:iterm2.CreateTabResponse.Status.INVALID_TAB_INDEX)
        INVALID_TAB_INDEX = 3,
        // @@protoc_insertion_point(enum_value:iterm2.CreateTabResponse.Status.MISSING_SUBSTITUTION)
        MISSING_SUBSTITUTION = 4,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::INVALID_PROFILE_NAME),
                2 => ::std::option::Option::Some(Status::INVALID_WINDOW_ID),
                3 => ::std::option::Option::Some(Status::INVALID_TAB_INDEX),
                4 => ::std::option::Option::Some(Status::MISSING_SUBSTITUTION),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "INVALID_PROFILE_NAME" => ::std::option::Option::Some(Status::INVALID_PROFILE_NAME),
                "INVALID_WINDOW_ID" => ::std::option::Option::Some(Status::INVALID_WINDOW_ID),
                "INVALID_TAB_INDEX" => ::std::option::Option::Some(Status::INVALID_TAB_INDEX),
                "MISSING_SUBSTITUTION" => ::std::option::Option::Some(Status::MISSING_SUBSTITUTION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::INVALID_PROFILE_NAME,
            Status::INVALID_WINDOW_ID,
            Status::INVALID_TAB_INDEX,
            Status::MISSING_SUBSTITUTION,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CreateTabResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("CreateTabResponse.Status")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.SplitPaneRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SplitPaneRequest {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SplitPaneRequest.session)
    pub session: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.SplitPaneRequest.split_direction)
    pub split_direction: ::std::option::Option<::protobuf::EnumOrUnknown<split_pane_request::SplitDirection>>,
    // @@protoc_insertion_point(field:iterm2.SplitPaneRequest.before)
    pub before: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:iterm2.SplitPaneRequest.profile_name)
    pub profile_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:iterm2.SplitPaneRequest.custom_profile_properties)
    pub custom_profile_properties: ::std::vec::Vec<ProfileProperty>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SplitPaneRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SplitPaneRequest {
    fn default() -> &'a SplitPaneRequest {
        <SplitPaneRequest as ::protobuf::Message>::default_instance()
    }
}

impl SplitPaneRequest {
    pub fn new() -> SplitPaneRequest {
        ::std::default::Default::default()
    }

    // optional string session = 1;

    pub fn session(&self) -> &str {
        match self.session.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::string::String) {
        self.session = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session(&mut self) -> &mut ::std::string::String {
        if self.session.is_none() {
            self.session = ::std::option::Option::Some(::std::string::String::new());
        }
        self.session.as_mut().unwrap()
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::string::String {
        self.session.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .iterm2.SplitPaneRequest.SplitDirection split_direction = 2;

    pub fn split_direction(&self) -> split_pane_request::SplitDirection {
        match self.split_direction {
            Some(e) => e.enum_value_or(split_pane_request::SplitDirection::VERTICAL),
            None => split_pane_request::SplitDirection::VERTICAL,
        }
    }

    pub fn clear_split_direction(&mut self) {
        self.split_direction = ::std::option::Option::None;
    }

    pub fn has_split_direction(&self) -> bool {
        self.split_direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_direction(&mut self, v: split_pane_request::SplitDirection) {
        self.split_direction = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool before = 3;

    pub fn before(&self) -> bool {
        self.before.unwrap_or(false)
    }

    pub fn clear_before(&mut self) {
        self.before = ::std::option::Option::None;
    }

    pub fn has_before(&self) -> bool {
        self.before.is_some()
    }

    // Param is passed by value, moved
    pub fn set_before(&mut self, v: bool) {
        self.before = ::std::option::Option::Some(v);
    }

    // optional string profile_name = 4;

    pub fn profile_name(&self) -> &str {
        match self.profile_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_profile_name(&mut self) {
        self.profile_name = ::std::option::Option::None;
    }

    pub fn has_profile_name(&self) -> bool {
        self.profile_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile_name(&mut self, v: ::std::string::String) {
        self.profile_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile_name(&mut self) -> &mut ::std::string::String {
        if self.profile_name.is_none() {
            self.profile_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.profile_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_profile_name(&mut self) -> ::std::string::String {
        self.profile_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session",
            |m: &SplitPaneRequest| { &m.session },
            |m: &mut SplitPaneRequest| { &mut m.session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "split_direction",
            |m: &SplitPaneRequest| { &m.split_direction },
            |m: &mut SplitPaneRequest| { &mut m.split_direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "before",
            |m: &SplitPaneRequest| { &m.before },
            |m: &mut SplitPaneRequest| { &mut m.before },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "profile_name",
            |m: &SplitPaneRequest| { &m.profile_name },
            |m: &mut SplitPaneRequest| { &mut m.profile_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "custom_profile_properties",
            |m: &SplitPaneRequest| { &m.custom_profile_properties },
            |m: &mut SplitPaneRequest| { &mut m.custom_profile_properties },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SplitPaneRequest>(
            "SplitPaneRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SplitPaneRequest {
    const NAME: &'static str = "SplitPaneRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.split_direction = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.before = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.profile_name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.custom_profile_properties.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.split_direction {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.before {
            my_size += 1 + 1;
        }
        if let Some(v) = self.profile_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.custom_profile_properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.split_direction {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.before {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.profile_name.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.custom_profile_properties {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SplitPaneRequest {
        SplitPaneRequest::new()
    }

    fn clear(&mut self) {
        self.session = ::std::option::Option::None;
        self.split_direction = ::std::option::Option::None;
        self.before = ::std::option::Option::None;
        self.profile_name = ::std::option::Option::None;
        self.custom_profile_properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SplitPaneRequest {
        static instance: SplitPaneRequest = SplitPaneRequest {
            session: ::std::option::Option::None,
            split_direction: ::std::option::Option::None,
            before: ::std::option::Option::None,
            profile_name: ::std::option::Option::None,
            custom_profile_properties: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SplitPaneRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SplitPaneRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SplitPaneRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SplitPaneRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SplitPaneRequest`
pub mod split_pane_request {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.SplitPaneRequest.SplitDirection)
    pub enum SplitDirection {
        // @@protoc_insertion_point(enum_value:iterm2.SplitPaneRequest.SplitDirection.VERTICAL)
        VERTICAL = 0,
        // @@protoc_insertion_point(enum_value:iterm2.SplitPaneRequest.SplitDirection.HORIZONTAL)
        HORIZONTAL = 1,
    }

    impl ::protobuf::Enum for SplitDirection {
        const NAME: &'static str = "SplitDirection";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SplitDirection> {
            match value {
                0 => ::std::option::Option::Some(SplitDirection::VERTICAL),
                1 => ::std::option::Option::Some(SplitDirection::HORIZONTAL),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<SplitDirection> {
            match str {
                "VERTICAL" => ::std::option::Option::Some(SplitDirection::VERTICAL),
                "HORIZONTAL" => ::std::option::Option::Some(SplitDirection::HORIZONTAL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SplitDirection] = &[
            SplitDirection::VERTICAL,
            SplitDirection::HORIZONTAL,
        ];
    }

    impl ::protobuf::EnumFull for SplitDirection {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SplitPaneRequest.SplitDirection").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for SplitDirection {
        fn default() -> Self {
            SplitDirection::VERTICAL
        }
    }

    impl SplitDirection {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SplitDirection>("SplitPaneRequest.SplitDirection")
        }
    }
}

// @@protoc_insertion_point(message:iterm2.SplitPaneResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SplitPaneResponse {
    // message fields
    // @@protoc_insertion_point(field:iterm2.SplitPaneResponse.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<split_pane_response::Status>>,
    // @@protoc_insertion_point(field:iterm2.SplitPaneResponse.session_id)
    pub session_id: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:iterm2.SplitPaneResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SplitPaneResponse {
    fn default() -> &'a SplitPaneResponse {
        <SplitPaneResponse as ::protobuf::Message>::default_instance()
    }
}

impl SplitPaneResponse {
    pub fn new() -> SplitPaneResponse {
        ::std::default::Default::default()
    }

    // optional .iterm2.SplitPaneResponse.Status status = 1;

    pub fn status(&self) -> split_pane_response::Status {
        match self.status {
            Some(e) => e.enum_value_or(split_pane_response::Status::OK),
            None => split_pane_response::Status::OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: split_pane_response::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &SplitPaneResponse| { &m.status },
            |m: &mut SplitPaneResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "session_id",
            |m: &SplitPaneResponse| { &m.session_id },
            |m: &mut SplitPaneResponse| { &mut m.session_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SplitPaneResponse>(
            "SplitPaneResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SplitPaneResponse {
    const NAME: &'static str = "SplitPaneResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.session_id.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.session_id {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.session_id {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SplitPaneResponse {
        SplitPaneResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.session_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SplitPaneResponse {
        static instance: SplitPaneResponse = SplitPaneResponse {
            status: ::std::option::Option::None,
            session_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SplitPaneResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SplitPaneResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SplitPaneResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SplitPaneResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SplitPaneResponse`
pub mod split_pane_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:iterm2.SplitPaneResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:iterm2.SplitPaneResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:iterm2.SplitPaneResponse.Status.SESSION_NOT_FOUND)
        SESSION_NOT_FOUND = 1,
        // @@protoc_insertion_point(enum_value:iterm2.SplitPaneResponse.Status.INVALID_PROFILE_NAME)
        INVALID_PROFILE_NAME = 2,
        // @@protoc_insertion_point(enum_value:iterm2.SplitPaneResponse.Status.CANNOT_SPLIT)
        CANNOT_SPLIT = 3,
        // @@protoc_insertion_point(enum_value:iterm2.SplitPaneResponse.Status.MALFORMED_CUSTOM_PROFILE_PROPERTY)
        MALFORMED_CUSTOM_PROFILE_PROPERTY = 4,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                2 => ::std::option::Option::Some(Status::INVALID_PROFILE_NAME),
                3 => ::std::option::Option::Some(Status::CANNOT_SPLIT),
                4 => ::std::option::Option::Some(Status::MALFORMED_CUSTOM_PROFILE_PROPERTY),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "OK" => ::std::option::Option::Some(Status::OK),
                "SESSION_NOT_FOUND" => ::std::option::Option::Some(Status::SESSION_NOT_FOUND),
                "INVALID_PROFILE_NAME" => ::std::option::Option::Some(Status::INVALID_PROFILE_NAME),
                "CANNOT_SPLIT" => ::std::option::Option::Some(Status::CANNOT_SPLIT),
                "MALFORMED_CUSTOM_PROFILE_PROPERTY" => ::std::option::Option::Some(Status::MALFORMED_CUSTOM_PROFILE_PROPERTY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::SESSION_NOT_FOUND,
            Status::INVALID_PROFILE_NAME,
            Status::CANNOT_SPLIT,
            Status::MALFORMED_CUSTOM_PROFILE_PROPERTY,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SplitPaneResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("SplitPaneResponse.Status")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:iterm2.SelectionMode)
pub enum SelectionMode {
    // @@protoc_insertion_point(enum_value:iterm2.SelectionMode.CHARACTER)
    CHARACTER = 0,
    // @@protoc_insertion_point(enum_value:iterm2.SelectionMode.WORD)
    WORD = 1,
    // @@protoc_insertion_point(enum_value:iterm2.SelectionMode.LINE)
    LINE = 2,
    // @@protoc_insertion_point(enum_value:iterm2.SelectionMode.SMART)
    SMART = 3,
    // @@protoc_insertion_point(enum_value:iterm2.SelectionMode.BOX)
    BOX = 4,
    // @@protoc_insertion_point(enum_value:iterm2.SelectionMode.WHOLE_LINE)
    WHOLE_LINE = 5,
}

impl ::protobuf::Enum for SelectionMode {
    const NAME: &'static str = "SelectionMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SelectionMode> {
        match value {
            0 => ::std::option::Option::Some(SelectionMode::CHARACTER),
            1 => ::std::option::Option::Some(SelectionMode::WORD),
            2 => ::std::option::Option::Some(SelectionMode::LINE),
            3 => ::std::option::Option::Some(SelectionMode::SMART),
            4 => ::std::option::Option::Some(SelectionMode::BOX),
            5 => ::std::option::Option::Some(SelectionMode::WHOLE_LINE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SelectionMode> {
        match str {
            "CHARACTER" => ::std::option::Option::Some(SelectionMode::CHARACTER),
            "WORD" => ::std::option::Option::Some(SelectionMode::WORD),
            "LINE" => ::std::option::Option::Some(SelectionMode::LINE),
            "SMART" => ::std::option::Option::Some(SelectionMode::SMART),
            "BOX" => ::std::option::Option::Some(SelectionMode::BOX),
            "WHOLE_LINE" => ::std::option::Option::Some(SelectionMode::WHOLE_LINE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SelectionMode] = &[
        SelectionMode::CHARACTER,
        SelectionMode::WORD,
        SelectionMode::LINE,
        SelectionMode::SMART,
        SelectionMode::BOX,
        SelectionMode::WHOLE_LINE,
    ];
}

impl ::protobuf::EnumFull for SelectionMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SelectionMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SelectionMode {
    fn default() -> Self {
        SelectionMode::CHARACTER
    }
}

impl SelectionMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SelectionMode>("SelectionMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:iterm2.NotificationType)
pub enum NotificationType {
    // @@protoc_insertion_point(enum_value:iterm2.NotificationType.NOTIFY_ON_KEYSTROKE)
    NOTIFY_ON_KEYSTROKE = 1,
    // @@protoc_insertion_point(enum_value:iterm2.NotificationType.NOTIFY_ON_SCREEN_UPDATE)
    NOTIFY_ON_SCREEN_UPDATE = 2,
    // @@protoc_insertion_point(enum_value:iterm2.NotificationType.NOTIFY_ON_PROMPT)
    NOTIFY_ON_PROMPT = 3,
    // @@protoc_insertion_point(enum_value:iterm2.NotificationType.NOTIFY_ON_LOCATION_CHANGE)
    NOTIFY_ON_LOCATION_CHANGE = 4,
    // @@protoc_insertion_point(enum_value:iterm2.NotificationType.NOTIFY_ON_CUSTOM_ESCAPE_SEQUENCE)
    NOTIFY_ON_CUSTOM_ESCAPE_SEQUENCE = 5,
    // @@protoc_insertion_point(enum_value:iterm2.NotificationType.NOTIFY_ON_VARIABLE_CHANGE)
    NOTIFY_ON_VARIABLE_CHANGE = 12,
    // @@protoc_insertion_point(enum_value:iterm2.NotificationType.KEYSTROKE_FILTER)
    KEYSTROKE_FILTER = 14,
    // @@protoc_insertion_point(enum_value:iterm2.NotificationType.NOTIFY_ON_NEW_SESSION)
    NOTIFY_ON_NEW_SESSION = 6,
    // @@protoc_insertion_point(enum_value:iterm2.NotificationType.NOTIFY_ON_TERMINATE_SESSION)
    NOTIFY_ON_TERMINATE_SESSION = 7,
    // @@protoc_insertion_point(enum_value:iterm2.NotificationType.NOTIFY_ON_LAYOUT_CHANGE)
    NOTIFY_ON_LAYOUT_CHANGE = 8,
    // @@protoc_insertion_point(enum_value:iterm2.NotificationType.NOTIFY_ON_FOCUS_CHANGE)
    NOTIFY_ON_FOCUS_CHANGE = 9,
    // @@protoc_insertion_point(enum_value:iterm2.NotificationType.NOTIFY_ON_SERVER_ORIGINATED_RPC)
    NOTIFY_ON_SERVER_ORIGINATED_RPC = 10,
    // @@protoc_insertion_point(enum_value:iterm2.NotificationType.NOTIFY_ON_BROADCAST_CHANGE)
    NOTIFY_ON_BROADCAST_CHANGE = 11,
    // @@protoc_insertion_point(enum_value:iterm2.NotificationType.NOTIFY_ON_PROFILE_CHANGE)
    NOTIFY_ON_PROFILE_CHANGE = 13,
}

impl ::protobuf::Enum for NotificationType {
    const NAME: &'static str = "NotificationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NotificationType> {
        match value {
            1 => ::std::option::Option::Some(NotificationType::NOTIFY_ON_KEYSTROKE),
            2 => ::std::option::Option::Some(NotificationType::NOTIFY_ON_SCREEN_UPDATE),
            3 => ::std::option::Option::Some(NotificationType::NOTIFY_ON_PROMPT),
            4 => ::std::option::Option::Some(NotificationType::NOTIFY_ON_LOCATION_CHANGE),
            5 => ::std::option::Option::Some(NotificationType::NOTIFY_ON_CUSTOM_ESCAPE_SEQUENCE),
            12 => ::std::option::Option::Some(NotificationType::NOTIFY_ON_VARIABLE_CHANGE),
            14 => ::std::option::Option::Some(NotificationType::KEYSTROKE_FILTER),
            6 => ::std::option::Option::Some(NotificationType::NOTIFY_ON_NEW_SESSION),
            7 => ::std::option::Option::Some(NotificationType::NOTIFY_ON_TERMINATE_SESSION),
            8 => ::std::option::Option::Some(NotificationType::NOTIFY_ON_LAYOUT_CHANGE),
            9 => ::std::option::Option::Some(NotificationType::NOTIFY_ON_FOCUS_CHANGE),
            10 => ::std::option::Option::Some(NotificationType::NOTIFY_ON_SERVER_ORIGINATED_RPC),
            11 => ::std::option::Option::Some(NotificationType::NOTIFY_ON_BROADCAST_CHANGE),
            13 => ::std::option::Option::Some(NotificationType::NOTIFY_ON_PROFILE_CHANGE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<NotificationType> {
        match str {
            "NOTIFY_ON_KEYSTROKE" => ::std::option::Option::Some(NotificationType::NOTIFY_ON_KEYSTROKE),
            "NOTIFY_ON_SCREEN_UPDATE" => ::std::option::Option::Some(NotificationType::NOTIFY_ON_SCREEN_UPDATE),
            "NOTIFY_ON_PROMPT" => ::std::option::Option::Some(NotificationType::NOTIFY_ON_PROMPT),
            "NOTIFY_ON_LOCATION_CHANGE" => ::std::option::Option::Some(NotificationType::NOTIFY_ON_LOCATION_CHANGE),
            "NOTIFY_ON_CUSTOM_ESCAPE_SEQUENCE" => ::std::option::Option::Some(NotificationType::NOTIFY_ON_CUSTOM_ESCAPE_SEQUENCE),
            "NOTIFY_ON_VARIABLE_CHANGE" => ::std::option::Option::Some(NotificationType::NOTIFY_ON_VARIABLE_CHANGE),
            "KEYSTROKE_FILTER" => ::std::option::Option::Some(NotificationType::KEYSTROKE_FILTER),
            "NOTIFY_ON_NEW_SESSION" => ::std::option::Option::Some(NotificationType::NOTIFY_ON_NEW_SESSION),
            "NOTIFY_ON_TERMINATE_SESSION" => ::std::option::Option::Some(NotificationType::NOTIFY_ON_TERMINATE_SESSION),
            "NOTIFY_ON_LAYOUT_CHANGE" => ::std::option::Option::Some(NotificationType::NOTIFY_ON_LAYOUT_CHANGE),
            "NOTIFY_ON_FOCUS_CHANGE" => ::std::option::Option::Some(NotificationType::NOTIFY_ON_FOCUS_CHANGE),
            "NOTIFY_ON_SERVER_ORIGINATED_RPC" => ::std::option::Option::Some(NotificationType::NOTIFY_ON_SERVER_ORIGINATED_RPC),
            "NOTIFY_ON_BROADCAST_CHANGE" => ::std::option::Option::Some(NotificationType::NOTIFY_ON_BROADCAST_CHANGE),
            "NOTIFY_ON_PROFILE_CHANGE" => ::std::option::Option::Some(NotificationType::NOTIFY_ON_PROFILE_CHANGE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [NotificationType] = &[
        NotificationType::NOTIFY_ON_KEYSTROKE,
        NotificationType::NOTIFY_ON_SCREEN_UPDATE,
        NotificationType::NOTIFY_ON_PROMPT,
        NotificationType::NOTIFY_ON_LOCATION_CHANGE,
        NotificationType::NOTIFY_ON_CUSTOM_ESCAPE_SEQUENCE,
        NotificationType::NOTIFY_ON_VARIABLE_CHANGE,
        NotificationType::KEYSTROKE_FILTER,
        NotificationType::NOTIFY_ON_NEW_SESSION,
        NotificationType::NOTIFY_ON_TERMINATE_SESSION,
        NotificationType::NOTIFY_ON_LAYOUT_CHANGE,
        NotificationType::NOTIFY_ON_FOCUS_CHANGE,
        NotificationType::NOTIFY_ON_SERVER_ORIGINATED_RPC,
        NotificationType::NOTIFY_ON_BROADCAST_CHANGE,
        NotificationType::NOTIFY_ON_PROFILE_CHANGE,
    ];
}

impl ::protobuf::EnumFull for NotificationType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("NotificationType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            NotificationType::NOTIFY_ON_KEYSTROKE => 0,
            NotificationType::NOTIFY_ON_SCREEN_UPDATE => 1,
            NotificationType::NOTIFY_ON_PROMPT => 2,
            NotificationType::NOTIFY_ON_LOCATION_CHANGE => 3,
            NotificationType::NOTIFY_ON_CUSTOM_ESCAPE_SEQUENCE => 4,
            NotificationType::NOTIFY_ON_VARIABLE_CHANGE => 5,
            NotificationType::KEYSTROKE_FILTER => 6,
            NotificationType::NOTIFY_ON_NEW_SESSION => 7,
            NotificationType::NOTIFY_ON_TERMINATE_SESSION => 8,
            NotificationType::NOTIFY_ON_LAYOUT_CHANGE => 9,
            NotificationType::NOTIFY_ON_FOCUS_CHANGE => 10,
            NotificationType::NOTIFY_ON_SERVER_ORIGINATED_RPC => 11,
            NotificationType::NOTIFY_ON_BROADCAST_CHANGE => 12,
            NotificationType::NOTIFY_ON_PROFILE_CHANGE => 13,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for NotificationType {
    fn default() -> Self {
        NotificationType::NOTIFY_ON_KEYSTROKE
    }
}

impl NotificationType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NotificationType>("NotificationType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:iterm2.Modifiers)
pub enum Modifiers {
    // @@protoc_insertion_point(enum_value:iterm2.Modifiers.CONTROL)
    CONTROL = 1,
    // @@protoc_insertion_point(enum_value:iterm2.Modifiers.OPTION)
    OPTION = 2,
    // @@protoc_insertion_point(enum_value:iterm2.Modifiers.COMMAND)
    COMMAND = 3,
    // @@protoc_insertion_point(enum_value:iterm2.Modifiers.SHIFT)
    SHIFT = 4,
    // @@protoc_insertion_point(enum_value:iterm2.Modifiers.FUNCTION)
    FUNCTION = 5,
    // @@protoc_insertion_point(enum_value:iterm2.Modifiers.NUMPAD)
    NUMPAD = 6,
}

impl ::protobuf::Enum for Modifiers {
    const NAME: &'static str = "Modifiers";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Modifiers> {
        match value {
            1 => ::std::option::Option::Some(Modifiers::CONTROL),
            2 => ::std::option::Option::Some(Modifiers::OPTION),
            3 => ::std::option::Option::Some(Modifiers::COMMAND),
            4 => ::std::option::Option::Some(Modifiers::SHIFT),
            5 => ::std::option::Option::Some(Modifiers::FUNCTION),
            6 => ::std::option::Option::Some(Modifiers::NUMPAD),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Modifiers> {
        match str {
            "CONTROL" => ::std::option::Option::Some(Modifiers::CONTROL),
            "OPTION" => ::std::option::Option::Some(Modifiers::OPTION),
            "COMMAND" => ::std::option::Option::Some(Modifiers::COMMAND),
            "SHIFT" => ::std::option::Option::Some(Modifiers::SHIFT),
            "FUNCTION" => ::std::option::Option::Some(Modifiers::FUNCTION),
            "NUMPAD" => ::std::option::Option::Some(Modifiers::NUMPAD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Modifiers] = &[
        Modifiers::CONTROL,
        Modifiers::OPTION,
        Modifiers::COMMAND,
        Modifiers::SHIFT,
        Modifiers::FUNCTION,
        Modifiers::NUMPAD,
    ];
}

impl ::protobuf::EnumFull for Modifiers {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Modifiers").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Modifiers::CONTROL => 0,
            Modifiers::OPTION => 1,
            Modifiers::COMMAND => 2,
            Modifiers::SHIFT => 3,
            Modifiers::FUNCTION => 4,
            Modifiers::NUMPAD => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Modifiers {
    fn default() -> Self {
        Modifiers::CONTROL
    }
}

impl Modifiers {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Modifiers>("Modifiers")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:iterm2.VariableScope)
pub enum VariableScope {
    // @@protoc_insertion_point(enum_value:iterm2.VariableScope.SESSION)
    SESSION = 1,
    // @@protoc_insertion_point(enum_value:iterm2.VariableScope.TAB)
    TAB = 2,
    // @@protoc_insertion_point(enum_value:iterm2.VariableScope.WINDOW)
    WINDOW = 3,
    // @@protoc_insertion_point(enum_value:iterm2.VariableScope.APP)
    APP = 4,
}

impl ::protobuf::Enum for VariableScope {
    const NAME: &'static str = "VariableScope";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VariableScope> {
        match value {
            1 => ::std::option::Option::Some(VariableScope::SESSION),
            2 => ::std::option::Option::Some(VariableScope::TAB),
            3 => ::std::option::Option::Some(VariableScope::WINDOW),
            4 => ::std::option::Option::Some(VariableScope::APP),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VariableScope> {
        match str {
            "SESSION" => ::std::option::Option::Some(VariableScope::SESSION),
            "TAB" => ::std::option::Option::Some(VariableScope::TAB),
            "WINDOW" => ::std::option::Option::Some(VariableScope::WINDOW),
            "APP" => ::std::option::Option::Some(VariableScope::APP),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VariableScope] = &[
        VariableScope::SESSION,
        VariableScope::TAB,
        VariableScope::WINDOW,
        VariableScope::APP,
    ];
}

impl ::protobuf::EnumFull for VariableScope {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VariableScope").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            VariableScope::SESSION => 0,
            VariableScope::TAB => 1,
            VariableScope::WINDOW => 2,
            VariableScope::APP => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for VariableScope {
    fn default() -> Self {
        VariableScope::SESSION
    }
}

impl VariableScope {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VariableScope>("VariableScope")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:iterm2.PromptMonitorMode)
pub enum PromptMonitorMode {
    // @@protoc_insertion_point(enum_value:iterm2.PromptMonitorMode.PROMPT)
    PROMPT = 1,
    // @@protoc_insertion_point(enum_value:iterm2.PromptMonitorMode.COMMAND_START)
    COMMAND_START = 2,
    // @@protoc_insertion_point(enum_value:iterm2.PromptMonitorMode.COMMAND_END)
    COMMAND_END = 3,
}

impl ::protobuf::Enum for PromptMonitorMode {
    const NAME: &'static str = "PromptMonitorMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PromptMonitorMode> {
        match value {
            1 => ::std::option::Option::Some(PromptMonitorMode::PROMPT),
            2 => ::std::option::Option::Some(PromptMonitorMode::COMMAND_START),
            3 => ::std::option::Option::Some(PromptMonitorMode::COMMAND_END),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PromptMonitorMode> {
        match str {
            "PROMPT" => ::std::option::Option::Some(PromptMonitorMode::PROMPT),
            "COMMAND_START" => ::std::option::Option::Some(PromptMonitorMode::COMMAND_START),
            "COMMAND_END" => ::std::option::Option::Some(PromptMonitorMode::COMMAND_END),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PromptMonitorMode] = &[
        PromptMonitorMode::PROMPT,
        PromptMonitorMode::COMMAND_START,
        PromptMonitorMode::COMMAND_END,
    ];
}

impl ::protobuf::EnumFull for PromptMonitorMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PromptMonitorMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            PromptMonitorMode::PROMPT => 0,
            PromptMonitorMode::COMMAND_START => 1,
            PromptMonitorMode::COMMAND_END => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for PromptMonitorMode {
    fn default() -> Self {
        PromptMonitorMode::PROMPT
    }
}

impl PromptMonitorMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PromptMonitorMode>("PromptMonitorMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:iterm2.AlternateColor)
pub enum AlternateColor {
    // @@protoc_insertion_point(enum_value:iterm2.AlternateColor.DEFAULT)
    DEFAULT = 0,
    // @@protoc_insertion_point(enum_value:iterm2.AlternateColor.REVERSED_DEFAULT)
    REVERSED_DEFAULT = 3,
    // @@protoc_insertion_point(enum_value:iterm2.AlternateColor.SYSTEM_MESSAGE)
    SYSTEM_MESSAGE = 4,
}

impl ::protobuf::Enum for AlternateColor {
    const NAME: &'static str = "AlternateColor";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AlternateColor> {
        match value {
            0 => ::std::option::Option::Some(AlternateColor::DEFAULT),
            3 => ::std::option::Option::Some(AlternateColor::REVERSED_DEFAULT),
            4 => ::std::option::Option::Some(AlternateColor::SYSTEM_MESSAGE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AlternateColor> {
        match str {
            "DEFAULT" => ::std::option::Option::Some(AlternateColor::DEFAULT),
            "REVERSED_DEFAULT" => ::std::option::Option::Some(AlternateColor::REVERSED_DEFAULT),
            "SYSTEM_MESSAGE" => ::std::option::Option::Some(AlternateColor::SYSTEM_MESSAGE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AlternateColor] = &[
        AlternateColor::DEFAULT,
        AlternateColor::REVERSED_DEFAULT,
        AlternateColor::SYSTEM_MESSAGE,
    ];
}

impl ::protobuf::EnumFull for AlternateColor {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AlternateColor").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            AlternateColor::DEFAULT => 0,
            AlternateColor::REVERSED_DEFAULT => 1,
            AlternateColor::SYSTEM_MESSAGE => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AlternateColor {
    fn default() -> Self {
        AlternateColor::DEFAULT
    }
}

impl AlternateColor {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AlternateColor>("AlternateColor")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:iterm2.ImagePlaceholderType)
pub enum ImagePlaceholderType {
    // @@protoc_insertion_point(enum_value:iterm2.ImagePlaceholderType.NONE)
    NONE = 0,
    // @@protoc_insertion_point(enum_value:iterm2.ImagePlaceholderType.ITERM2)
    ITERM2 = 1,
    // @@protoc_insertion_point(enum_value:iterm2.ImagePlaceholderType.KITTY)
    KITTY = 2,
}

impl ::protobuf::Enum for ImagePlaceholderType {
    const NAME: &'static str = "ImagePlaceholderType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ImagePlaceholderType> {
        match value {
            0 => ::std::option::Option::Some(ImagePlaceholderType::NONE),
            1 => ::std::option::Option::Some(ImagePlaceholderType::ITERM2),
            2 => ::std::option::Option::Some(ImagePlaceholderType::KITTY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ImagePlaceholderType> {
        match str {
            "NONE" => ::std::option::Option::Some(ImagePlaceholderType::NONE),
            "ITERM2" => ::std::option::Option::Some(ImagePlaceholderType::ITERM2),
            "KITTY" => ::std::option::Option::Some(ImagePlaceholderType::KITTY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ImagePlaceholderType] = &[
        ImagePlaceholderType::NONE,
        ImagePlaceholderType::ITERM2,
        ImagePlaceholderType::KITTY,
    ];
}

impl ::protobuf::EnumFull for ImagePlaceholderType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ImagePlaceholderType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ImagePlaceholderType {
    fn default() -> Self {
        ImagePlaceholderType::NONE
    }
}

impl ImagePlaceholderType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ImagePlaceholderType>("ImagePlaceholderType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tapi.proto\x12\x06iterm2\"\x9a\x16\n\x17ClientOriginatedMessage\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x03R\x02id\x12H\n\x12get_buffer_request\
    \x18d\x20\x01(\x0b2\x18.iterm2.GetBufferRequestH\0R\x10getBufferRequest\
    \x12H\n\x12get_prompt_request\x18e\x20\x01(\x0b2\x18.iterm2.GetPromptReq\
    uestH\0R\x10getPromptRequest\x12M\n\x13transaction_request\x18f\x20\x01(\
    \x0b2\x1a.iterm2.TransactionRequestH\0R\x12transactionRequest\x12P\n\x14\
    notification_request\x18g\x20\x01(\x0b2\x1b.iterm2.NotificationRequestH\
    \0R\x13notificationRequest\x12Q\n\x15register_tool_request\x18h\x20\x01(\
    \x0b2\x1b.iterm2.RegisterToolRequestH\0R\x13registerToolRequest\x12d\n\
    \x1cset_profile_property_request\x18i\x20\x01(\x0b2!.iterm2.SetProfilePr\
    opertyRequestH\0R\x19setProfilePropertyRequest\x12Q\n\x15list_sessions_r\
    equest\x18j\x20\x01(\x0b2\x1b.iterm2.ListSessionsRequestH\0R\x13listSess\
    ionsRequest\x12E\n\x11send_text_request\x18k\x20\x01(\x0b2\x17.iterm2.Se\
    ndTextRequestH\0R\x0fsendTextRequest\x12H\n\x12create_tab_request\x18l\
    \x20\x01(\x0b2\x18.iterm2.CreateTabRequestH\0R\x10createTabRequest\x12H\
    \n\x12split_pane_request\x18m\x20\x01(\x0b2\x18.iterm2.SplitPaneRequestH\
    \0R\x10splitPaneRequest\x12d\n\x1cget_profile_property_request\x18n\x20\
    \x01(\x0b2!.iterm2.GetProfilePropertyRequestH\0R\x19getProfilePropertyRe\
    quest\x12N\n\x14set_property_request\x18o\x20\x01(\x0b2\x1a.iterm2.SetPr\
    opertyRequestH\0R\x12setPropertyRequest\x12N\n\x14get_property_request\
    \x18p\x20\x01(\x0b2\x1a.iterm2.GetPropertyRequestH\0R\x12getPropertyRequ\
    est\x12>\n\x0einject_request\x18q\x20\x01(\x0b2\x15.iterm2.InjectRequest\
    H\0R\rinjectRequest\x12D\n\x10activate_request\x18r\x20\x01(\x0b2\x17.it\
    erm2.ActivateRequestH\0R\x0factivateRequest\x12D\n\x10variable_request\
    \x18s\x20\x01(\x0b2\x17.iterm2.VariableRequestH\0R\x0fvariableRequest\
    \x12]\n\x19saved_arrangement_request\x18t\x20\x01(\x0b2\x1f.iterm2.Saved\
    ArrangementRequestH\0R\x17savedArrangementRequest\x12;\n\rfocus_request\
    \x18u\x20\x01(\x0b2\x14.iterm2.FocusRequestH\0R\x0cfocusRequest\x12Q\n\
    \x15list_profiles_request\x18v\x20\x01(\x0b2\x1b.iterm2.ListProfilesRequ\
    estH\0R\x13listProfilesRequest\x12z\n$server_originated_rpc_result_reque\
    st\x18w\x20\x01(\x0b2(.iterm2.ServerOriginatedRPCResultRequestH\0R\x20se\
    rverOriginatedRpcResultRequest\x12W\n\x17restart_session_request\x18x\
    \x20\x01(\x0b2\x1d.iterm2.RestartSessionRequestH\0R\x15restartSessionReq\
    uest\x12E\n\x11menu_item_request\x18y\x20\x01(\x0b2\x17.iterm2.MenuItemR\
    equestH\0R\x0fmenuItemRequest\x12R\n\x16set_tab_layout_request\x18z\x20\
    \x01(\x0b2\x1b.iterm2.SetTabLayoutRequestH\0R\x13setTabLayoutRequest\x12\
    g\n\x1dget_broadcast_domains_request\x18{\x20\x01(\x0b2\".iterm2.GetBroa\
    dcastDomainsRequestH\0R\x1agetBroadcastDomainsRequest\x128\n\x0ctmux_req\
    uest\x18|\x20\x01(\x0b2\x13.iterm2.TmuxRequestH\0R\x0btmuxRequest\x12N\n\
    \x14reorder_tabs_request\x18}\x20\x01(\x0b2\x1a.iterm2.ReorderTabsReques\
    tH\0R\x12reorderTabsRequest\x12M\n\x13preferences_request\x18~\x20\x01(\
    \x0b2\x1a.iterm2.PreferencesRequestH\0R\x12preferencesRequest\x12N\n\x14\
    color_preset_request\x18\x7f\x20\x01(\x0b2\x1a.iterm2.ColorPresetRequest\
    H\0R\x12colorPresetRequest\x12H\n\x11selection_request\x18\x80\x01\x20\
    \x01(\x0b2\x18.iterm2.SelectionRequestH\0R\x10selectionRequest\x12e\n\
    \x1cstatus_bar_component_request\x18\x81\x01\x20\x01(\x0b2!.iterm2.Statu\
    sBarComponentRequestH\0R\x19statusBarComponentRequest\x12h\n\x1dset_broa\
    dcast_domains_request\x18\x82\x01\x20\x01(\x0b2\".iterm2.SetBroadcastDom\
    ainsRequestH\0R\x1asetBroadcastDomainsRequest\x12<\n\rclose_request\x18\
    \x83\x01\x20\x01(\x0b2\x14.iterm2.CloseRequestH\0R\x0ccloseRequest\x12X\
    \n\x17invoke_function_request\x18\x84\x01\x20\x01(\x0b2\x1d.iterm2.Invok\
    eFunctionRequestH\0R\x15invokeFunctionRequest\x12O\n\x14list_prompts_req\
    uest\x18\x85\x01\x20\x01(\x0b2\x1a.iterm2.ListPromptsRequestH\0R\x12list\
    PromptsRequestB\x0c\n\nsubmessage\"\xd5\x17\n\x17ServerOriginatedMessage\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\x03R\x02id\x12\x16\n\x05error\x18\x02\
    \x20\x01(\tH\0R\x05error\x12K\n\x13get_buffer_response\x18d\x20\x01(\x0b\
    2\x19.iterm2.GetBufferResponseH\0R\x11getBufferResponse\x12K\n\x13get_pr\
    ompt_response\x18e\x20\x01(\x0b2\x19.iterm2.GetPromptResponseH\0R\x11get\
    PromptResponse\x12P\n\x14transaction_response\x18f\x20\x01(\x0b2\x1b.ite\
    rm2.TransactionResponseH\0R\x13transactionResponse\x12S\n\x15notificatio\
    n_response\x18g\x20\x01(\x0b2\x1c.iterm2.NotificationResponseH\0R\x14not\
    ificationResponse\x12T\n\x16register_tool_response\x18h\x20\x01(\x0b2\
    \x1c.iterm2.RegisterToolResponseH\0R\x14registerToolResponse\x12g\n\x1ds\
    et_profile_property_response\x18i\x20\x01(\x0b2\".iterm2.SetProfilePrope\
    rtyResponseH\0R\x1asetProfilePropertyResponse\x12T\n\x16list_sessions_re\
    sponse\x18j\x20\x01(\x0b2\x1c.iterm2.ListSessionsResponseH\0R\x14listSes\
    sionsResponse\x12H\n\x12send_text_response\x18k\x20\x01(\x0b2\x18.iterm2\
    .SendTextResponseH\0R\x10sendTextResponse\x12K\n\x13create_tab_response\
    \x18l\x20\x01(\x0b2\x19.iterm2.CreateTabResponseH\0R\x11createTabRespons\
    e\x12K\n\x13split_pane_response\x18m\x20\x01(\x0b2\x19.iterm2.SplitPaneR\
    esponseH\0R\x11splitPaneResponse\x12g\n\x1dget_profile_property_response\
    \x18n\x20\x01(\x0b2\".iterm2.GetProfilePropertyResponseH\0R\x1agetProfil\
    ePropertyResponse\x12Q\n\x15set_property_response\x18o\x20\x01(\x0b2\x1b\
    .iterm2.SetPropertyResponseH\0R\x13setPropertyResponse\x12Q\n\x15get_pro\
    perty_response\x18p\x20\x01(\x0b2\x1b.iterm2.GetPropertyResponseH\0R\x13\
    getPropertyResponse\x12A\n\x0finject_response\x18q\x20\x01(\x0b2\x16.ite\
    rm2.InjectResponseH\0R\x0einjectResponse\x12G\n\x11activate_response\x18\
    r\x20\x01(\x0b2\x18.iterm2.ActivateResponseH\0R\x10activateResponse\x12G\
    \n\x11variable_response\x18s\x20\x01(\x0b2\x18.iterm2.VariableResponseH\
    \0R\x10variableResponse\x12`\n\x1asaved_arrangement_response\x18t\x20\
    \x01(\x0b2\x20.iterm2.SavedArrangementResponseH\0R\x18savedArrangementRe\
    sponse\x12>\n\x0efocus_response\x18u\x20\x01(\x0b2\x15.iterm2.FocusRespo\
    nseH\0R\rfocusResponse\x12T\n\x16list_profiles_response\x18v\x20\x01(\
    \x0b2\x1c.iterm2.ListProfilesResponseH\0R\x14listProfilesResponse\x12}\n\
    %server_originated_rpc_result_response\x18w\x20\x01(\x0b2).iterm2.Server\
    OriginatedRPCResultResponseH\0R!serverOriginatedRpcResultResponse\x12Z\n\
    \x18restart_session_response\x18x\x20\x01(\x0b2\x1e.iterm2.RestartSessio\
    nResponseH\0R\x16restartSessionResponse\x12H\n\x12menu_item_response\x18\
    y\x20\x01(\x0b2\x18.iterm2.MenuItemResponseH\0R\x10menuItemResponse\x12U\
    \n\x17set_tab_layout_response\x18z\x20\x01(\x0b2\x1c.iterm2.SetTabLayout\
    ResponseH\0R\x14setTabLayoutResponse\x12j\n\x1eget_broadcast_domains_res\
    ponse\x18{\x20\x01(\x0b2#.iterm2.GetBroadcastDomainsResponseH\0R\x1bgetB\
    roadcastDomainsResponse\x12;\n\rtmux_response\x18|\x20\x01(\x0b2\x14.ite\
    rm2.TmuxResponseH\0R\x0ctmuxResponse\x12Q\n\x15reorder_tabs_response\x18\
    }\x20\x01(\x0b2\x1b.iterm2.ReorderTabsResponseH\0R\x13reorderTabsRespons\
    e\x12P\n\x14preferences_response\x18~\x20\x01(\x0b2\x1b.iterm2.Preferenc\
    esResponseH\0R\x13preferencesResponse\x12Q\n\x15color_preset_response\
    \x18\x7f\x20\x01(\x0b2\x1b.iterm2.ColorPresetResponseH\0R\x13colorPreset\
    Response\x12K\n\x12selection_response\x18\x80\x01\x20\x01(\x0b2\x19.iter\
    m2.SelectionResponseH\0R\x11selectionResponse\x12h\n\x1dstatus_bar_compo\
    nent_response\x18\x81\x01\x20\x01(\x0b2\".iterm2.StatusBarComponentRespo\
    nseH\0R\x1astatusBarComponentResponse\x12k\n\x1eset_broadcast_domains_re\
    sponse\x18\x82\x01\x20\x01(\x0b2#.iterm2.SetBroadcastDomainsResponseH\0R\
    \x1bsetBroadcastDomainsResponse\x12?\n\x0eclose_response\x18\x83\x01\x20\
    \x01(\x0b2\x15.iterm2.CloseResponseH\0R\rcloseResponse\x12[\n\x18invoke_\
    function_response\x18\x84\x01\x20\x01(\x0b2\x1e.iterm2.InvokeFunctionRes\
    ponseH\0R\x16invokeFunctionResponse\x12R\n\x15list_prompts_response\x18\
    \x85\x01\x20\x01(\x0b2\x1b.iterm2.ListPromptsResponseH\0R\x13listPrompts\
    Response\x12;\n\x0cnotification\x18\xe8\x07\x20\x01(\x0b2\x14.iterm2.Not\
    ificationH\0R\x0cnotificationB\x0c\n\nsubmessage\"\xaf\x04\n\x15InvokeFu\
    nctionRequest\x125\n\x03tab\x18\x01\x20\x01(\x0b2!.iterm2.InvokeFunction\
    Request.TabH\0R\x03tab\x12A\n\x07session\x18\x02\x20\x01(\x0b2%.iterm2.I\
    nvokeFunctionRequest.SessionH\0R\x07session\x12>\n\x06window\x18\x03\x20\
    \x01(\x0b2$.iterm2.InvokeFunctionRequest.WindowH\0R\x06window\x125\n\x03\
    app\x18\x04\x20\x01(\x0b2!.iterm2.InvokeFunctionRequest.AppH\0R\x03app\
    \x12>\n\x06method\x18\x07\x20\x01(\x0b2$.iterm2.InvokeFunctionRequest.Me\
    thodH\0R\x06method\x12\x1e\n\ninvocation\x18\x05\x20\x01(\tR\ninvocation\
    \x12\x1e\n\x07timeout\x18\x06\x20\x01(\x01:\x02-1R\x07timeoutB\0\x1a\x1c\
    \n\x03Tab\x12\x15\n\x06tab_id\x18\x01\x20\x01(\tR\x05tabId\x1a(\n\x07Ses\
    sion\x12\x1d\n\nsession_id\x18\x01\x20\x01(\tR\tsessionId\x1a%\n\x06Wind\
    ow\x12\x1b\n\twindow_id\x18\x01\x20\x01(\tR\x08windowId\x1a\x05\n\x03App\
    \x1a$\n\x06Method\x12\x1a\n\x08receiver\x18\x01\x20\x01(\tR\x08receiverB\
    \t\n\x07context\"\x8a\x03\n\x16InvokeFunctionResponse\x12<\n\x05error\
    \x18\x01\x20\x01(\x0b2$.iterm2.InvokeFunctionResponse.ErrorH\0R\x05error\
    \x12B\n\x07success\x18\x02\x20\x01(\x0b2&.iterm2.InvokeFunctionResponse.\
    SuccessH\0R\x07success\x1ai\n\x05Error\x12=\n\x06status\x18\x01\x20\x01(\
    \x0e2%.iterm2.InvokeFunctionResponse.StatusR\x06status\x12!\n\x0cerror_r\
    eason\x18\x02\x20\x01(\tR\x0berrorReason\x1a*\n\x07Success\x12\x1f\n\x0b\
    json_result\x18\x01\x20\x01(\tR\njsonResult\"H\n\x06Status\x12\x0b\n\x07\
    TIMEOUT\x10\x01\x12\n\n\x06FAILED\x10\x02\x12\x15\n\x11REQUEST_MALFORMED\
    \x10\x03\x12\x0e\n\nINVALID_ID\x10\x04B\r\n\x0bdisposition\"\xec\x02\n\
    \x0cCloseRequest\x124\n\x04tabs\x18\x01\x20\x01(\x0b2\x1e.iterm2.CloseRe\
    quest.CloseTabsH\0R\x04tabs\x12@\n\x08sessions\x18\x02\x20\x01(\x0b2\".i\
    term2.CloseRequest.CloseSessionsH\0R\x08sessions\x12=\n\x07windows\x18\
    \x03\x20\x01(\x0b2!.iterm2.CloseRequest.CloseWindowsH\0R\x07windows\x12\
    \x14\n\x05force\x18\x04\x20\x01(\x08R\x05force\x1a$\n\tCloseTabs\x12\x17\
    \n\x07tab_ids\x18\x01\x20\x03(\tR\x06tabIds\x1a0\n\rCloseSessions\x12\
    \x1f\n\x0bsession_ids\x18\x01\x20\x03(\tR\nsessionIds\x1a-\n\x0cCloseWin\
    dows\x12\x1d\n\nwindow_ids\x18\x01\x20\x03(\tR\twindowIdsB\x08\n\x06targ\
    et\"}\n\rCloseResponse\x128\n\x08statuses\x18\x01\x20\x03(\x0e2\x1c.iter\
    m2.CloseResponse.StatusR\x08statuses\"2\n\x06Status\x12\x06\n\x02OK\x10\
    \0\x12\r\n\tNOT_FOUND\x10\x01\x12\x11\n\rUSER_DECLINED\x10\x02\"b\n\x1aS\
    etBroadcastDomainsRequest\x12D\n\x11broadcast_domains\x18\x01\x20\x03(\
    \x0b2\x17.iterm2.BroadcastDomainR\x10broadcastDomains\"\xcf\x01\n\x1bSet\
    BroadcastDomainsResponse\x12B\n\x06status\x18\x01\x20\x01(\x0e2*.iterm2.\
    SetBroadcastDomainsResponse.StatusR\x06status\"l\n\x06Status\x12\x06\n\
    \x02OK\x10\0\x12\x15\n\x11SESSION_NOT_FOUND\x10\x01\x12\"\n\x1eBROADCAST\
    _DOMAINS_NOT_DISJOINT\x10\x02\x12\x1f\n\x1bSESSIONS_NOT_IN_SAME_WINDOW\
    \x10\x03\"\xfe\x01\n\x19StatusBarComponentRequest\x12R\n\x0copen_popover\
    \x18\x01\x20\x01(\x0b2-.iterm2.StatusBarComponentRequest.OpenPopoverH\0R\
    \x0bopenPopover\x12\x1e\n\nidentifier\x18\x02\x20\x01(\tR\nidentifier\
    \x1ab\n\x0bOpenPopover\x12\x1d\n\nsession_id\x18\x01\x20\x01(\tR\tsessio\
    nId\x12\x12\n\x04html\x18\x02\x20\x01(\tR\x04html\x12\x20\n\x04size\x18\
    \x03\x20\x01(\x0b2\x0c.iterm2.SizeR\x04sizeB\t\n\x07request\"\xb7\x01\n\
    \x1aStatusBarComponentResponse\x12A\n\x06status\x18\x01\x20\x01(\x0e2).i\
    term2.StatusBarComponentResponse.StatusR\x06status\"V\n\x06Status\x12\
    \x06\n\x02OK\x10\0\x12\x15\n\x11SESSION_NOT_FOUND\x10\x01\x12\x15\n\x11R\
    EQUEST_MALFORMED\x10\x02\x12\x16\n\x12INVALID_IDENTIFIER\x10\x03\"r\n\
    \x12WindowedCoordRange\x123\n\x0bcoord_range\x18\x01\x20\x01(\x0b2\x12.i\
    term2.CoordRangeR\ncoordRange\x12'\n\x07columns\x18\x02\x20\x01(\x0b2\r.\
    iterm2.RangeR\x07columns\"\xb8\x01\n\x0cSubSelection\x12L\n\x14windowed_\
    coord_range\x18\x01\x20\x01(\x0b2\x1a.iterm2.WindowedCoordRangeR\x12wind\
    owedCoordRange\x12<\n\x0eselection_mode\x18\x02\x20\x01(\x0e2\x15.iterm2\
    .SelectionModeR\rselectionMode\x12\x1c\n\tconnected\x18\x03\x20\x01(\x08\
    R\tconnected\"H\n\tSelection\x12;\n\x0esub_selections\x18\x01\x20\x03(\
    \x0b2\x14.iterm2.SubSelectionR\rsubSelections\"\x82\x03\n\x10SelectionRe\
    quest\x12b\n\x15get_selection_request\x18\x01\x20\x01(\x0b2,.iterm2.Sele\
    ctionRequest.GetSelectionRequestH\0R\x13getSelectionRequest\x12b\n\x15se\
    t_selection_request\x18\x02\x20\x01(\x0b2,.iterm2.SelectionRequest.SetSe\
    lectionRequestH\0R\x13setSelectionRequest\x1a4\n\x13GetSelectionRequest\
    \x12\x1d\n\nsession_id\x18\x01\x20\x01(\tR\tsessionId\x1ae\n\x13SetSelec\
    tionRequest\x12\x1d\n\nsession_id\x18\x01\x20\x01(\tR\tsessionId\x12/\n\
    \tselection\x18\x02\x20\x01(\x0b2\x11.iterm2.SelectionR\tselectionB\t\n\
    \x07request\"\xdb\x03\n\x11SelectionResponse\x128\n\x06status\x18\x01\
    \x20\x01(\x0e2\x20.iterm2.SelectionResponse.StatusR\x06status\x12f\n\x16\
    get_selection_response\x18\x02\x20\x01(\x0b2..iterm2.SelectionResponse.G\
    etSelectionResponseH\0R\x14getSelectionResponse\x12f\n\x16set_selection_\
    response\x18\x03\x20\x01(\x0b2..iterm2.SelectionResponse.SetSelectionRes\
    ponseH\0R\x14setSelectionResponse\x1aG\n\x14GetSelectionResponse\x12/\n\
    \tselection\x18\x02\x20\x01(\x0b2\x11.iterm2.SelectionR\tselection\x1a\
    \x16\n\x14SetSelectionResponse\"O\n\x06Status\x12\x06\n\x02OK\x10\0\x12\
    \x13\n\x0fINVALID_SESSION\x10\x01\x12\x11\n\rINVALID_RANGE\x10\x02\x12\
    \x15\n\x11REQUEST_MALFORMED\x10\x03B\n\n\x08response\"\xe3\x01\n\x12Colo\
    rPresetRequest\x12K\n\x0clist_presets\x18\x01\x20\x01(\x0b2&.iterm2.Colo\
    rPresetRequest.ListPresetsH\0R\x0blistPresets\x12E\n\nget_preset\x18\x02\
    \x20\x01(\x0b2$.iterm2.ColorPresetRequest.GetPresetH\0R\tgetPreset\x1a\r\
    \n\x0bListPresets\x1a\x1f\n\tGetPreset\x12\x12\n\x04name\x18\x01\x20\x01\
    (\tR\x04nameB\t\n\x07request\"\xd4\x04\n\x13ColorPresetResponse\x12L\n\
    \x0clist_presets\x18\x01\x20\x01(\x0b2'.iterm2.ColorPresetResponse.ListP\
    resetsH\0R\x0blistPresets\x12F\n\nget_preset\x18\x02\x20\x01(\x0b2%.iter\
    m2.ColorPresetResponse.GetPresetH\0R\tgetPreset\x12:\n\x06status\x18\x03\
    \x20\x01(\x0e2\".iterm2.ColorPresetResponse.StatusR\x06status\x1a!\n\x0b\
    ListPresets\x12\x12\n\x04name\x18\x01\x20\x03(\tR\x04name\x1a\xfc\x01\n\
    \tGetPreset\x12Y\n\x0ecolor_settings\x18\x01\x20\x03(\x0b22.iterm2.Color\
    PresetResponse.GetPreset.ColorSettingR\rcolorSettings\x1a\x93\x01\n\x0cC\
    olorSetting\x12\x10\n\x03red\x18\x01\x20\x01(\x02R\x03red\x12\x14\n\x05g\
    reen\x18\x02\x20\x01(\x02R\x05green\x12\x12\n\x04blue\x18\x03\x20\x01(\
    \x02R\x04blue\x12\x14\n\x05alpha\x18\x04\x20\x01(\x02R\x05alpha\x12\x1f\
    \n\x0bcolor_space\x18\x05\x20\x01(\tR\ncolorSpace\x12\x10\n\x03key\x18\
    \x06\x20\x01(\tR\x03key\"=\n\x06Status\x12\x06\n\x02OK\x10\0\x12\x14\n\
    \x10PRESET_NOT_FOUND\x10\x01\x12\x15\n\x11REQUEST_MALFORMED\x10\x02B\n\n\
    \x08response\"\xd0\x05\n\x12PreferencesRequest\x12>\n\x08requests\x18\
    \x01\x20\x03(\x0b2\".iterm2.PreferencesRequest.RequestR\x08requests\x1a\
    \xf9\x04\n\x07Request\x12h\n\x16set_preference_request\x18\x01\x20\x01(\
    \x0b20.iterm2.PreferencesRequest.Request.SetPreferenceH\0R\x14setPrefere\
    nceRequest\x12h\n\x16get_preference_request\x18\x02\x20\x01(\x0b20.iterm\
    2.PreferencesRequest.Request.GetPreferenceH\0R\x14getPreferenceRequest\
    \x12u\n\x1bset_default_profile_request\x18\x03\x20\x01(\x0b24.iterm2.Pre\
    ferencesRequest.Request.SetDefaultProfileH\0R\x18setDefaultProfileReques\
    t\x12u\n\x1bget_default_profile_request\x18\x04\x20\x01(\x0b24.iterm2.Pr\
    eferencesRequest.Request.GetDefaultProfileH\0R\x18getDefaultProfileReque\
    st\x1a@\n\rSetPreference\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x1d\n\njson_value\x18\x02\x20\x01(\tR\tjsonValue\x1a!\n\rGetPreference\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x1a'\n\x11SetDefaultProfile\
    \x12\x12\n\x04guid\x18\x01\x20\x01(\tR\x04guid\x1a\x13\n\x11GetDefaultPr\
    ofileB\t\n\x07request\"\xda\x08\n\x13PreferencesResponse\x12<\n\x07resul\
    ts\x18\x01\x20\x03(\x0b2\".iterm2.PreferencesResponse.ResultR\x07results\
    \x1a\x84\x08\n\x06Result\x12j\n\x14unrecognized_request\x18\x01\x20\x01(\
    \x0b25.iterm2.PreferencesResponse.Result.UnrecognizedResultH\0R\x13unrec\
    ognizedRequest\x12l\n\x15set_preference_result\x18\x02\x20\x01(\x0b26.it\
    erm2.PreferencesResponse.Result.SetPreferenceResultH\0R\x13setPreference\
    Result\x12l\n\x15get_preference_result\x18\x03\x20\x01(\x0b26.iterm2.Pre\
    ferencesResponse.Result.GetPreferenceResultH\0R\x13getPreferenceResult\
    \x12y\n\x1aset_default_profile_result\x18\x04\x20\x01(\x0b2:.iterm2.Pref\
    erencesResponse.Result.SetDefaultProfileResultH\0R\x17setDefaultProfileR\
    esult\x12y\n\x1aget_default_profile_result\x18\x05\x20\x01(\x0b2:.iterm2\
    .PreferencesResponse.Result.GetDefaultProfileResultH\0R\x17getDefaultPro\
    fileResult\x1a\x9f\x01\n\x13SetPreferenceResult\x12U\n\x06status\x18\x01\
    \x20\x01(\x0e2=.iterm2.PreferencesResponse.Result.SetPreferenceResult.St\
    atusR\x06status\"1\n\x06Status\x12\x06\n\x02OK\x10\0\x12\x0c\n\x08BAD_JS\
    ON\x10\x01\x12\x11\n\rINVALID_VALUE\x10\x02\x1a4\n\x13GetPreferenceResul\
    t\x12\x1d\n\njson_value\x18\x01\x20\x01(\tR\tjsonValue\x1a\x94\x01\n\x17\
    SetDefaultProfileResult\x12Y\n\x06status\x18\x01\x20\x01(\x0e2A.iterm2.P\
    referencesResponse.Result.SetDefaultProfileResult.StatusR\x06status\"\
    \x1e\n\x06Status\x12\x06\n\x02OK\x10\0\x12\x0c\n\x08BAD_GUID\x10\x01\x1a\
    \x14\n\x12UnrecognizedResult\x1a-\n\x17GetDefaultProfileResult\x12\x12\n\
    \x04guid\x18\x01\x20\x01(\tR\x04guidB\x08\n\x06result\"\xa1\x01\n\x12Reo\
    rderTabsRequest\x12G\n\x0bassignments\x18\x03\x20\x03(\x0b2%.iterm2.Reor\
    derTabsRequest.AssignmentR\x0bassignments\x1aB\n\nAssignment\x12\x1b\n\t\
    window_id\x18\x01\x20\x01(\tR\x08windowId\x12\x17\n\x07tab_ids\x18\x02\
    \x20\x03(\tR\x06tabIds\"\xa6\x01\n\x13ReorderTabsResponse\x12:\n\x06stat\
    us\x18\x04\x20\x01(\x0e2\".iterm2.ReorderTabsResponse.StatusR\x06status\
    \"S\n\x06Status\x12\x06\n\x02OK\x10\0\x12\x16\n\x12INVALID_ASSIGNMENT\
    \x10\x01\x12\x15\n\x11INVALID_WINDOW_ID\x10\x02\x12\x12\n\x0eINVALID_TAB\
    _ID\x10\x03\"\xf1\x04\n\x0bTmuxRequest\x12P\n\x10list_connections\x18\
    \x01\x20\x01(\x0b2#.iterm2.TmuxRequest.ListConnectionsH\0R\x0flistConnec\
    tions\x12D\n\x0csend_command\x18\x02\x20\x01(\x0b2\x1f.iterm2.TmuxReques\
    t.SendCommandH\0R\x0bsendCommand\x12T\n\x12set_window_visible\x18\x03\
    \x20\x01(\x0b2$.iterm2.TmuxRequest.SetWindowVisibleH\0R\x10setWindowVisi\
    ble\x12G\n\rcreate_window\x18\x04\x20\x01(\x0b2\x20.iterm2.TmuxRequest.C\
    reateWindowH\0R\x0ccreateWindow\x1a\x11\n\x0fListConnections\x1aL\n\x0bS\
    endCommand\x12#\n\rconnection_id\x18\x01\x20\x01(\tR\x0cconnectionId\x12\
    \x18\n\x07command\x18\x02\x20\x01(\tR\x07command\x1an\n\x10SetWindowVisi\
    ble\x12#\n\rconnection_id\x18\x01\x20\x01(\tR\x0cconnectionId\x12\x1b\n\
    \twindow_id\x18\x02\x20\x01(\tR\x08windowId\x12\x18\n\x07visible\x18\x03\
    \x20\x01(\x08R\x07visible\x1aO\n\x0cCreateWindow\x12#\n\rconnection_id\
    \x18\x01\x20\x01(\tR\x0cconnectionId\x12\x1a\n\x08affinity\x18\x02\x20\
    \x01(\tR\x08affinityB\t\n\x07payload\"\x8a\x06\n\x0cTmuxResponse\x12Q\n\
    \x10list_connections\x18\x01\x20\x01(\x0b2$.iterm2.TmuxResponse.ListConn\
    ectionsH\0R\x0flistConnections\x12E\n\x0csend_command\x18\x02\x20\x01(\
    \x0b2\x20.iterm2.TmuxResponse.SendCommandH\0R\x0bsendCommand\x12U\n\x12s\
    et_window_visible\x18\x03\x20\x01(\x0b2%.iterm2.TmuxResponse.SetWindowVi\
    sibleH\0R\x10setWindowVisible\x12H\n\rcreate_window\x18\x05\x20\x01(\x0b\
    2!.iterm2.TmuxResponse.CreateWindowH\0R\x0ccreateWindow\x123\n\x06status\
    \x18\x04\x20\x01(\x0e2\x1b.iterm2.TmuxResponse.StatusR\x06status\x1a\xc3\
    \x01\n\x0fListConnections\x12Q\n\x0bconnections\x18\x01\x20\x03(\x0b2/.i\
    term2.TmuxResponse.ListConnections.ConnectionR\x0bconnections\x1a]\n\nCo\
    nnection\x12#\n\rconnection_id\x18\x01\x20\x01(\tR\x0cconnectionId\x12*\
    \n\x11owning_session_id\x18\x02\x20\x01(\tR\x0fowningSessionId\x1a%\n\
    \x0bSendCommand\x12\x16\n\x06output\x18\x01\x20\x01(\tR\x06output\x1a\
    \x12\n\x10SetWindowVisible\x1a%\n\x0cCreateWindow\x12\x15\n\x06tab_id\
    \x18\x01\x20\x01(\tR\x05tabId\"W\n\x06Status\x12\x06\n\x02OK\x10\0\x12\
    \x13\n\x0fINVALID_REQUEST\x10\x01\x12\x19\n\x15INVALID_CONNECTION_ID\x10\
    \x02\x12\x15\n\x11INVALID_WINDOW_ID\x10\x03B\t\n\x07payload\"\x1c\n\x1aG\
    etBroadcastDomainsRequest\"2\n\x0fBroadcastDomain\x12\x1f\n\x0bsession_i\
    ds\x18\x01\x20\x03(\tR\nsessionIds\"c\n\x1bGetBroadcastDomainsResponse\
    \x12D\n\x11broadcast_domains\x18\x01\x20\x03(\x0b2\x17.iterm2.BroadcastD\
    omainR\x10broadcastDomains\"W\n\x13SetTabLayoutRequest\x12)\n\x04root\
    \x18\x01\x20\x01(\x0b2\x15.iterm2.SplitTreeNodeR\x04root\x12\x15\n\x06ta\
    b_id\x18\x02\x20\x01(\tR\x05tabId\"\x97\x01\n\x14SetTabLayoutResponse\
    \x12;\n\x06status\x18\x01\x20\x01(\x0e2#.iterm2.SetTabLayoutResponse.Sta\
    tusR\x06status\"B\n\x06Status\x12\x06\n\x02OK\x10\0\x12\x0e\n\nBAD_TAB_I\
    D\x10\x01\x12\x0e\n\nWRONG_TREE\x10\x02\x12\x10\n\x0cINVALID_SIZE\x10\
    \x03\"P\n\x0fMenuItemRequest\x12\x1e\n\nidentifier\x18\x01\x20\x01(\tR\n\
    identifier\x12\x1d\n\nquery_only\x18\x02\x20\x01(\x08R\tqueryOnly\"\xb3\
    \x01\n\x10MenuItemResponse\x127\n\x06status\x18\x01\x20\x01(\x0e2\x1f.it\
    erm2.MenuItemResponse.StatusR\x06status\x12\x18\n\x07checked\x18\x02\x20\
    \x01(\x08R\x07checked\x12\x18\n\x07enabled\x18\x03\x20\x01(\x08R\x07enab\
    led\"2\n\x06Status\x12\x06\n\x02OK\x10\0\x12\x12\n\x0eBAD_IDENTIFIER\x10\
    \x01\x12\x0c\n\x08DISABLED\x10\x02\"\\\n\x15RestartSessionRequest\x12\
    \x1d\n\nsession_id\x18\x01\x20\x01(\tR\tsessionId\x12$\n\x0eonly_if_exit\
    ed\x18\x02\x20\x01(\x08R\x0conlyIfExited\"\x9d\x01\n\x16RestartSessionRe\
    sponse\x12=\n\x06status\x18\x01\x20\x01(\x0e2%.iterm2.RestartSessionResp\
    onse.StatusR\x06status\"D\n\x06Status\x12\x06\n\x02OK\x10\0\x12\x15\n\
    \x11SESSION_NOT_FOUND\x10\x01\x12\x1b\n\x17SESSION_NOT_RESTARTABLE\x10\
    \x02\"\x95\x01\n\x20ServerOriginatedRPCResultRequest\x12\x1d\n\nrequest_\
    id\x18\x01\x20\x01(\tR\trequestId\x12'\n\x0ejson_exception\x18\x02\x20\
    \x01(\tH\0R\rjsonException\x12\x1f\n\njson_value\x18\x03\x20\x01(\tH\0R\
    \tjsonValueB\x08\n\x06result\"#\n!ServerOriginatedRPCResultResponse\"K\n\
    \x13ListProfilesRequest\x12\x1e\n\nproperties\x18\x01\x20\x03(\tR\nprope\
    rties\x12\x14\n\x05guids\x18\x02\x20\x03(\tR\x05guids\"\x9c\x01\n\x14Lis\
    tProfilesResponse\x12@\n\x08profiles\x18\x01\x20\x03(\x0b2$.iterm2.ListP\
    rofilesResponse.ProfileR\x08profiles\x1aB\n\x07Profile\x127\n\npropertie\
    s\x18\x01\x20\x03(\x0b2\x17.iterm2.ProfilePropertyR\nproperties\"\x0e\n\
    \x0cFocusRequest\"W\n\rFocusResponse\x12F\n\rnotifications\x18\x01\x20\
    \x03(\x0b2\x20.iterm2.FocusChangedNotificationR\rnotifications\"\xb5\x01\
    \n\x17SavedArrangementRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04n\
    ame\x12>\n\x06action\x18\x02\x20\x01(\x0e2&.iterm2.SavedArrangementReque\
    st.ActionR\x06action\x12\x1b\n\twindow_id\x18\x03\x20\x01(\tR\x08windowI\
    d\")\n\x06Action\x12\x0b\n\x07RESTORE\x10\0\x12\x08\n\x04SAVE\x10\x01\
    \x12\x08\n\x04LIST\x10\x02\"\xcb\x01\n\x18SavedArrangementResponse\x12?\
    \n\x06status\x18\x01\x20\x01(\x0e2'.iterm2.SavedArrangementResponse.Stat\
    usR\x06status\x12\x14\n\x05names\x18\x02\x20\x03(\tR\x05names\"X\n\x06St\
    atus\x12\x06\n\x02OK\x10\0\x12\x19\n\x15ARRANGEMENT_NOT_FOUND\x10\x01\
    \x12\x14\n\x10WINDOW_NOT_FOUND\x10\x02\x12\x15\n\x11REQUEST_MALFORMED\
    \x10\x03\"\xf9\x01\n\x0fVariableRequest\x12\x1f\n\nsession_id\x18\x01\
    \x20\x01(\tH\0R\tsessionId\x12\x17\n\x06tab_id\x18\x04\x20\x01(\tH\0R\
    \x05tabId\x12\x12\n\x03app\x18\x05\x20\x01(\x08H\0R\x03app\x12\x1d\n\twi\
    ndow_id\x18\x06\x20\x01(\tH\0R\x08windowId\x12-\n\x03set\x18\x02\x20\x03\
    (\x0b2\x1b.iterm2.VariableRequest.SetR\x03set\x12\x10\n\x03get\x18\x03\
    \x20\x03(\tR\x03get\x1a/\n\x03Set\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05valueB\x07\n\x05scope\
    \"\xf5\x01\n\x10VariableResponse\x127\n\x06status\x18\x01\x20\x01(\x0e2\
    \x1f.iterm2.VariableResponse.StatusR\x06status\x12\x16\n\x06values\x18\
    \x02\x20\x03(\tR\x06values\"\x8f\x01\n\x06Status\x12\x06\n\x02OK\x10\0\
    \x12\x15\n\x11SESSION_NOT_FOUND\x10\x01\x12\x10\n\x0cINVALID_NAME\x10\
    \x02\x12\x11\n\rMISSING_SCOPE\x10\x03\x12\x11\n\rTAB_NOT_FOUND\x10\x04\
    \x12\x18\n\x14MULTI_GET_DISALLOWED\x10\x05\x12\x14\n\x10WINDOW_NOT_FOUND\
    \x10\x06\"\x8f\x03\n\x0fActivateRequest\x12\x1d\n\twindow_id\x18\x01\x20\
    \x01(\tH\0R\x08windowId\x12\x17\n\x06tab_id\x18\x02\x20\x01(\tH\0R\x05ta\
    bId\x12\x1f\n\nsession_id\x18\x03\x20\x01(\tH\0R\tsessionId\x12,\n\x12or\
    der_window_front\x18\x04\x20\x01(\x08R\x10orderWindowFront\x12\x1d\n\nse\
    lect_tab\x18\x05\x20\x01(\x08R\tselectTab\x12%\n\x0eselect_session\x18\
    \x06\x20\x01(\x08R\rselectSession\x12>\n\x0cactivate_app\x18\x07\x20\x01\
    (\x0b2\x1b.iterm2.ActivateRequest.AppR\x0bactivateApp\x1aa\n\x03App\x12*\
    \n\x11raise_all_windows\x18\x01\x20\x01(\x08R\x0fraiseAllWindows\x12.\n\
    \x13ignoring_other_apps\x18\x02\x20\x01(\x08R\x11ignoringOtherAppsB\x0c\
    \n\nidentifier\"\x85\x01\n\x10ActivateResponse\x127\n\x06status\x18\x01\
    \x20\x01(\x0e2\x1f.iterm2.ActivateResponse.StatusR\x06status\"8\n\x06Sta\
    tus\x12\x06\n\x02OK\x10\0\x12\x12\n\x0eBAD_IDENTIFIER\x10\x01\x12\x12\n\
    \x0eINVALID_OPTION\x10\x02\"B\n\rInjectRequest\x12\x1d\n\nsession_id\x18\
    \x01\x20\x03(\tR\tsessionId\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04d\
    ata\"p\n\x0eInjectResponse\x125\n\x06status\x18\x01\x20\x03(\x0e2\x1d.it\
    erm2.InjectResponse.StatusR\x06status\"'\n\x06Status\x12\x06\n\x02OK\x10\
    \0\x12\x15\n\x11SESSION_NOT_FOUND\x10\x01\"v\n\x12GetPropertyRequest\x12\
    \x1d\n\twindow_id\x18\x01\x20\x01(\tH\0R\x08windowId\x12\x1f\n\nsession_\
    id\x18\x03\x20\x01(\tH\0R\tsessionId\x12\x12\n\x04name\x18\x02\x20\x01(\
    \tR\x04nameB\x0c\n\nidentifier\"\xad\x01\n\x13GetPropertyResponse\x12:\n\
    \x06status\x18\x01\x20\x01(\x0e2\".iterm2.GetPropertyResponse.StatusR\
    \x06status\x12\x1d\n\njson_value\x18\x02\x20\x01(\tR\tjsonValue\";\n\x06\
    Status\x12\x06\n\x02OK\x10\0\x12\x15\n\x11UNRECOGNIZED_NAME\x10\x01\x12\
    \x12\n\x0eINVALID_TARGET\x10\x02\"\x95\x01\n\x12SetPropertyRequest\x12\
    \x1d\n\twindow_id\x18\x01\x20\x01(\tH\0R\x08windowId\x12\x1f\n\nsession_\
    id\x18\x05\x20\x01(\tH\0R\tsessionId\x12\x12\n\x04name\x18\x03\x20\x01(\
    \tR\x04name\x12\x1d\n\njson_value\x18\x04\x20\x01(\tR\tjsonValueB\x0c\n\
    \nidentifier\"\xcb\x01\n\x13SetPropertyResponse\x12:\n\x06status\x18\x01\
    \x20\x01(\x0e2\".iterm2.SetPropertyResponse.StatusR\x06status\"x\n\x06St\
    atus\x12\x06\n\x02OK\x10\0\x12\x15\n\x11UNRECOGNIZED_NAME\x10\x01\x12\
    \x11\n\rINVALID_VALUE\x10\x02\x12\x12\n\x0eINVALID_TARGET\x10\x03\x12\
    \x0c\n\x08DEFERRED\x10\x04\x12\x0e\n\nIMPOSSIBLE\x10\x05\x12\n\n\x06FAIL\
    ED\x10\x06\"\x98\x02\n\x13RegisterToolRequest\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12\x1e\n\nidentifier\x18\x02\x20\x01(\tR\nidentifi\
    er\x12H\n\x1creveal_if_already_registered\x18\x05\x20\x01(\x08:\x05false\
    R\x19revealIfAlreadyRegisteredB\0\x12R\n\ttool_type\x18\x03\x20\x01(\x0e\
    2$.iterm2.RegisterToolRequest.ToolType:\rWEB_VIEW_TOOLR\x08toolTypeB\0\
    \x12\x10\n\x03URL\x18\x04\x20\x01(\tR\x03URL\"\x1d\n\x08ToolType\x12\x11\
    \n\rWEB_VIEW_TOOL\x10\x01\"\xdd\x0f\n\x16RPCRegistrationRequest\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x12Q\n\targuments\x18\x02\x20\x03\
    (\x0b23.iterm2.RPCRegistrationRequest.RPCArgumentSignatureR\targuments\
    \x12F\n\x08defaults\x18\x04\x20\x03(\x0b2*.iterm2.RPCRegistrationRequest\
    .RPCArgumentR\x08defaults\x12\x18\n\x07timeout\x18\x03\x20\x01(\x02R\x07\
    timeout\x12B\n\x04role\x18\x05\x20\x01(\x0e2#.iterm2.RPCRegistrationRequ\
    est.Role:\x07GENERICR\x04roleB\0\x12q\n\x18session_title_attributes\x18\
    \x07\x20\x01(\x0b25.iterm2.RPCRegistrationRequest.SessionTitleAttributes\
    H\0R\x16sessionTitleAttributes\x12\x84\x01\n\x1fstatus_bar_component_att\
    ributes\x18\x08\x20\x01(\x0b2;.iterm2.RPCRegistrationRequest.StatusBarCo\
    mponentAttributesH\0R\x1cstatusBarComponentAttributes\x12n\n\x17context_\
    menu_attributes\x18\t\x20\x01(\x0b24.iterm2.RPCRegistrationRequest.Conte\
    xtMenuAttributesH\0R\x15contextMenuAttributes\x12%\n\x0cdisplay_name\x18\
    \x06\x20\x01(\tR\x0bdisplayNameB\x02\x18\x01\x1a*\n\x14RPCArgumentSignat\
    ure\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x1a5\n\x0bRPCArgument\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04path\x18\x02\
    \x20\x01(\tR\x04path\x1ah\n\x16SessionTitleAttributes\x12!\n\x0cdisplay_\
    name\x18\x01\x20\x01(\tR\x0bdisplayName\x12+\n\x11unique_identifier\x18\
    \x06\x20\x01(\tR\x10uniqueIdentifier\x1a\x80\x07\n\x1cStatusBarComponent\
    Attributes\x12+\n\x11short_description\x18\x01\x20\x01(\tR\x10shortDescr\
    iption\x121\n\x14detailed_description\x18\x02\x20\x01(\tR\x13detailedDes\
    cription\x12V\n\x05knobs\x18\x03\x20\x03(\x0b2@.iterm2.RPCRegistrationRe\
    quest.StatusBarComponentAttributes.KnobR\x05knobs\x12\x1a\n\x08exemplar\
    \x18\x04\x20\x01(\tR\x08exemplar\x12%\n\x0eupdate_cadence\x18\x05\x20\
    \x01(\x02R\rupdateCadence\x12+\n\x11unique_identifier\x18\x06\x20\x01(\t\
    R\x10uniqueIdentifier\x12V\n\x05icons\x18\x07\x20\x03(\x0b2@.iterm2.RPCR\
    egistrationRequest.StatusBarComponentAttributes.IconR\x05icons\x12h\n\
    \x06format\x18\x08\x20\x01(\x0e2B.iterm2.RPCRegistrationRequest.StatusBa\
    rComponentAttributes.Format:\nPLAIN_TEXTR\x06formatB\0\x1a\x9f\x02\n\x04\
    Knob\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12Y\n\x04type\x18\
    \x02\x20\x01(\x0e2E.iterm2.RPCRegistrationRequest.StatusBarComponentAttr\
    ibutes.Knob.TypeR\x04type\x12\x20\n\x0bplaceholder\x18\x03\x20\x01(\tR\
    \x0bplaceholder\x12,\n\x12json_default_value\x18\x04\x20\x01(\tR\x10json\
    DefaultValue\x12\x10\n\x03key\x18\x05\x20\x01(\tR\x03key\"F\n\x04Type\
    \x12\x0c\n\x08Checkbox\x10\x01\x12\n\n\x06String\x10\x02\x12\x19\n\x15Po\
    sitiveFloatingPoint\x10\x03\x12\t\n\x05Color\x10\x04\x1a0\n\x04Icon\x12\
    \x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x14\n\x05scale\x18\x02\
    \x20\x01(\x02R\x05scale\"\"\n\x06Format\x12\x0e\n\nPLAIN_TEXT\x10\0\x12\
    \x08\n\x04HTML\x10\x01\x1ag\n\x15ContextMenuAttributes\x12!\n\x0cdisplay\
    _name\x18\x01\x20\x01(\tR\x0bdisplayName\x12+\n\x11unique_identifier\x18\
    \x02\x20\x01(\tR\x10uniqueIdentifier\"R\n\x04Role\x12\x0b\n\x07GENERIC\
    \x10\x01\x12\x11\n\rSESSION_TITLE\x10\x02\x12\x18\n\x14STATUS_BAR_COMPON\
    ENT\x10\x03\x12\x10\n\x0cCONTEXT_MENU\x10\x04B\x18\n\x16RoleSpecificAttr\
    ibutes\"\x93\x01\n\x14RegisterToolResponse\x12;\n\x06status\x18\x01\x20\
    \x01(\x0e2#.iterm2.RegisterToolResponse.StatusR\x06status\">\n\x06Status\
    \x12\x06\n\x02OK\x10\0\x12\x15\n\x11REQUEST_MALFORMED\x10\x01\x12\x15\n\
    \x11PERMISSION_DENIED\x10\x02\"\x98\x02\n\x10KeystrokePattern\x12@\n\x12\
    required_modifiers\x18\x01\x20\x03(\x0e2\x11.iterm2.ModifiersR\x11requir\
    edModifiers\x12B\n\x13forbidden_modifiers\x18\x02\x20\x03(\x0e2\x11.iter\
    m2.ModifiersR\x12forbiddenModifiers\x12\x1a\n\x08keycodes\x18\x03\x20\
    \x03(\x05R\x08keycodes\x12\x1e\n\ncharacters\x18\x04\x20\x03(\tR\ncharac\
    ters\x12B\n\x1dcharacters_ignoring_modifiers\x18\x05\x20\x03(\tR\x1bchar\
    actersIgnoringModifiers\"\x81\x01\n\x17KeystrokeMonitorRequest\x12J\n\
    \x12patterns_to_ignore\x18\x01\x20\x03(\x0b2\x18.iterm2.KeystrokePattern\
    R\x10patternsToIgnoreB\x02\x18\x01\x12\x1a\n\x08advanced\x18\x02\x20\x01\
    (\x08R\x08advanced\"`\n\x16KeystrokeFilterRequest\x12F\n\x12patterns_to_\
    ignore\x18\x01\x20\x03(\x0b2\x18.iterm2.KeystrokePatternR\x10patternsToI\
    gnore\"y\n\x16VariableMonitorRequest\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12+\n\x05scope\x18\x02\x20\x01(\x0e2\x15.iterm2.VariableSco\
    peR\x05scope\x12\x1e\n\nidentifier\x18\x03\x20\x01(\tR\nidentifier\"*\n\
    \x14ProfileChangeRequest\x12\x12\n\x04guid\x18\x01\x20\x01(\tR\x04guid\"\
    G\n\x14PromptMonitorRequest\x12/\n\x05modes\x18\x01\x20\x03(\x0e2\x19.it\
    erm2.PromptMonitorModeR\x05modes\"\xc0\x05\n\x13NotificationRequest\x12\
    \x18\n\x07session\x18\x01\x20\x01(\tR\x07session\x12\x1c\n\tsubscribe\
    \x18\x02\x20\x01(\x08R\tsubscribe\x12E\n\x11notification_type\x18\x03\
    \x20\x01(\x0e2\x18.iterm2.NotificationTypeR\x10notificationType\x12Z\n\
    \x18rpc_registration_request\x18\x04\x20\x01(\x0b2\x1e.iterm2.RPCRegistr\
    ationRequestH\0R\x16rpcRegistrationRequest\x12]\n\x19keystroke_monitor_r\
    equest\x18\x05\x20\x01(\x0b2\x1f.iterm2.KeystrokeMonitorRequestH\0R\x17k\
    eystrokeMonitorRequest\x12Z\n\x18variable_monitor_request\x18\x06\x20\
    \x01(\x0b2\x1e.iterm2.VariableMonitorRequestH\0R\x16variableMonitorReque\
    st\x12T\n\x16profile_change_request\x18\x07\x20\x01(\x0b2\x1c.iterm2.Pro\
    fileChangeRequestH\0R\x14profileChangeRequest\x12Z\n\x18keystroke_filter\
    _request\x18\x08\x20\x01(\x0b2\x1e.iterm2.KeystrokeFilterRequestH\0R\x16\
    keystrokeFilterRequest\x12T\n\x16prompt_monitor_request\x18\t\x20\x01(\
    \x0b2\x1c.iterm2.PromptMonitorRequestH\0R\x14promptMonitorRequestB\x0b\n\
    \targuments\"\xfd\x01\n\x14NotificationResponse\x12;\n\x06status\x18\x01\
    \x20\x01(\x0e2#.iterm2.NotificationResponse.StatusR\x06status\"\xa7\x01\
    \n\x06Status\x12\x06\n\x02OK\x10\0\x12\x15\n\x11SESSION_NOT_FOUND\x10\
    \x01\x12\x15\n\x11REQUEST_MALFORMED\x10\x02\x12\x12\n\x0eNOT_SUBSCRIBED\
    \x10\x03\x12\x16\n\x12ALREADY_SUBSCRIBED\x10\x04\x12#\n\x1fDUPLICATE_SER\
    VER_ORIGINATED_RPC\x10\x05\x12\x16\n\x12INVALID_IDENTIFIER\x10\x06\"\xab\
    \n\n\x0cNotification\x12T\n\x16keystroke_notification\x18\x01\x20\x01(\
    \x0b2\x1d.iterm2.KeystrokeNotificationR\x15keystrokeNotification\x12^\n\
    \x1ascreen_update_notification\x18\x02\x20\x01(\x0b2\x20.iterm2.ScreenUp\
    dateNotificationR\x18screenUpdateNotification\x12K\n\x13prompt_notificat\
    ion\x18\x03\x20\x01(\x0b2\x1a.iterm2.PromptNotificationR\x12promptNotifi\
    cation\x12h\n\x1clocation_change_notification\x18\x04\x20\x01(\x0b2\".it\
    erm2.LocationChangeNotificationR\x1alocationChangeNotificationB\x02\x18\
    \x01\x12w\n#custom_escape_sequence_notification\x18\x05\x20\x01(\x0b2(.i\
    term2.CustomEscapeSequenceNotificationR\x20customEscapeSequenceNotificat\
    ion\x12X\n\x18new_session_notification\x18\x06\x20\x01(\x0b2\x1e.iterm2.\
    NewSessionNotificationR\x16newSessionNotification\x12j\n\x1eterminate_se\
    ssion_notification\x18\x07\x20\x01(\x0b2$.iterm2.TerminateSessionNotific\
    ationR\x1cterminateSessionNotification\x12a\n\x1blayout_changed_notifica\
    tion\x18\x08\x20\x01(\x0b2!.iterm2.LayoutChangedNotificationR\x19layoutC\
    hangedNotification\x12^\n\x1afocus_changed_notification\x18\t\x20\x01(\
    \x0b2\x20.iterm2.FocusChangedNotificationR\x18focusChangedNotification\
    \x12t\n\"server_originated_rpc_notification\x18\n\x20\x01(\x0b2'.iterm2.\
    ServerOriginatedRPCNotificationR\x1fserverOriginatedRpcNotification\x12g\
    \n\x19broadcast_domains_changed\x18\x0b\x20\x01(\x0b2+.iterm2.BroadcastD\
    omainsChangedNotificationR\x17broadcastDomainsChanged\x12g\n\x1dvariable\
    _changed_notification\x18\x0c\x20\x01(\x0b2#.iterm2.VariableChangedNotif\
    icationR\x1bvariableChangedNotification\x12d\n\x1cprofile_changed_notifi\
    cation\x18\r\x20\x01(\x0b2\".iterm2.ProfileChangedNotificationR\x1aprofi\
    leChangedNotification\"0\n\x1aProfileChangedNotification\x12\x12\n\x04gu\
    id\x18\x01\x20\x01(\tR\x04guid\"\xa4\x01\n\x1bVariableChangedNotificatio\
    n\x12+\n\x05scope\x18\x01\x20\x01(\x0e2\x15.iterm2.VariableScopeR\x05sco\
    pe\x12\x1e\n\nidentifier\x18\x02\x20\x01(\tR\nidentifier\x12\x12\n\x04na\
    me\x18\x03\x20\x01(\tR\x04name\x12$\n\x0ejson_new_value\x18\x04\x20\x01(\
    \tR\x0cjsonNewValue\"k\n#BroadcastDomainsChangedNotification\x12D\n\x11b\
    roadcast_domains\x18\x01\x20\x03(\x0b2\x17.iterm2.BroadcastDomainR\x10br\
    oadcastDomains\"\xb2\x01\n\x13ServerOriginatedRPC\x12\x12\n\x04name\x18\
    \x02\x20\x01(\tR\x04name\x12E\n\targuments\x18\x03\x20\x03(\x0b2'.iterm2\
    .ServerOriginatedRPC.RPCArgumentR\targuments\x1a@\n\x0bRPCArgument\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1d\n\njson_value\x18\x02\
    \x20\x01(\tR\tjsonValue\"o\n\x1fServerOriginatedRPCNotification\x12\x1d\
    \n\nrequest_id\x18\x01\x20\x01(\tR\trequestId\x12-\n\x03rpc\x18\x02\x20\
    \x01(\x0b2\x1b.iterm2.ServerOriginatedRPCR\x03rpc\"\xd3\x02\n\x15Keystro\
    keNotification\x12\x1e\n\ncharacters\x18\x01\x20\x01(\tR\ncharacters\x12\
    @\n\x1bcharactersIgnoringModifiers\x18\x02\x20\x01(\tR\x1bcharactersIgno\
    ringModifiers\x12/\n\tmodifiers\x18\x03\x20\x03(\x0e2\x11.iterm2.Modifie\
    rsR\tmodifiers\x12\x18\n\x07keyCode\x18\x04\x20\x01(\x05R\x07keyCode\x12\
    \x18\n\x07session\x18\x05\x20\x01(\tR\x07session\x12<\n\x06action\x18\
    \x06\x20\x01(\x0e2$.iterm2.KeystrokeNotification.ActionR\x06action\"5\n\
    \x06Action\x12\x0c\n\x08KEY_DOWN\x10\0\x12\n\n\x06KEY_UP\x10\x01\x12\x11\
    \n\rFLAGS_CHANGED\x10\x02\"4\n\x18ScreenUpdateNotification\x12\x18\n\x07\
    session\x18\x01\x20\x01(\tR\x07session\"o\n\x18PromptNotificationPrompt\
    \x12\x20\n\x0bplaceholder\x18\x01\x20\x01(\tR\x0bplaceholder\x121\n\x06p\
    rompt\x18\x02\x20\x01(\x0b2\x19.iterm2.GetPromptResponseR\x06prompt\":\n\
    \x1ePromptNotificationCommandStart\x12\x18\n\x07command\x18\x01\x20\x01(\
    \tR\x07command\"6\n\x1cPromptNotificationCommandEnd\x12\x16\n\x06status\
    \x18\x01\x20\x01(\x05R\x06status\"\xb5\x02\n\x12PromptNotification\x12\
    \x18\n\x07session\x18\x01\x20\x01(\tR\x07session\x12:\n\x06prompt\x18\
    \x02\x20\x01(\x0b2\x20.iterm2.PromptNotificationPromptH\0R\x06prompt\x12\
    M\n\rcommand_start\x18\x03\x20\x01(\x0b2&.iterm2.PromptNotificationComma\
    ndStartH\0R\x0ccommandStart\x12G\n\x0bcommand_end\x18\x04\x20\x01(\x0b2$\
    .iterm2.PromptNotificationCommandEndH\0R\ncommandEnd\x12(\n\x10unique_pr\
    ompt_id\x18\x05\x20\x01(\tR\x0euniquePromptIdB\x07\n\x05event\"\x8e\x01\
    \n\x1aLocationChangeNotification\x12\x1b\n\thost_name\x18\x01\x20\x01(\t\
    R\x08hostName\x12\x1b\n\tuser_name\x18\x02\x20\x01(\tR\x08userName\x12\
    \x1c\n\tdirectory\x18\x03\x20\x01(\tR\tdirectory\x12\x18\n\x07session\
    \x18\x04\x20\x01(\tR\x07session\"\x7f\n\x20CustomEscapeSequenceNotificat\
    ion\x12\x18\n\x07session\x18\x01\x20\x01(\tR\x07session\x12'\n\x0fsender\
    _identity\x18\x02\x20\x01(\tR\x0esenderIdentity\x12\x18\n\x07payload\x18\
    \x03\x20\x01(\tR\x07payload\"7\n\x16NewSessionNotification\x12\x1d\n\nse\
    ssion_id\x18\x01\x20\x01(\tR\tsessionId\"\xcd\x03\n\x18FocusChangedNotif\
    ication\x12/\n\x12application_active\x18\x01\x20\x01(\x08H\0R\x11applica\
    tionActive\x12A\n\x06window\x18\x02\x20\x01(\x0b2'.iterm2.FocusChangedNo\
    tification.WindowH\0R\x06window\x12#\n\x0cselected_tab\x18\x03\x20\x01(\
    \tH\0R\x0bselectedTab\x12\x1a\n\x07session\x18\x04\x20\x01(\tH\0R\x07ses\
    sion\x1a\xf2\x01\n\x06Window\x12Y\n\rwindow_status\x18\x01\x20\x01(\x0e2\
    4.iterm2.FocusChangedNotification.Window.WindowStatusR\x0cwindowStatus\
    \x12\x1b\n\twindow_id\x18\x02\x20\x01(\tR\x08windowId\"p\n\x0cWindowStat\
    us\x12\x1e\n\x1aTERMINAL_WINDOW_BECAME_KEY\x10\0\x12\x1e\n\x1aTERMINAL_W\
    INDOW_IS_CURRENT\x10\x01\x12\x20\n\x1cTERMINAL_WINDOW_RESIGNED_KEY\x10\
    \x02B\x07\n\x05event\"=\n\x1cTerminateSessionNotification\x12\x1d\n\nses\
    sion_id\x18\x01\x20\x01(\tR\tsessionId\"o\n\x19LayoutChangedNotification\
    \x12R\n\x16list_sessions_response\x18\x01\x20\x01(\x0b2\x1c.iterm2.ListS\
    essionsResponseR\x14listSessionsResponse\"\x85\x01\n\x10GetBufferRequest\
    \x12\x18\n\x07session\x18\x01\x20\x01(\tR\x07session\x120\n\nline_range\
    \x18\x02\x20\x01(\x0b2\x11.iterm2.LineRangeR\tlineRange\x12%\n\x0einclud\
    e_styles\x18\x03\x20\x01(\x08R\rincludeStyles\"\xb4\x03\n\x11GetBufferRe\
    sponse\x12>\n\x06status\x18\x01\x20\x01(\x0e2\x20.iterm2.GetBufferRespon\
    se.Status:\x02OKR\x06statusB\0\x12'\n\x05range\x18\x02\x20\x01(\x0b2\r.i\
    term2.RangeR\x05rangeB\x02\x18\x01\x120\n\x08contents\x18\x03\x20\x03(\
    \x0b2\x14.iterm2.LineContentsR\x08contents\x12%\n\x06cursor\x18\x04\x20\
    \x01(\x0b2\r.iterm2.CoordR\x06cursor\x127\n\x16num_lines_above_screen\
    \x18\x05\x20\x01(\x03R\x13numLinesAboveScreenB\x02\x18\x01\x12L\n\x14win\
    dowed_coord_range\x18\x06\x20\x01(\x0b2\x1a.iterm2.WindowedCoordRangeR\
    \x12windowedCoordRange\"V\n\x06Status\x12\x06\n\x02OK\x10\0\x12\x15\n\
    \x11SESSION_NOT_FOUND\x10\x01\x12\x16\n\x12INVALID_LINE_RANGE\x10\x02\
    \x12\x15\n\x11REQUEST_MALFORMED\x10\x03\"V\n\x10GetPromptRequest\x12\x18\
    \n\x07session\x18\x01\x20\x01(\tR\x07session\x12(\n\x10unique_prompt_id\
    \x18\x02\x20\x01(\tR\x0euniquePromptId\"\xd9\x04\n\x11GetPromptResponse\
    \x12>\n\x06status\x18\x01\x20\x01(\x0e2\x20.iterm2.GetPromptResponse.Sta\
    tus:\x02OKR\x06statusB\0\x125\n\x0cprompt_range\x18\x02\x20\x01(\x0b2\
    \x12.iterm2.CoordRangeR\x0bpromptRange\x127\n\rcommand_range\x18\x03\x20\
    \x01(\x0b2\x12.iterm2.CoordRangeR\x0ccommandRange\x125\n\x0coutput_range\
    \x18\x04\x20\x01(\x0b2\x12.iterm2.CoordRangeR\x0boutputRange\x12+\n\x11w\
    orking_directory\x18\x05\x20\x01(\tR\x10workingDirectory\x12\x18\n\x07co\
    mmand\x18\x06\x20\x01(\tR\x07command\x12B\n\x0cprompt_state\x18\x07\x20\
    \x01(\x0e2\x1f.iterm2.GetPromptResponse.StateR\x0bpromptState\x12\x1f\n\
    \x0bexit_status\x18\t\x20\x01(\rR\nexitStatus\x12(\n\x10unique_prompt_id\
    \x18\n\x20\x01(\tR\x0euniquePromptId\"V\n\x06Status\x12\x06\n\x02OK\x10\
    \0\x12\x15\n\x11SESSION_NOT_FOUND\x10\x01\x12\x15\n\x11REQUEST_MALFORMED\
    \x10\x02\x12\x16\n\x12PROMPT_UNAVAILABLE\x10\x03\"/\n\x05State\x12\x0b\n\
    \x07EDITING\x10\0\x12\x0b\n\x07RUNNING\x10\x01\x12\x0c\n\x08FINISHED\x10\
    \x02\"|\n\x12ListPromptsRequest\x12\x18\n\x07session\x18\x01\x20\x01(\tR\
    \x07session\x12&\n\x0ffirst_unique_id\x18\x02\x20\x01(\tR\rfirstUniqueId\
    \x12$\n\x0elast_unique_id\x18\x03\x20\x01(\tR\x0clastUniqueId\"\xaa\x01\
    \n\x13ListPromptsResponse\x12@\n\x06status\x18\x01\x20\x01(\x0e2\".iterm\
    2.ListPromptsResponse.Status:\x02OKR\x06statusB\0\x12(\n\x10unique_promp\
    t_id\x18\x02\x20\x03(\tR\x0euniquePromptId\"'\n\x06Status\x12\x06\n\x02O\
    K\x10\0\x12\x15\n\x11SESSION_NOT_FOUND\x10\x01\"I\n\x19GetProfilePropert\
    yRequest\x12\x18\n\x07session\x18\x01\x20\x01(\tR\x07session\x12\x12\n\
    \x04keys\x18\x02\x20\x03(\tR\x04keys\"B\n\x0fProfileProperty\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x1d\n\njson_value\x18\x02\x20\x01\
    (\tR\tjsonValue\"\xe9\x01\n\x1aGetProfilePropertyResponse\x12G\n\x06stat\
    us\x18\x01\x20\x01(\x0e2).iterm2.GetProfilePropertyResponse.Status:\x02O\
    KR\x06statusB\0\x127\n\nproperties\x18\x03\x20\x03(\x0b2\x17.iterm2.Prof\
    ilePropertyR\nproperties\"I\n\x06Status\x12\x06\n\x02OK\x10\0\x12\x15\n\
    \x11SESSION_NOT_FOUND\x10\x01\x12\x15\n\x11REQUEST_MALFORMED\x10\x02\x12\
    \t\n\x05ERROR\x10\x03\"\xee\x02\n\x19SetProfilePropertyRequest\x12\x1a\n\
    \x07session\x18\x01\x20\x01(\tH\0R\x07session\x12I\n\tguid_list\x18\x02\
    \x20\x01(\x0b2*.iterm2.SetProfilePropertyRequest.GuidListH\0R\x08guidLis\
    t\x12\x10\n\x03key\x18\x03\x20\x01(\tR\x03key\x12\x1d\n\njson_value\x18\
    \x04\x20\x01(\tR\tjsonValue\x12N\n\x0bassignments\x18\x05\x20\x03(\x0b2,\
    .iterm2.SetProfilePropertyRequest.AssignmentR\x0bassignments\x1a\x20\n\
    \x08GuidList\x12\x14\n\x05guids\x18\x01\x20\x03(\tR\x05guids\x1a=\n\nAss\
    ignment\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x1d\n\njson_valu\
    e\x18\x02\x20\x01(\tR\tjsonValueB\x08\n\x06target\"\xb3\x01\n\x1aSetProf\
    ilePropertyResponse\x12G\n\x06status\x18\x01\x20\x01(\x0e2).iterm2.SetPr\
    ofilePropertyResponse.Status:\x02OKR\x06statusB\0\"L\n\x06Status\x12\x06\
    \n\x02OK\x10\0\x12\x15\n\x11SESSION_NOT_FOUND\x10\x01\x12\x15\n\x11REQUE\
    ST_MALFORMED\x10\x02\x12\x0c\n\x08BAD_GUID\x10\x03\"*\n\x12TransactionRe\
    quest\x12\x14\n\x05begin\x18\x01\x20\x01(\x08R\x05begin\"\x99\x01\n\x13T\
    ransactionResponse\x12@\n\x06status\x18\x01\x20\x01(\x0e2\".iterm2.Trans\
    actionResponse.Status:\x02OKR\x06statusB\0\"@\n\x06Status\x12\x06\n\x02O\
    K\x10\0\x12\x12\n\x0eNO_TRANSACTION\x10\x01\x12\x1a\n\x16ALREADY_IN_TRAN\
    SACTION\x10\x02\"\xb2\x01\n\tLineRange\x120\n\x14screen_contents_only\
    \x18\x01\x20\x01(\x08R\x12screenContentsOnly\x12%\n\x0etrailing_lines\
    \x18\x02\x20\x01(\x05R\rtrailingLines\x12L\n\x14windowed_coord_range\x18\
    \x03\x20\x01(\x0b2\x1a.iterm2.WindowedCoordRangeR\x12windowedCoordRange\
    \";\n\x05Range\x12\x1a\n\x08location\x18\x01\x20\x01(\x03R\x08location\
    \x12\x16\n\x06length\x18\x02\x20\x01(\x03R\x06length\"R\n\nCoordRange\
    \x12#\n\x05start\x18\x01\x20\x01(\x0b2\r.iterm2.CoordR\x05start\x12\x1f\
    \n\x03end\x18\x02\x20\x01(\x0b2\r.iterm2.CoordR\x03end\"#\n\x05Coord\x12\
    \x0c\n\x01x\x18\x01\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\
    \x03R\x01y\"F\n\x08RGBColor\x12\x10\n\x03red\x18\x01\x20\x01(\rR\x03red\
    \x12\x14\n\x05green\x18\x02\x20\x01(\rR\x05green\x12\x12\n\x04blue\x18\
    \x03\x20\x01(\rR\x04blue\"7\n\x03URL\x12\x10\n\x03url\x18\x01\x20\x01(\t\
    R\x03url\x12\x1e\n\nidentifier\x18\x02\x20\x01(\tR\nidentifier\"\xd0\x06\
    \n\tCellStyle\x12\x20\n\nfgStandard\x18\x01\x20\x01(\rH\0R\nfgStandard\
    \x12:\n\x0bfgAlternate\x18\x02\x20\x01(\x0e2\x16.iterm2.AlternateColorH\
    \0R\x0bfgAlternate\x12(\n\x05fgRgb\x18\x03\x20\x01(\x0b2\x10.iterm2.RGBC\
    olorH\0R\x05fgRgb\x126\n\x15fgAlternatePlacementX\x18\x04\x20\x01(\rH\0R\
    \x15fgAlternatePlacementX\x12\x20\n\nbgStandard\x18\x05\x20\x01(\rH\x01R\
    \nbgStandard\x12:\n\x0bbgAlternate\x18\x06\x20\x01(\x0e2\x16.iterm2.Alte\
    rnateColorH\x01R\x0bbgAlternate\x12(\n\x05bgRgb\x18\x07\x20\x01(\x0b2\
    \x10.iterm2.RGBColorH\x01R\x05bgRgb\x126\n\x15bgAlternatePlacementY\x18\
    \x08\x20\x01(\rH\x01R\x15bgAlternatePlacementY\x12\x12\n\x04bold\x18\t\
    \x20\x01(\x08R\x04bold\x12\x14\n\x05faint\x18\n\x20\x01(\x08R\x05faint\
    \x12\x16\n\x06italic\x18\x0b\x20\x01(\x08R\x06italic\x12\x14\n\x05blink\
    \x18\x0c\x20\x01(\x08R\x05blink\x12\x1c\n\tunderline\x18\r\x20\x01(\x08R\
    \tunderline\x12$\n\rstrikethrough\x18\x0e\x20\x01(\x08R\rstrikethrough\
    \x12\x1c\n\tinvisible\x18\x0f\x20\x01(\x08R\tinvisible\x12\x18\n\x07inve\
    rse\x18\x10\x20\x01(\x08R\x07inverse\x12\x18\n\x07guarded\x18\x11\x20\
    \x01(\x08R\x07guarded\x122\n\x05image\x18\x12\x20\x01(\x0e2\x1c.iterm2.I\
    magePlaceholderTypeR\x05image\x128\n\x0eunderlineColor\x18\x13\x20\x01(\
    \x0b2\x10.iterm2.RGBColorR\x0eunderlineColor\x12\x18\n\x07blockID\x18\
    \x14\x20\x01(\tR\x07blockID\x12\x1d\n\x03url\x18\x15\x20\x01(\x0b2\x0b.i\
    term2.URLR\x03url\x12\x18\n\x07repeats\x18\x16\x20\x01(\rR\x07repeatsB\t\
    \n\x07fgColorB\t\n\x07bgColor\"\xbd\x02\n\x0cLineContents\x12\x12\n\x04t\
    ext\x18\x01\x20\x01(\tR\x04text\x12J\n\x14code_points_per_cell\x18\x02\
    \x20\x03(\x0b2\x19.iterm2.CodePointsPerCellR\x11codePointsPerCell\x12^\n\
    \x0ccontinuation\x18\x03\x20\x01(\x0e2!.iterm2.LineContents.Continuation\
    :\x15CONTINUATION_HARD_EOLR\x0ccontinuationB\0\x12'\n\x05style\x18\x04\
    \x20\x03(\x0b2\x11.iterm2.CellStyleR\x05style\"D\n\x0cContinuation\x12\
    \x19\n\x15CONTINUATION_HARD_EOL\x10\x01\x12\x19\n\x15CONTINUATION_SOFT_E\
    OL\x10\x02\"Z\n\x11CodePointsPerCell\x12+\n\x0fnum_code_points\x18\x01\
    \x20\x01(\x05:\x011R\rnumCodePointsB\0\x12\x18\n\x07repeats\x18\x02\x20\
    \x01(\x05R\x07repeats\"\x15\n\x13ListSessionsRequest\"n\n\x0fSendTextReq\
    uest\x12\x18\n\x07session\x18\x01\x20\x01(\tR\x07session\x12\x12\n\x04te\
    xt\x18\x02\x20\x01(\tR\x04text\x12-\n\x12suppress_broadcast\x18\x03\x20\
    \x01(\x08R\x11suppressBroadcast\"t\n\x10SendTextResponse\x127\n\x06statu\
    s\x18\x01\x20\x01(\x0e2\x1f.iterm2.SendTextResponse.StatusR\x06status\"'\
    \n\x06Status\x12\x06\n\x02OK\x10\0\x12\x15\n\x11SESSION_NOT_FOUND\x10\
    \x01\"4\n\x04Size\x12\x14\n\x05width\x18\x01\x20\x01(\x05R\x05width\x12\
    \x16\n\x06height\x18\x02\x20\x01(\x05R\x06height\"#\n\x05Point\x12\x0c\n\
    \x01x\x18\x01\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x05R\
    \x01y\"P\n\x05Frame\x12%\n\x06origin\x18\x01\x20\x01(\x0b2\r.iterm2.Poin\
    tR\x06origin\x12\x20\n\x04size\x18\x02\x20\x01(\x0b2\x0c.iterm2.SizeR\
    \x04size\"\xa3\x01\n\x0eSessionSummary\x12+\n\x11unique_identifier\x18\
    \x01\x20\x01(\tR\x10uniqueIdentifier\x12#\n\x05frame\x18\x02\x20\x01(\
    \x0b2\r.iterm2.FrameR\x05frame\x12)\n\tgrid_size\x18\x03\x20\x01(\x0b2\
    \x0c.iterm2.SizeR\x08gridSize\x12\x14\n\x05title\x18\x04\x20\x01(\tR\x05\
    title\"\xe1\x01\n\rSplitTreeNode\x12\x1a\n\x08vertical\x18\x01\x20\x01(\
    \x08R\x08vertical\x129\n\x05links\x18\x02\x20\x03(\x0b2#.iterm2.SplitTre\
    eNode.SplitTreeLinkR\x05links\x1ay\n\rSplitTreeLink\x122\n\x07session\
    \x18\x01\x20\x01(\x0b2\x16.iterm2.SessionSummaryH\0R\x07session\x12+\n\
    \x04node\x18\x02\x20\x01(\x0b2\x15.iterm2.SplitTreeNodeH\0R\x04nodeB\x07\
    \n\x05child\"\x96\x04\n\x14ListSessionsResponse\x12=\n\x07windows\x18\
    \x01\x20\x03(\x0b2#.iterm2.ListSessionsResponse.WindowR\x07windows\x12?\
    \n\x0fburied_sessions\x18\x02\x20\x03(\x0b2\x16.iterm2.SessionSummaryR\
    \x0eburiedSessions\x1a\x98\x01\n\x06Window\x124\n\x04tabs\x18\x01\x20\
    \x03(\x0b2\x20.iterm2.ListSessionsResponse.TabR\x04tabs\x12\x1b\n\twindo\
    w_id\x18\x02\x20\x01(\tR\x08windowId\x12#\n\x05frame\x18\x03\x20\x01(\
    \x0b2\r.iterm2.FrameR\x05frame\x12\x16\n\x06number\x18\x04\x20\x01(\x05R\
    \x06number\x1a\xe2\x01\n\x03Tab\x12)\n\x04root\x18\x03\x20\x01(\x0b2\x15\
    .iterm2.SplitTreeNodeR\x04root\x12\x15\n\x06tab_id\x18\x02\x20\x01(\tR\
    \x05tabId\x12$\n\x0etmux_window_id\x18\x04\x20\x01(\tR\x0ctmuxWindowId\
    \x12,\n\x12tmux_connection_id\x18\x05\x20\x01(\tR\x10tmuxConnectionId\
    \x12E\n\x12minimized_sessions\x18\x06\x20\x03(\x0b2\x16.iterm2.SessionSu\
    mmaryR\x11minimizedSessions\"\xe2\x01\n\x10CreateTabRequest\x12!\n\x0cpr\
    ofile_name\x18\x01\x20\x01(\tR\x0bprofileName\x12\x1b\n\twindow_id\x18\
    \x02\x20\x01(\tR\x08windowId\x12\x1b\n\ttab_index\x18\x03\x20\x01(\rR\
    \x08tabIndex\x12\x1c\n\x07command\x18\x04\x20\x01(\tR\x07commandB\x02\
    \x18\x01\x12S\n\x19custom_profile_properties\x18\x05\x20\x03(\x0b2\x17.i\
    term2.ProfilePropertyR\x17customProfileProperties\"\x94\x02\n\x11CreateT\
    abResponse\x128\n\x06status\x18\x01\x20\x01(\x0e2\x20.iterm2.CreateTabRe\
    sponse.StatusR\x06status\x12\x1b\n\twindow_id\x18\x02\x20\x01(\tR\x08win\
    dowId\x12\x15\n\x06tab_id\x18\x03\x20\x01(\x05R\x05tabId\x12\x1d\n\nsess\
    ion_id\x18\x04\x20\x01(\tR\tsessionId\"r\n\x06Status\x12\x06\n\x02OK\x10\
    \0\x12\x18\n\x14INVALID_PROFILE_NAME\x10\x01\x12\x15\n\x11INVALID_WINDOW\
    _ID\x10\x02\x12\x15\n\x11INVALID_TAB_INDEX\x10\x03\x12\x18\n\x14MISSING_\
    SUBSTITUTION\x10\x04\"\xc7\x02\n\x10SplitPaneRequest\x12\x18\n\x07sessio\
    n\x18\x01\x20\x01(\tR\x07session\x12P\n\x0fsplit_direction\x18\x02\x20\
    \x01(\x0e2'.iterm2.SplitPaneRequest.SplitDirectionR\x0esplitDirection\
    \x12\x1f\n\x06before\x18\x03\x20\x01(\x08:\x05falseR\x06beforeB\0\x12!\n\
    \x0cprofile_name\x18\x04\x20\x01(\tR\x0bprofileName\x12S\n\x19custom_pro\
    file_properties\x18\x05\x20\x03(\x0b2\x17.iterm2.ProfilePropertyR\x17cus\
    tomProfileProperties\".\n\x0eSplitDirection\x12\x0c\n\x08VERTICAL\x10\0\
    \x12\x0e\n\nHORIZONTAL\x10\x01\"\xe8\x01\n\x11SplitPaneResponse\x128\n\
    \x06status\x18\x01\x20\x01(\x0e2\x20.iterm2.SplitPaneResponse.StatusR\
    \x06status\x12\x1d\n\nsession_id\x18\x02\x20\x03(\tR\tsessionId\"z\n\x06\
    Status\x12\x06\n\x02OK\x10\0\x12\x15\n\x11SESSION_NOT_FOUND\x10\x01\x12\
    \x18\n\x14INVALID_PROFILE_NAME\x10\x02\x12\x10\n\x0cCANNOT_SPLIT\x10\x03\
    \x12%\n!MALFORMED_CUSTOM_PROFILE_PROPERTY\x10\x04*V\n\rSelectionMode\x12\
    \r\n\tCHARACTER\x10\0\x12\x08\n\x04WORD\x10\x01\x12\x08\n\x04LINE\x10\
    \x02\x12\t\n\x05SMART\x10\x03\x12\x07\n\x03BOX\x10\x04\x12\x0e\n\nWHOLE_\
    LINE\x10\x05*\xb4\x03\n\x10NotificationType\x12\x17\n\x13NOTIFY_ON_KEYST\
    ROKE\x10\x01\x12\x1b\n\x17NOTIFY_ON_SCREEN_UPDATE\x10\x02\x12\x14\n\x10N\
    OTIFY_ON_PROMPT\x10\x03\x12!\n\x19NOTIFY_ON_LOCATION_CHANGE\x10\x04\x1a\
    \x02\x08\x01\x12$\n\x20NOTIFY_ON_CUSTOM_ESCAPE_SEQUENCE\x10\x05\x12\x1d\
    \n\x19NOTIFY_ON_VARIABLE_CHANGE\x10\x0c\x12\x14\n\x10KEYSTROKE_FILTER\
    \x10\x0e\x12\x19\n\x15NOTIFY_ON_NEW_SESSION\x10\x06\x12\x1f\n\x1bNOTIFY_\
    ON_TERMINATE_SESSION\x10\x07\x12\x1b\n\x17NOTIFY_ON_LAYOUT_CHANGE\x10\
    \x08\x12\x1a\n\x16NOTIFY_ON_FOCUS_CHANGE\x10\t\x12#\n\x1fNOTIFY_ON_SERVE\
    R_ORIGINATED_RPC\x10\n\x12\x1e\n\x1aNOTIFY_ON_BROADCAST_CHANGE\x10\x0b\
    \x12\x1c\n\x18NOTIFY_ON_PROFILE_CHANGE\x10\r*V\n\tModifiers\x12\x0b\n\
    \x07CONTROL\x10\x01\x12\n\n\x06OPTION\x10\x02\x12\x0b\n\x07COMMAND\x10\
    \x03\x12\t\n\x05SHIFT\x10\x04\x12\x0c\n\x08FUNCTION\x10\x05\x12\n\n\x06N\
    UMPAD\x10\x06*:\n\rVariableScope\x12\x0b\n\x07SESSION\x10\x01\x12\x07\n\
    \x03TAB\x10\x02\x12\n\n\x06WINDOW\x10\x03\x12\x07\n\x03APP\x10\x04*C\n\
    \x11PromptMonitorMode\x12\n\n\x06PROMPT\x10\x01\x12\x11\n\rCOMMAND_START\
    \x10\x02\x12\x0f\n\x0bCOMMAND_END\x10\x03*G\n\x0eAlternateColor\x12\x0b\
    \n\x07DEFAULT\x10\0\x12\x14\n\x10REVERSED_DEFAULT\x10\x03\x12\x12\n\x0eS\
    YSTEM_MESSAGE\x10\x04*7\n\x14ImagePlaceholderType\x12\x08\n\x04NONE\x10\
    \0\x12\n\n\x06ITERM2\x10\x01\x12\t\n\x05KITTY\x10\x02B\x06\xa2\x02\x03IT\
    Mb\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(172);
            messages.push(ClientOriginatedMessage::generated_message_descriptor_data());
            messages.push(ServerOriginatedMessage::generated_message_descriptor_data());
            messages.push(InvokeFunctionRequest::generated_message_descriptor_data());
            messages.push(InvokeFunctionResponse::generated_message_descriptor_data());
            messages.push(CloseRequest::generated_message_descriptor_data());
            messages.push(CloseResponse::generated_message_descriptor_data());
            messages.push(SetBroadcastDomainsRequest::generated_message_descriptor_data());
            messages.push(SetBroadcastDomainsResponse::generated_message_descriptor_data());
            messages.push(StatusBarComponentRequest::generated_message_descriptor_data());
            messages.push(StatusBarComponentResponse::generated_message_descriptor_data());
            messages.push(WindowedCoordRange::generated_message_descriptor_data());
            messages.push(SubSelection::generated_message_descriptor_data());
            messages.push(Selection::generated_message_descriptor_data());
            messages.push(SelectionRequest::generated_message_descriptor_data());
            messages.push(SelectionResponse::generated_message_descriptor_data());
            messages.push(ColorPresetRequest::generated_message_descriptor_data());
            messages.push(ColorPresetResponse::generated_message_descriptor_data());
            messages.push(PreferencesRequest::generated_message_descriptor_data());
            messages.push(PreferencesResponse::generated_message_descriptor_data());
            messages.push(ReorderTabsRequest::generated_message_descriptor_data());
            messages.push(ReorderTabsResponse::generated_message_descriptor_data());
            messages.push(TmuxRequest::generated_message_descriptor_data());
            messages.push(TmuxResponse::generated_message_descriptor_data());
            messages.push(GetBroadcastDomainsRequest::generated_message_descriptor_data());
            messages.push(BroadcastDomain::generated_message_descriptor_data());
            messages.push(GetBroadcastDomainsResponse::generated_message_descriptor_data());
            messages.push(SetTabLayoutRequest::generated_message_descriptor_data());
            messages.push(SetTabLayoutResponse::generated_message_descriptor_data());
            messages.push(MenuItemRequest::generated_message_descriptor_data());
            messages.push(MenuItemResponse::generated_message_descriptor_data());
            messages.push(RestartSessionRequest::generated_message_descriptor_data());
            messages.push(RestartSessionResponse::generated_message_descriptor_data());
            messages.push(ServerOriginatedRPCResultRequest::generated_message_descriptor_data());
            messages.push(ServerOriginatedRPCResultResponse::generated_message_descriptor_data());
            messages.push(ListProfilesRequest::generated_message_descriptor_data());
            messages.push(ListProfilesResponse::generated_message_descriptor_data());
            messages.push(FocusRequest::generated_message_descriptor_data());
            messages.push(FocusResponse::generated_message_descriptor_data());
            messages.push(SavedArrangementRequest::generated_message_descriptor_data());
            messages.push(SavedArrangementResponse::generated_message_descriptor_data());
            messages.push(VariableRequest::generated_message_descriptor_data());
            messages.push(VariableResponse::generated_message_descriptor_data());
            messages.push(ActivateRequest::generated_message_descriptor_data());
            messages.push(ActivateResponse::generated_message_descriptor_data());
            messages.push(InjectRequest::generated_message_descriptor_data());
            messages.push(InjectResponse::generated_message_descriptor_data());
            messages.push(GetPropertyRequest::generated_message_descriptor_data());
            messages.push(GetPropertyResponse::generated_message_descriptor_data());
            messages.push(SetPropertyRequest::generated_message_descriptor_data());
            messages.push(SetPropertyResponse::generated_message_descriptor_data());
            messages.push(RegisterToolRequest::generated_message_descriptor_data());
            messages.push(RPCRegistrationRequest::generated_message_descriptor_data());
            messages.push(RegisterToolResponse::generated_message_descriptor_data());
            messages.push(KeystrokePattern::generated_message_descriptor_data());
            messages.push(KeystrokeMonitorRequest::generated_message_descriptor_data());
            messages.push(KeystrokeFilterRequest::generated_message_descriptor_data());
            messages.push(VariableMonitorRequest::generated_message_descriptor_data());
            messages.push(ProfileChangeRequest::generated_message_descriptor_data());
            messages.push(PromptMonitorRequest::generated_message_descriptor_data());
            messages.push(NotificationRequest::generated_message_descriptor_data());
            messages.push(NotificationResponse::generated_message_descriptor_data());
            messages.push(Notification::generated_message_descriptor_data());
            messages.push(ProfileChangedNotification::generated_message_descriptor_data());
            messages.push(VariableChangedNotification::generated_message_descriptor_data());
            messages.push(BroadcastDomainsChangedNotification::generated_message_descriptor_data());
            messages.push(ServerOriginatedRPC::generated_message_descriptor_data());
            messages.push(ServerOriginatedRPCNotification::generated_message_descriptor_data());
            messages.push(KeystrokeNotification::generated_message_descriptor_data());
            messages.push(ScreenUpdateNotification::generated_message_descriptor_data());
            messages.push(PromptNotificationPrompt::generated_message_descriptor_data());
            messages.push(PromptNotificationCommandStart::generated_message_descriptor_data());
            messages.push(PromptNotificationCommandEnd::generated_message_descriptor_data());
            messages.push(PromptNotification::generated_message_descriptor_data());
            messages.push(LocationChangeNotification::generated_message_descriptor_data());
            messages.push(CustomEscapeSequenceNotification::generated_message_descriptor_data());
            messages.push(NewSessionNotification::generated_message_descriptor_data());
            messages.push(FocusChangedNotification::generated_message_descriptor_data());
            messages.push(TerminateSessionNotification::generated_message_descriptor_data());
            messages.push(LayoutChangedNotification::generated_message_descriptor_data());
            messages.push(GetBufferRequest::generated_message_descriptor_data());
            messages.push(GetBufferResponse::generated_message_descriptor_data());
            messages.push(GetPromptRequest::generated_message_descriptor_data());
            messages.push(GetPromptResponse::generated_message_descriptor_data());
            messages.push(ListPromptsRequest::generated_message_descriptor_data());
            messages.push(ListPromptsResponse::generated_message_descriptor_data());
            messages.push(GetProfilePropertyRequest::generated_message_descriptor_data());
            messages.push(ProfileProperty::generated_message_descriptor_data());
            messages.push(GetProfilePropertyResponse::generated_message_descriptor_data());
            messages.push(SetProfilePropertyRequest::generated_message_descriptor_data());
            messages.push(SetProfilePropertyResponse::generated_message_descriptor_data());
            messages.push(TransactionRequest::generated_message_descriptor_data());
            messages.push(TransactionResponse::generated_message_descriptor_data());
            messages.push(LineRange::generated_message_descriptor_data());
            messages.push(Range::generated_message_descriptor_data());
            messages.push(CoordRange::generated_message_descriptor_data());
            messages.push(Coord::generated_message_descriptor_data());
            messages.push(RGBColor::generated_message_descriptor_data());
            messages.push(URL::generated_message_descriptor_data());
            messages.push(CellStyle::generated_message_descriptor_data());
            messages.push(LineContents::generated_message_descriptor_data());
            messages.push(CodePointsPerCell::generated_message_descriptor_data());
            messages.push(ListSessionsRequest::generated_message_descriptor_data());
            messages.push(SendTextRequest::generated_message_descriptor_data());
            messages.push(SendTextResponse::generated_message_descriptor_data());
            messages.push(Size::generated_message_descriptor_data());
            messages.push(Point::generated_message_descriptor_data());
            messages.push(Frame::generated_message_descriptor_data());
            messages.push(SessionSummary::generated_message_descriptor_data());
            messages.push(SplitTreeNode::generated_message_descriptor_data());
            messages.push(ListSessionsResponse::generated_message_descriptor_data());
            messages.push(CreateTabRequest::generated_message_descriptor_data());
            messages.push(CreateTabResponse::generated_message_descriptor_data());
            messages.push(SplitPaneRequest::generated_message_descriptor_data());
            messages.push(SplitPaneResponse::generated_message_descriptor_data());
            messages.push(invoke_function_request::Tab::generated_message_descriptor_data());
            messages.push(invoke_function_request::Session::generated_message_descriptor_data());
            messages.push(invoke_function_request::Window::generated_message_descriptor_data());
            messages.push(invoke_function_request::App::generated_message_descriptor_data());
            messages.push(invoke_function_request::Method::generated_message_descriptor_data());
            messages.push(invoke_function_response::Error::generated_message_descriptor_data());
            messages.push(invoke_function_response::Success::generated_message_descriptor_data());
            messages.push(close_request::CloseTabs::generated_message_descriptor_data());
            messages.push(close_request::CloseSessions::generated_message_descriptor_data());
            messages.push(close_request::CloseWindows::generated_message_descriptor_data());
            messages.push(status_bar_component_request::OpenPopover::generated_message_descriptor_data());
            messages.push(selection_request::GetSelectionRequest::generated_message_descriptor_data());
            messages.push(selection_request::SetSelectionRequest::generated_message_descriptor_data());
            messages.push(selection_response::GetSelectionResponse::generated_message_descriptor_data());
            messages.push(selection_response::SetSelectionResponse::generated_message_descriptor_data());
            messages.push(color_preset_request::ListPresets::generated_message_descriptor_data());
            messages.push(color_preset_request::GetPreset::generated_message_descriptor_data());
            messages.push(color_preset_response::ListPresets::generated_message_descriptor_data());
            messages.push(color_preset_response::GetPreset::generated_message_descriptor_data());
            messages.push(color_preset_response::get_preset::ColorSetting::generated_message_descriptor_data());
            messages.push(preferences_request::Request::generated_message_descriptor_data());
            messages.push(preferences_request::request::SetPreference::generated_message_descriptor_data());
            messages.push(preferences_request::request::GetPreference::generated_message_descriptor_data());
            messages.push(preferences_request::request::SetDefaultProfile::generated_message_descriptor_data());
            messages.push(preferences_request::request::GetDefaultProfile::generated_message_descriptor_data());
            messages.push(preferences_response::Result::generated_message_descriptor_data());
            messages.push(preferences_response::result::SetPreferenceResult::generated_message_descriptor_data());
            messages.push(preferences_response::result::GetPreferenceResult::generated_message_descriptor_data());
            messages.push(preferences_response::result::SetDefaultProfileResult::generated_message_descriptor_data());
            messages.push(preferences_response::result::UnrecognizedResult::generated_message_descriptor_data());
            messages.push(preferences_response::result::GetDefaultProfileResult::generated_message_descriptor_data());
            messages.push(reorder_tabs_request::Assignment::generated_message_descriptor_data());
            messages.push(tmux_request::ListConnections::generated_message_descriptor_data());
            messages.push(tmux_request::SendCommand::generated_message_descriptor_data());
            messages.push(tmux_request::SetWindowVisible::generated_message_descriptor_data());
            messages.push(tmux_request::CreateWindow::generated_message_descriptor_data());
            messages.push(tmux_response::ListConnections::generated_message_descriptor_data());
            messages.push(tmux_response::SendCommand::generated_message_descriptor_data());
            messages.push(tmux_response::SetWindowVisible::generated_message_descriptor_data());
            messages.push(tmux_response::CreateWindow::generated_message_descriptor_data());
            messages.push(tmux_response::list_connections::Connection::generated_message_descriptor_data());
            messages.push(list_profiles_response::Profile::generated_message_descriptor_data());
            messages.push(variable_request::Set::generated_message_descriptor_data());
            messages.push(activate_request::App::generated_message_descriptor_data());
            messages.push(rpcregistration_request::RPCArgumentSignature::generated_message_descriptor_data());
            messages.push(rpcregistration_request::RPCArgument::generated_message_descriptor_data());
            messages.push(rpcregistration_request::SessionTitleAttributes::generated_message_descriptor_data());
            messages.push(rpcregistration_request::StatusBarComponentAttributes::generated_message_descriptor_data());
            messages.push(rpcregistration_request::ContextMenuAttributes::generated_message_descriptor_data());
            messages.push(rpcregistration_request::status_bar_component_attributes::Knob::generated_message_descriptor_data());
            messages.push(rpcregistration_request::status_bar_component_attributes::Icon::generated_message_descriptor_data());
            messages.push(server_originated_rpc::RPCArgument::generated_message_descriptor_data());
            messages.push(focus_changed_notification::Window::generated_message_descriptor_data());
            messages.push(set_profile_property_request::GuidList::generated_message_descriptor_data());
            messages.push(set_profile_property_request::Assignment::generated_message_descriptor_data());
            messages.push(split_tree_node::SplitTreeLink::generated_message_descriptor_data());
            messages.push(list_sessions_response::Window::generated_message_descriptor_data());
            messages.push(list_sessions_response::Tab::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(47);
            enums.push(SelectionMode::generated_enum_descriptor_data());
            enums.push(NotificationType::generated_enum_descriptor_data());
            enums.push(Modifiers::generated_enum_descriptor_data());
            enums.push(VariableScope::generated_enum_descriptor_data());
            enums.push(PromptMonitorMode::generated_enum_descriptor_data());
            enums.push(AlternateColor::generated_enum_descriptor_data());
            enums.push(ImagePlaceholderType::generated_enum_descriptor_data());
            enums.push(invoke_function_response::Status::generated_enum_descriptor_data());
            enums.push(close_response::Status::generated_enum_descriptor_data());
            enums.push(set_broadcast_domains_response::Status::generated_enum_descriptor_data());
            enums.push(status_bar_component_response::Status::generated_enum_descriptor_data());
            enums.push(selection_response::Status::generated_enum_descriptor_data());
            enums.push(color_preset_response::Status::generated_enum_descriptor_data());
            enums.push(preferences_response::result::set_preference_result::Status::generated_enum_descriptor_data());
            enums.push(preferences_response::result::set_default_profile_result::Status::generated_enum_descriptor_data());
            enums.push(reorder_tabs_response::Status::generated_enum_descriptor_data());
            enums.push(tmux_response::Status::generated_enum_descriptor_data());
            enums.push(set_tab_layout_response::Status::generated_enum_descriptor_data());
            enums.push(menu_item_response::Status::generated_enum_descriptor_data());
            enums.push(restart_session_response::Status::generated_enum_descriptor_data());
            enums.push(saved_arrangement_request::Action::generated_enum_descriptor_data());
            enums.push(saved_arrangement_response::Status::generated_enum_descriptor_data());
            enums.push(variable_response::Status::generated_enum_descriptor_data());
            enums.push(activate_response::Status::generated_enum_descriptor_data());
            enums.push(inject_response::Status::generated_enum_descriptor_data());
            enums.push(get_property_response::Status::generated_enum_descriptor_data());
            enums.push(set_property_response::Status::generated_enum_descriptor_data());
            enums.push(register_tool_request::ToolType::generated_enum_descriptor_data());
            enums.push(rpcregistration_request::Role::generated_enum_descriptor_data());
            enums.push(rpcregistration_request::status_bar_component_attributes::Format::generated_enum_descriptor_data());
            enums.push(rpcregistration_request::status_bar_component_attributes::knob::Type::generated_enum_descriptor_data());
            enums.push(register_tool_response::Status::generated_enum_descriptor_data());
            enums.push(notification_response::Status::generated_enum_descriptor_data());
            enums.push(keystroke_notification::Action::generated_enum_descriptor_data());
            enums.push(focus_changed_notification::window::WindowStatus::generated_enum_descriptor_data());
            enums.push(get_buffer_response::Status::generated_enum_descriptor_data());
            enums.push(get_prompt_response::Status::generated_enum_descriptor_data());
            enums.push(get_prompt_response::State::generated_enum_descriptor_data());
            enums.push(list_prompts_response::Status::generated_enum_descriptor_data());
            enums.push(get_profile_property_response::Status::generated_enum_descriptor_data());
            enums.push(set_profile_property_response::Status::generated_enum_descriptor_data());
            enums.push(transaction_response::Status::generated_enum_descriptor_data());
            enums.push(line_contents::Continuation::generated_enum_descriptor_data());
            enums.push(send_text_response::Status::generated_enum_descriptor_data());
            enums.push(create_tab_response::Status::generated_enum_descriptor_data());
            enums.push(split_pane_request::SplitDirection::generated_enum_descriptor_data());
            enums.push(split_pane_response::Status::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
